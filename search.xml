<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[Unix]데이터 관련 프로젝트시 자주 사용하는 commandline 명령어 모음</title>
    <url>/2021/10/08/DE-Linux-commandline/</url>
    <content><![CDATA[<!--


<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="데이터-관련-프로젝트시-자주-사용하는-commandline-명령어-모음"><a href="#데이터-관련-프로젝트시-자주-사용하는-commandline-명령어-모음" class="headerlink" title="데이터 관련 프로젝트시 자주 사용하는 commandline 명령어 모음"></a>데이터 관련 프로젝트시 자주 사용하는 commandline 명령어 모음</h2><h3 id="도움말"><a href="#도움말" class="headerlink" title="도움말"></a>도움말</h3><ul>
<li>man</li>
</ul>
<h3 id="파일관리"><a href="#파일관리" class="headerlink" title="파일관리"></a>파일관리</h3><ul>
<li>pwd</li>
<li>cd</li>
<li>ls</li>
<li>mkdir</li>
<li>rmdir</li>
<li>cp</li>
<li>mv</li>
<li>rm</li>
<li>ln</li>
<li>chmod</li>
</ul>
<h3 id="파일처리"><a href="#파일처리" class="headerlink" title="파일처리"></a>파일처리</h3><ul>
<li>cat</li>
<li>echo</li>
<li>head</li>
<li>tail</li>
<li>more&#x2F;less</li>
<li>grep</li>
<li>sed*</li>
<li>awk*</li>
<li>find*</li>
<li>which</li>
<li>sort</li>
<li>uniq</li>
<li>cut</li>
<li>tr</li>
<li>zip</li>
<li>unzip</li>
<li>gunzip</li>
<li>tar</li>
</ul>
<h3 id="프로세스-관리"><a href="#프로세스-관리" class="headerlink" title="프로세스 관리"></a>프로세스 관리</h3><ul>
<li>top</li>
<li>ps</li>
<li>kill</li>
<li>fg</li>
<li>bg</li>
</ul>
<h3 id="네트워크"><a href="#네트워크" class="headerlink" title="네트워크"></a>네트워크</h3><ul>
<li>ssh</li>
<li>scp</li>
<li>ping</li>
<li>traceroute</li>
<li>curl</li>
<li>finger</li>
<li>who</li>
</ul>
<h3 id="편집기"><a href="#편집기" class="headerlink" title="편집기"></a>편집기</h3><ul>
<li>vi</li>
<li>vim</li>
<li>nvim </li>
<li>nano</li>
</ul>
<h3 id="파이프와-리디렉션"><a href="#파이프와-리디렉션" class="headerlink" title="파이프와 리디렉션"></a>파이프와 리디렉션</h3><h3 id="셀-환경변수"><a href="#셀-환경변수" class="headerlink" title="셀 환경변수"></a>셀 환경변수</h3><ul>
<li>export</li>
<li>$path</li>
<li>$ps1</li>
</ul>
<h3 id="Unsorted"><a href="#Unsorted" class="headerlink" title="Unsorted"></a>Unsorted</h3><ul>
<li>cal</li>
<li>history</li>
</ul>
<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li>따라하며 배우는 데이터과학 (책)</li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>commandline</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[Pyspark]하둡의 컨셉 이해하기</title>
    <url>/2022/06/22/DE-Pyspark-Hadoop.md/</url>
    <content><![CDATA[<h2 id="하둡"><a href="#하둡" class="headerlink" title="하둡"></a>하둡</h2><p>: 하둡은 Data Locality에 바탕을 둔 분산컴퓨팅을 위한 소프트웨어 플랫폼 및 프레임워크이다. 기본적인 컨셉은 분산처리(큰 문제를 작은 문제의 집합으로 나누고 정리하는 것)이다.</p>
<p>하둡은 HDFS (Hadoop Distributed File System) 와 YARN(Yet Another Resource Navigator)로 구성된다.</p>
<ul>
<li>하둡은 데이터가 비공유 접근을 허용하는 클러스터의 노드에서 지역적으로 처리될 수 있게 한다</li>
<li>각 노드는 다른 노드들과 통신할 필요 없이 전체 데이터의 훨씬 작은 부분을 독립적으로 처리할 수 있다.</li>
<li>기본적으로 분산시스템이기에 네트워크 연결을 통해 여러 연산자원(노드들)의 사용을 조정한다.</li>
<li>선형적 확장성을 가진다. 이는 노드의 수 , 스토리지의 양 , 잡 루틴이 선형적 관계로 엮여있다는 것을 의미한다. (만약 노드의 수를 늘린다면 그만큼 처리시간이 줄어들 것이라고 예측할 수 있다.)</li>
</ul>
<p><strong>데이터가 기본적으로 분산되어있고 확장가능하며(노드의 수를 늘리는 방식으로) 오류에 대처할 수 있다.</strong></p>
<p>이는 분산파일시스템의 구현을 통해 가능해진다.</p>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>-Pyspark</tag>
      </tags>
  </entry>
  <entry>
    <title>[DDL]Table 구조 다루기</title>
    <url>/2021/07/05/DE-SQL-DDL-tables/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="Data-Definition"><a href="#Data-Definition" class="headerlink" title="Data Definition"></a>Data Definition</h2><ul>
<li><code>ALTER</code>는 DB구조를 변경하는데 쓴다.</li>
<li><code>TRUNCATE</code>는 데이터를 삭제하는데 쓴다.</li>
<li><code>DROP</code>은 테이블 자체를 삭제한다.</li>
</ul>
<h3 id="테이블-데이터-다루기"><a href="#테이블-데이터-다루기" class="headerlink" title="테이블 데이터 다루기"></a>테이블 데이터 다루기</h3><ul>
<li>테이블 생성</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t ( id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">                 name <span class="type">VARCHAR</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">                 price <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>테이블 삭제</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>새 컬럼 추가</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> <span class="keyword">COLUMN</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>새 제약조건 추가</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>제약조건 삭제</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>테이블명 변경</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t RENAME <span class="keyword">to</span> t2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>컬럼명 변경</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> t1 RENAME c1 <span class="keyword">to</span> c2;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>테이블 데이터 삭제</li>
</ul>
<p>테이블 구조는 남기고 데이터를 전부 날린다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> t;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://www.mysqltutorial.org/mysql-join/">mysql tutorial</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[SQL]WHERE절의 이해</title>
    <url>/2022/06/15/DE-SQL-Where/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="Where-절"><a href="#Where-절" class="headerlink" title="Where 절"></a>Where 절</h2><p>조건생성을 위해 Where절을 사용한다.</p>
<h4 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h4><ul>
<li>특정 칼럼의 값이 시작점, 끝점인 데이터만 출력</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> ordersdetails</span><br><span class="line"><span class="keyword">where</span> priceeach <span class="keyword">between</span> <span class="number">30</span> <span class="keyword">and</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h4 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h4><ul>
<li>or 연산자</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> customernumber</span><br><span class="line"><span class="keyword">from</span> customers</span><br><span class="line"><span class="keyword">where</span> country <span class="keyword">in</span> (<span class="string">&#x27;USA&#x27;</span>,<span class="string">&#x27;CANADA&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h4><ul>
<li>null 데이터 출력</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> copang_main.member <span class="keyword">where</span> ADDRESS <span class="keyword">is</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> copang_main.member <span class="keyword">where</span> address <span class="keyword">is</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> copang_main.member <span class="keyword">where</span></span><br><span class="line">address <span class="keyword">is</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">OR</span> height <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">OR</span> weight <span class="keyword">IS</span> <span class="keyword">NULL</span>; # 세 컬럼중 하나라도 <span class="keyword">null</span>이 있는 로우만 조회</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> # coalesce</span><br><span class="line">    <span class="built_in">coalesce</span>(height,<span class="string">&#x27;####&#x27;</span>), # <span class="keyword">null</span>이 아닌 값은 그대로 반환, <span class="keyword">null</span>일 경우 입력한 값 반환</span><br><span class="line">    <span class="built_in">coalesce</span>(weight,<span class="string">&#x27;----&#x27;</span>),</span><br><span class="line">    <span class="built_in">coalesce</span>(address,<span class="string">&#x27;@@@@&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> copang_main.`<span class="keyword">member</span>`;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>NULL 변환함수</strong></p>
<ol>
<li><p>coalesce : 첫번째로 null이 아닌 값을 반환</p>
</li>
<li><p>ifnull : 첫번째 인자가 null인 경우 두번째 인자, 아닐 경우 해당 값 표현</p>
</li>
<li><p>if(a1,a2,a3) : ifelse 처럼 사용가능</p>
</li>
</ol>
<h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><ul>
<li>문자열 매칭하기</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> main.`<span class="keyword">member</span>` <span class="keyword">WHERE</span> address <span class="keyword">like</span> <span class="string">&#x27;서울%&#x27;</span>; # address가 서울로 시작하는 <span class="type">row</span> 조회</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> main.`<span class="keyword">member</span>` <span class="keyword">WHERE</span> address <span class="keyword">like</span> <span class="string">&#x27;%고양시%&#x27;</span>; # 고양시라는 단어 앞뒤로 임의의 길이를 가진 문자열 조건</span><br></pre></td></tr></table></figure>


<h4 id="이스케이핑-문제"><a href="#이스케이핑-문제" class="headerlink" title="이스케이핑 문제"></a>이스케이핑 문제</h4><ul>
<li>어떤 문자가 그것에 부여된 특정한 의미,기능으로 해석되는 것이 아니라 단순한 문자 하나도 해석되게끔 하는 것을 <code>이스케이핑</code>이라 한다.</li>
<li>‘ 이스케이핑 -&gt; select * from copang_main.test where sentence like ‘%&#39;%’</li>
<li>_ 이스케이핑 -&gt; select * from copang_main.test where sentence like ‘%_%’</li>
<li>“ 이스케이핑 -&gt; select * from copang_main.test where sentence like ‘%&quot;&quot;%’</li>
<li>대문자 제외 소문자 찾기 select * from copang_main.test where sentence like binary ‘%g%’</li>
</ul>
<h4 id="ANY"><a href="#ANY" class="headerlink" title="ANY"></a>ANY</h4><ul>
<li><strong>ANY는 나올 수 있는 모든 조건에 OR 연산을 수행한것과 동일한 결과 반환</strong></li>
<li>수량이 10개인 제품 전부 반환</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="keyword">ANY</span></span><br><span class="line">  (<span class="keyword">SELECT</span> ProductID</span><br><span class="line">  <span class="keyword">FROM</span> OrderDetails</span><br><span class="line">  <span class="keyword">WHERE</span> Quantity <span class="operator">=</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>수량이 1000개 초과인 제품 전부 반환</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="keyword">ANY</span></span><br><span class="line">  (<span class="keyword">SELECT</span> ProductID</span><br><span class="line">  <span class="keyword">FROM</span> OrderDetails</span><br><span class="line">  <span class="keyword">WHERE</span> Quantity <span class="operator">&gt;</span> <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><ul>
<li>조건을 모두 만족하는 행을 반환</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ProductName</span><br><span class="line"><span class="keyword">FROM</span> Products</span><br><span class="line"><span class="keyword">WHERE</span> ProductID <span class="operator">=</span> <span class="keyword">ALL</span></span><br><span class="line">  (<span class="keyword">SELECT</span> ProductID</span><br><span class="line">  <span class="keyword">FROM</span> OrderDetails</span><br><span class="line">  <span class="keyword">WHERE</span> Quantity <span class="operator">=</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h4><ul>
<li>EXISTS는 행의 존재 여부를 확인하여 True&#x2F;False 값을 반환</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> SupplierName</span><br><span class="line"><span class="keyword">FROM</span> Suppliers</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> ProductName <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> Products.SupplierID <span class="operator">=</span> Suppliers.supplierID <span class="keyword">AND</span> Price <span class="operator">=</span> <span class="number">22</span>);</span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li>SQL로 맛보는 데이터 전처리분석</li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[SQL]간단한 CASE WHEN 용법</title>
    <url>/2022/06/15/DE-SQL-case-when/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>간단한 mysql case when 용법 정리</strong></p>
<hr>
<h3 id="Case-When"><a href="#Case-When" class="headerlink" title="Case When"></a>Case When</h3><ul>
<li>기본적으로 파생변수(컬럼)를 생성하는데 사용한다.</li>
<li>파생변수이기 때문에 Select절 에 들어간다.</li>
</ul>
<h4 id="Case-When-용법"><a href="#Case-When-용법" class="headerlink" title="Case When 용법"></a>Case When 용법</h4><p>용법은 어렵지 않다. 파생변수 Select 절에 들어가는 것만 주의</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> player_name,</span><br><span class="line">       weight,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> weight <span class="operator">&gt;</span> <span class="number">250</span> <span class="keyword">THEN</span> <span class="string">&#x27;over 250&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> weight <span class="operator">&gt;</span> <span class="number">200</span> <span class="keyword">THEN</span> <span class="string">&#x27;201-250&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> weight <span class="operator">&gt;</span> <span class="number">175</span> <span class="keyword">THEN</span> <span class="string">&#x27;176-200&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;175 or under&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> weight_group</span><br><span class="line">  <span class="keyword">FROM</span> benn.college_football_players</span><br></pre></td></tr></table></figure>

<ul>
<li>order by에 사용힐 컬럼 생성</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CustomerName, City, Country</span><br><span class="line"><span class="keyword">FROM</span> Customers</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">(<span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> City <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> Country</span><br><span class="line">    <span class="keyword">ELSE</span> City</span><br><span class="line"><span class="keyword">END</span>);</span><br></pre></td></tr></table></figure>


<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> animal_id, name,</span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line">    <span class="keyword">when</span> sex_upon_intake <span class="keyword">like</span> &quot;Intact%&quot; <span class="keyword">then</span> &quot;O&quot;</span><br><span class="line">    <span class="keyword">else</span> &quot;X&quot; </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> &quot;중성화&quot;</span><br><span class="line"><span class="keyword">from</span> animal_ins</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> animal_id</span><br></pre></td></tr></table></figure>


<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://www.w3schools.com/sql/sql_case.asp">https://www.w3schools.com/sql/sql_case.asp</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[SQL]서브쿼리 정리</title>
    <url>/2022/06/15/DE-SQL-subquery/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="간단한-서브쿼리-종류와-용법-정리"><a href="#간단한-서브쿼리-종류와-용법-정리" class="headerlink" title="간단한 서브쿼리 종류와 용법 정리"></a><strong>간단한 서브쿼리 종류와 용법 정리</strong></h2><h3 id="Subquery"><a href="#Subquery" class="headerlink" title="Subquery"></a>Subquery</h3><hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>서브쿼리</strong> : 서브쿼리는 하나의 SQL쿼리 안에 포함된 다른 SQL쿼리를 말한다.</li>
</ul>
<hr>
<ul>
<li><p><strong>서브쿼리 사용상황</strong></p>
<ul>
<li>가장 기본적으로 알려지지 않은 조건을 사용해서 조회해야할 때</li>
<li>DB에 접근하는 속도를 향상시킬 때</li>
</ul>
</li>
<li><p><strong>사용시 주의점</strong></p>
<ul>
<li>항상 괄호로 감싸서 사용할 것</li>
<li>서브쿼리의 결과가 2건 이상이라면(다중행) <strong>반드시</strong> 비교연산자와 함께 사용한다, </li>
<li>서브쿼리 내에서는 order by 사용 못함( order by는 쿼리에서 하나만 사용)</li>
<li>서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다.</li>
<li>질의 결과에 서브쿼리 컬럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 한다.</li>
</ul>
</li>
<li><p><strong>종류</strong></p>
<ul>
<li>단일 행 서브쿼리 : 특정 행을 반환. 이 행을 조건절도도 사용가능<ul>
<li>ex) 평균값알아내는 서브쿼리를 통해 평균값 이상의 그룹을 출력</li>
</ul>
</li>
</ul>
<ul>
<li>다중행 서브쿼리 : 결과가 2건이상 반환되는 서브쿼리. 반드시 비교연산자와 함께 사용. Where 절에 괄호로 들어간다.<ul>
<li>IN(서브쿼리) : 서브쿼리의 결과에 존재하는 값과 동일한 조건의미</li>
<li>ALL(서브쿼리) : 모든 값을 만족하는 조건</li>
<li>ANY(서브쿼리) : 비교연산자에 “&gt;” 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에 결과중에 가장 작은값보다 크면 만족한다.</li>
<li>EXIST(서브쿼리) :  서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인. 존재유무만 확인하기에 1건만 찾으면 더 이상검색안함</li>
</ul>
</li>
<li>다중 컬럼 서브쿼리 : 서브쿼리 결과로 <strong>여러 개의 컬럼이 반환</strong>되어 메인쿼리 조건과 동시에 비교되는 것.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 다둥컬럼 서브퉈리 예시</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> ord_num, agent_code, ord_date, ord_amount</span><br><span class="line"><span class="keyword">from</span> orders</span><br><span class="line"><span class="keyword">where</span>(agent_code, ord_amount) <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> agent_code, <span class="built_in">MIN</span>(ord_amount)</span><br><span class="line"><span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> agent_code);  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Where-절의-Subquery"><a href="#Where-절의-Subquery" class="headerlink" title="Where 절의 Subquery"></a>Where 절의 Subquery</h4><ul>
<li><p>비교연산자 IN 사용</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 특정 행 반환</span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id, first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> </span><br><span class="line">            department_id</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            departments</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            location_id <span class="operator">=</span> &quot;찾는 아이디&quot;)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name , last_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>MAX나 MIN 사용</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># <span class="keyword">where</span> 절에서 서브쿼리로 정의한 조건을 <span class="keyword">select</span> 절에 쓸 수 있다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id, first_name, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    salary <span class="operator">=</span> (<span class="keyword">SELECT</span> </span><br><span class="line">            <span class="built_in">MAX</span>(salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            employees)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> first_name , last_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>AVG로 조건걸기</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    employee_id, first_name, last_name, salary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    employees</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> </span><br><span class="line">            <span class="built_in">AVG</span>(salary)</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            employees);    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>서브쿼리 조건문처럼 사용하기</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> tutorial.sf_crime_incidents_2014_01</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="type">Date</span> <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(<span class="type">date</span>)</span><br><span class="line">                 <span class="keyword">FROM</span> tutorial.sf_crime_incidents_2014_01</span><br><span class="line">              )</span><br></pre></td></tr></table></figure>



<h4 id="FROM-절의-Subquery-Inline-View"><a href="#FROM-절의-Subquery-Inline-View" class="headerlink" title="FROM 절의 Subquery(Inline View)"></a>FROM 절의 Subquery(Inline View)</h4><ul>
<li>SQL이 실행될 때만 동적으로 생성되는 Inline view</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">MAX</span>(items), </span><br><span class="line">    <span class="built_in">MIN</span>(items), </span><br><span class="line">    <span class="built_in">FLOOR</span>(<span class="built_in">AVG</span>(items))</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        orderNumber, <span class="built_in">COUNT</span>(orderNumber) <span class="keyword">AS</span> items</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        orderdetails</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> orderNumber) <span class="keyword">AS</span> lineitems;</span><br></pre></td></tr></table></figure>


<ul>
<li>파생테이블은 반드시 alias를 가진다,</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="built_in">substring</span>(address,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">as</span> region,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> review_count</span><br><span class="line"><span class="keyword">from</span> review <span class="keyword">as</span> r <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">member</span> <span class="keyword">as</span> m</span><br><span class="line"><span class="keyword">on</span> r.mem_id <span class="operator">=</span> m.id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">substring</span>(address,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">having</span> region <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">and</span> region <span class="operator">!=</span> <span class="string">&#x27;안드&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(review_count),</span><br><span class="line">       <span class="built_in">max</span>(review_count),</span><br><span class="line">       <span class="built_in">min</span>(review_count)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span></span><br><span class="line">    <span class="built_in">substring</span>(address,<span class="number">1</span>,<span class="number">2</span>) <span class="keyword">as</span> region,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> review_count</span><br><span class="line"><span class="keyword">from</span> review <span class="keyword">as</span> r <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> <span class="keyword">member</span> <span class="keyword">as</span> m</span><br><span class="line"><span class="keyword">on</span> r.mem_id <span class="operator">=</span> m.id</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="built_in">substring</span>(address,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">having</span> region <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">    <span class="keyword">and</span> region <span class="operator">!=</span> <span class="string">&#x27;안드&#x27;</span>) <span class="keyword">as</span> review_count_summary #서브쿼리로 탄생한 파생테이블은 반드시 alias를 가져야 한다</span><br></pre></td></tr></table></figure>


<p>– Join과 서브쿼리 같이 사용하기</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> tutorial.sf_crime_incidents_2014_01 incidents</span><br><span class="line">  <span class="keyword">JOIN</span> ( <span class="keyword">SELECT</span> <span class="type">date</span></span><br><span class="line">           <span class="keyword">FROM</span> tutorial.sf_crime_incidents_2014_01</span><br><span class="line">          <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">date</span></span><br><span class="line">          LIMIT <span class="number">5</span></span><br><span class="line">       ) sub</span><br><span class="line">    <span class="keyword">ON</span> incidents.date <span class="operator">=</span> sub.date</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SELECT-절의-Subquery-Scala-Subquery"><a href="#SELECT-절의-Subquery-Scala-Subquery" class="headerlink" title="SELECT 절의 Subquery(Scala Subquery)"></a>SELECT 절의 Subquery(Scala Subquery)</h4><ul>
<li>SELECT 절 안에 SELECT가 있을 경우 Scala 서브쿼리라 부르며 기본적으로 한 행만 리턴한다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> PLAYER, HEIGHT , (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(HEIGHT)</span><br><span class="line">                         <span class="keyword">FROM</span> PLAYER X</span><br><span class="line">                         <span class="keyword">WHERE</span> X.TEAM_ID <span class="operator">=</span> P.TEAM_ID)</span><br><span class="line"><span class="keyword">FROM</span> PLAYER_P</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>기본적으로 outer join이 적용되어 있다.</li>
<li>쿼리 수행 횟수를 최소화하기 위해서 입력값과 출력값을 내부 캐시에 저장한다.</li>
<li>대용량 데이터를 처리할 경우 속도가 느려질 수 있다.</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> A.PKID</span><br><span class="line">    , A.TITLE</span><br><span class="line">    , NVL(B.NAME, <span class="string">&#x27;탈퇴한 회원&#x27;</span>), B.NAME</span><br><span class="line">    , (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> REPLY <span class="keyword">WHERE</span> P_PKID <span class="operator">=</span> B.PKID) <span class="keyword">AS</span> COUNT1</span><br><span class="line"><span class="keyword">FROM</span> BOARD B <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">MEMBER</span> M</span><br><span class="line">    <span class="keyword">ON</span> B.MEM_NO <span class="operator">=</span> M.PKID</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://mode.com/sql-tutorial/sql-sub-queries/">https://mode.com/sql-tutorial/sql-sub-queries/</a></li>
<li><a href="https://www.mysqltutorial.org/mysql-subquery/">https://www.mysqltutorial.org/mysql-subquery/</a></li>
</ul>
]]></content>
      <categories>
        <category>Data Engineering</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Subquery</tag>
      </tags>
  </entry>
  <entry>
    <title>[Neural Network]Recurrent Neural Network</title>
    <url>/2022/06/15/DL-RNN/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>굵은 글씨로 뭔가 쓴다.</strong></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
      <tags>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>[Neural Network]역전파 알고리즘(backpropagation)</title>
    <url>/2021/09/28/DL-backpropagation/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling

https://edgeaiguru.com/Feedforward-and-Backpropagation
# 

https://www.youtube.com/watch?v=aircAruvnKk

#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>순전파가 입력층에서 신호를 받아 은닉층의 가중치(+bias)와 연산을 한 뒤 출력층에서 벡터를 출력하는 과정이라면<br>역전파는 예측값과 실제값의 차이(에러)를 줄이기 위해  손실함수가 최소가 되도록 출력층으로부터 순전파의 역방향으로 편미분을 통해 가중치를 업데이트 하는 것이다. 간단히 역전파의 컨셉을 알아보자.</strong></p>
<hr>
<h2 id="역전파-알고리즘"><a href="#역전파-알고리즘" class="headerlink" title="역전파 알고리즘"></a>역전파 알고리즘</h2><p><strong>순전파가 입력층에서 신호를 받아 은닉층의 가중치(+bias)와 연산을 한 뒤 출력층에서 벡터를 출력하는 과정이라면 역전파는 예측값과 실제값의 차이(에러)를 줄이기 위해  손실함수가 최소가 되도록 출력층으로부터 순전파의 역방향으로 편미분을 통해 가중치를 업데이트 하는 것이다.</strong></p>
<p>역전파 알고리즘에서 가중치를 업데이트 한다는 것은 가중치 매개변수의 기울기(Graidant)를 예측값을 바탕으로 다시 계산한다는 것이다.</p>
<p>기본적으로 <strong>타겟과 예측값의 차이를 줄이기 위해</strong> 가중치를 업데이트한다.</p>
<p>$$<br> y &#x3D; activiate(\sum(\theta_{1}x_{1} + \theta_{2}x_{2} + … + \theta_{n}x_{n}) + bias)$$</p>
<p>타겟과 예측값의 차이는 <code>loss function(cost function)</code>이라고 볼 수 있다.</p>
<p>비용함수는 수식으로 나타내면 아래와 같다.</p>
<p>$$J(\theta) &#x3D; y - h_\theta(x)$$<br>여기서 $h_\theta(x)$ 는 가설함수(모형)이다.</p>
<p>역전파(backward Propagation)는 예측값의 국소적 미분값을 순전파(Forward Propagation)의 반대방향으로 곱한 후 다음노드로 전달하는 것이다.</p>
<p>비용함수의 편미분을 통해 기울기를 구하는 이유는 <strong>기울기가 비용함수의 값을 최소화 하는 방향을 제시하기 때문이다.</strong></p>
<p><img src="https://i.imgur.com/Olxv64J.png"></p>
<center><b>그림 1. Gradiant Boosting을 통한 global optimum 찾기</b></center>


<p>만약 모형의 loss function이 MSE(Mear Sqared Error)일 경우, 비용함수는 아래와 같이 나타낼 수 있다. (m은 sample의 수를 의미)</p>
<p>$$ J(\theta)&#x3D;\frac{1}{2 m} \sum_{i&#x3D;1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)^{2}$$</p>
<p>이를 미분할 경우 직접 계산하기 어렵거나 불가능하기 때문에 Chain Rule을 사용한 합성함수의 편미분을 통해 구한다.</p>
<p>아래와 같은 신경망이 있고 output node의 활성화함수는 sigmoid라고 할 경우</p>
<p><img src="https://i.imgur.com/bGCvYVJ.png"></p>
<center><b>그림 2. 신경망으로 나타낸 backpropagation</b></center>

<p>하나의 가중치에 대한 Gradiant를 아래와 같이 나타날 수 있다.</p>
<p>$$ Gradiant&#x3D;\frac{\partial J(\theta)}{\partial \theta_{i}}&#x3D;\frac{\frac{1}{2 m} \sum_{i&#x3D;1}^{m}\left(y^{(i)}-\hat{y}^{(i)}\right)} {\partial \theta_{i}}$$</p>
<p>이 때 분자는 가중치 $\theta_i$에 대해 미분할 수 없기 때문에 아래와 같이 <code>Chain Rule</code> 을 사용해서 Gradiant를 도출한다.</p>
<p>$$\frac{\partial J(\theta)}{\partial \theta_{i}} &#x3D;\frac{\partial J(\theta)}{\partial z_{2}} \times \frac{\partial z_{2}}{\partial s_{2}} \times \frac{\partial s_{2}}{\partial \theta_{i}}  $$</p>
<p><strong>chain rule(연쇄법칙)</strong><br>chain rule은 합성함수의 미분규칙이며 역전파과정에서 Gradiant를 도출할 때 사용된다.</p>
<p>기본적으로 바깥함수의 도함수에 안쪽함수를 인자로 넣어주고 안쪽함수의 도함수를 곱해주면 된다.</p>
<p><img src="https://i.imgur.com/4eSVZW0.png"></p>
<center><b>그림 3. Chain Rule 예시</b></center>


<p><strong>가중치 업데이트</strong></p>
<p>도출된 값을 learning rate와 곱해서 기존 가중치에서 빼주면 새로운 가중치는 다음과 같이 나타낼 수 있다.</p>
<p>$$\theta_{j}&#x3D;\theta_{j}-\eta \frac{\partial}{\partial \theta_{j}} J(\theta)$$</p>
<p><strong>결국 순전파와 역전파를 통해 가중치와 편향을 훈련데이터에 적응하도록 조정하는 과정이  기계학습에서의 <code>학습</code>이라는 것을 알 수 있다.</strong></p>
<h3 id="신경망-학습-알고리즘-절차-정리"><a href="#신경망-학습-알고리즘-절차-정리" class="headerlink" title="신경망 학습 알고리즘 절차 정리"></a>신경망 학습 알고리즘 절차 정리</h3><p>퍼셉트론과 역전파 알고리즘에 대한 이해를 바탕으로 지금까지의 절차를 아래와 같이 정리할 수 있다.</p>
<ol>
<li><p>학습할 신경망 구조를 선택</p>
<ul>
<li>입력층 유닛의 수 &#x3D; Feature 수 (input layer)</li>
<li>출력층 유닛의 수 &#x3D; target class 수 (output layer)</li>
<li>은닉층 수, 각 은닉층의 노드 수 (hidden layer)<ul>
<li>hyperparameter의 영역이다. </li>
<li>sqrt(input layer 수 * output layer 수 ) 로 구해줄 수 있지만 방식이 정해진 것은 아니다.</li>
</ul>
</li>
</ul>
</li>
<li><p>가중치 초기화</p>
</li>
<li><p>순방향 전파를 통해 $h_{\theta}(x^{(i)})$(출력층 y값) 을 모든 입력 $x^{(i)}$에 대해 계산</p>
<ul>
<li>입력벡터와 가중치벡터의 내적을 산출<br>비용함수 $J(\theta)$를 계산</li>
</ul>
</li>
<li><p>역방향 전파를 통해 편미분 값들 $\frac{\delta}{\delta\theta_{jk}^{l}}{J(\theta)}$ 을 계산</p>
</li>
<li><p>optimizer를 통해 loss function을 최소화</p>
</li>
<li><p>어떤 중지 기준을 충족하거나 비용함수를 최소화 할 때까지 단계 2-5를 반복한다.</p>
<ul>
<li>한번 학습할때의 sample의 size 를 <code>batch</code> 라고 한다.</li>
<li>전체 sample에 대해 2-5 의 과정을 반복한 것을 <code>epoch</code>라고 한다.</li>
<li><code>iteration</code>은 batch 기준으로 학습의 횟수를 카운팅 한 것이다. 100개의 sample의 batch가 50이고 epoch를 50으로 할 경우 전체 iteration의 수는 100이 된다.</li>
</ul>
</li>
</ol>
<h3 id="머신러닝에서의-학습"><a href="#머신러닝에서의-학습" class="headerlink" title="머신러닝에서의 학습"></a>머신러닝에서의 학습</h3><p>미분은 순간의 변화율을 구하는 것이다.<br><strong>역전파는 모형에서 계산한 예측값과 실제값의 차이를 바탕으로 미분을 통해 가중치를 보정하는 것을 최대한 반복해서 수행하는 것이다.</strong><br>구체적으로는 손실함수의 국소적 미분값(local deravitive)를 구해서 학습률과 곱한 값을 기존 가중치에서 빼주는 것을 손실함수가 최소가 될 때까지 반복하는 것이다.<br><code>손실함수의 각 피처에 대한 편미분을 벡터로 묶은 것을 그래디언트(Gradient)라고 부른다.</code><br>결국 역전파는 Gradiant를 조정하는 것을 반복하는 것이라고 볼 수 있다.<br>결국 순전파와 역전파를 통해 가중치와 편향을 훈련데이터에 적응하도록 조정하는 과정이  기계학습에서의 <code>학습</code>이라는 것을 알 수 있다.</p>
<h2 id="신경망-학습-알고리즘-절차-정리-1"><a href="#신경망-학습-알고리즘-절차-정리-1" class="headerlink" title="신경망 학습 알고리즘 절차 정리"></a>신경망 학습 알고리즘 절차 정리</h2><p>퍼셉트론과 역전파 알고리즘에 대한 이해를 바탕으로 지금까지의 절차를 아래와 같이 정리할 수 있다.</p>
<ol start="0">
<li><p>학습할 신경망 구조를 선택</p>
<ul>
<li>입력층 유닛의 수 &#x3D; Feature 수 (input layer)</li>
<li>출력층 유닛의 수 &#x3D; target class 수 (output layer)</li>
<li>은닉층 수, 각 은닉층의 노드 수 (hidden layer)<ul>
<li>hyperparameter의 영역이다. </li>
<li>sqrt(input layer 수 * output layer 수 ) 로 구해줄 수 있지만 방식이 정해진 것은 아니다.</li>
</ul>
</li>
</ul>
</li>
<li><p>가중치 초기화</p>
</li>
<li><p>순방향 전파를 통해 $h_{\theta}(x^{(i)})$(출력층 y값) 을 모든 입력 $x^{(i)}$에 대해 계산</p>
<ul>
<li>입력벡터와 가중치벡터의 내적을 산출<br>비용함수 $J(\theta)$를 계산</li>
</ul>
</li>
<li><p>역방향 전파를 통해 편미분 값들 $\frac{\delta}{\delta\theta_{jk}^{l}}{J(\theta)}$ 을 계산</p>
</li>
<li><p>optimizer를 통해 loss function을 최소화</p>
</li>
<li><p>어떤 중지 기준을 충족하거나 비용함수를 최소화 할 때까지 단계 2-5를 반복한다.</p>
<ul>
<li>한번 학습할때의 sample의 size 를 <code>batch</code> 라고 한다.</li>
<li>전체 sample에 대해 2-5 의 과정을 반복한 것을 <code>epoch</code>라고 한다.</li>
<li><code>iteration</code>은 batch 기준으로 학습의 횟수를 카운팅 한 것이다. 100개의 sample의 batch가 50이고 epoch를 50으로 할 경우 전체 iteration의 수는 100이 된다.</li>
</ul>
</li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://towardsdatascience.com/understanding-backpropagation-algorithm-7bb3aa2f95fd">https://towardsdatascience.com/understanding-backpropagation-algorithm-7bb3aa2f95fd</a></li>
<li><a href="https://edgeaiguru.com/Feedforward-and-Backpropagation">https://edgeaiguru.com/Feedforward-and-Backpropagation</a></li>
</ul>
]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>[Neural Network]하이퍼파라미터</title>
    <url>/2022/06/15/DL-hyperparameter/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>hyperparameter에 대해 알아보고 딥러닝에서 쓸 수 있는 hyperparameter tuning option에 대해 알아본다.</strong></p>
<ul>
<li>training epoch</li>
<li>batch_size</li>
<li>learning rate</li>
<li>optimization algorithms</li>
<li>momentum</li>
<li>activate function</li>
</ul>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>[Deep Learning]Loss function</title>
    <url>/2022/06/15/DL-lossfunction/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk








#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>굵은 글씨로 뭔가 쓴다.</strong></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>[Deep Learning]Optimizer</title>
    <url>/2022/06/15/DL-optimizer/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk



optimizer란 

optimizer 종류

optimizer 선택 방법론

구현

#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>굵은 글씨로 뭔가 쓴다.</strong></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
      <tags>
        <tag>Optimizer</tag>
      </tags>
  </entry>
  <entry>
    <title>[Neural Network]Perceptron의 이해</title>
    <url>/2022/06/15/DL-perceptron/</url>
    <content><![CDATA[<!--

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling

**Perceptron은 딥러닝의 기초가 되는 알고리즘이다. 개념은 간단하지만 추후 나올 다른 신경망의 기원이 되는 알고리즘인 만큼 정확히 알 필요가 있다. 여기서는 최적화 관점에서의 Perceptron을 다룬다.**


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>Perceptron은 딥러닝의 기초가 되는 중요한 알고리즘이지만 Percepton 자체는 그냥 인풋을 두 개의 클래스로 분류하는 이진분류에 속한다.<br>최적화 관점에서의 Perceptron을 알아보자</strong></p>
<ul>
<li><a href="#perceptron">Perceptron</a><ul>
<li><a href="#%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-perceptron">최적화 관점에서의 Perceptron</a></li>
<li><a href="#perception-as-linear-binary-classifier">Perception as Linear Binary Classifier</a></li>
</ul>
</li>
<li><a href="#%EB%85%BC%EB%A6%AC%EA%B2%8C%EC%9D%B4%ED%8A%B8">논리게이트</a></li>
<li><a href="#%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98">활성화 함수</a><ul>
<li><a href="#step-function">Step Function</a></li>
<li><a href="#sigmoid-function">Sigmoid Function</a></li>
<li><a href="#relu-function">RelU Function</a></li>
</ul>
</li>
<li><a href="#python%EC%9C%BC%EB%A1%9C-perceptron-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0">Python으로 Perceptron 구현하기</a></li>
<li><a href="#%EC%A0%95%EB%A6%AC">정리</a></li>
<li><a href="#references">References</a></li>
</ul>
<hr>
<h2 id="Perceptron"><a href="#Perceptron" class="headerlink" title="Perceptron"></a>Perceptron</h2><p>Perceptron은 <strong>여러 신호를 입력으로 받아 하나의 신호를 출력하는 일종의 뉴런</strong>이다. 생물학에서 이야기하는 그 뉴런의 컨셉을 생각하면 이해가 쉽다.</p>
<ul>
<li>한개의 뉴런으로 여러 입력신호(x0, x1, …)가 입력되면 각각 고유한 가중치(weights, w0, w1, …)가 곱해지고 더해진다.</li>
<li>편향(bias)</li>
<li>가중치가 곱해진 값들은 모두 더해져 정해진 임계값(threshold)을 넘을 경우에만 다음 노드들이 있는 층(layer)으로 신호가 전해진다.</li>
</ul>
<p>아래 그림을 통해 기본적인 퍼셉트론 노드의 구조를 쉽게 이해할 수있다.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/f/ff/Rosenblattperceptron.png"></p>
<center><b>그림1. Perceptron 구조</b></center>


<p><strong>Perceptron은 정확히 말하면 Perceptron Learning Algorithm인데 이름에서 보다시피 알고리즘의 일종이다.</strong></p>
<p>기본적으로 SVM이나 Decision tree 처럼 학습을 하는 알고리즘이기 때문에 최적화 문제랑 같이보면 이해가 쉽다.</p>
<p><img src="/2021-08-10-10-47-38.png"></p>
<ol>
<li><p>가중치(w) 를 </p>
</li>
<li><p>가중치를 업데이트한다.</p>
<p>가중치</p>
</li>
</ol>
<p>\begin{align}<br> y &#x3D;activation(\sum(w_{1}x_{1} + w_{2}x_{2} + … + w_{n}x_{n}) + bias)<br>\end{align}</p>
<p><img src="/ML-DL-perceptron/perceptron_al.png"></p>
<center><b>그림2. Perceptron Learning Algorithm</b></center>


<h3 id="최적화-관점에서의-Perceptron"><a href="#최적화-관점에서의-Perceptron" class="headerlink" title="최적화 관점에서의 Perceptron"></a>최적화 관점에서의 Perceptron</h3><p>최적화 관점으로 생각하면 Perceptron 또한 비용함수인 $f(h)-y$ 를 최소화 하는 목적을 가지고 있다고 볼 수 있다.</p>
<p>Perceptron 알고리즘에서의 비욯함수는 <code>0-1 loss</code>인데 이는 단순히 잘못된 예측에 대해 1의 패널티를 부여하고 제대로된 예측은 그대로 놔두는 것이다.</p>
<p>이를 수식으로 나타내면 아래와 같다</p>
<p>$L(\hat{y}, y) &#x3D; I(\hat{y} \ne y)$ </p>
<p>(여기서 I 는 indicator 함수로 0아니면 1의 결과를 반환한다.)</p>
<p>이러한 비용함수의 문제는 gradient descent 를 사용해 국소최적해(local optimum) 를 찾기 어렵다는 것이다.</p>
<h3 id="Perception-as-Linear-Binary-Classifier"><a href="#Perception-as-Linear-Binary-Classifier" class="headerlink" title="Perception as Linear Binary Classifier"></a>Perception as Linear Binary Classifier</h3><p>Perceptron의 컨셉을 다시 살펴보면 </p>
<h2 id="논리게이트"><a href="#논리게이트" class="headerlink" title="논리게이트"></a>논리게이트</h2><h2 id="활성화-함수"><a href="#활성화-함수" class="headerlink" title="활성화 함수"></a>활성화 함수</h2><p>활성화 함수는 입력벡터와 가중치벡터의 가중합인 net input을 받아 출력신호를 도출해내는 함수이다.</p>
<h3 id="Step-Function"><a href="#Step-Function" class="headerlink" title="Step Function"></a>Step Function</h3><h3 id="Sigmoid-Function"><a href="#Sigmoid-Function" class="headerlink" title="Sigmoid Function"></a>Sigmoid Function</h3><h3 id="RelU-Function"><a href="#RelU-Function" class="headerlink" title="RelU Function"></a>RelU Function</h3><h2 id="Python으로-Perceptron-구현하기"><a href="#Python으로-Perceptron-구현하기" class="headerlink" title="Python으로 Perceptron 구현하기"></a>Python으로 Perceptron 구현하기</h2><p>간단한 Perceptron을 Python으로 구현해보자</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><ul>
<li>퍼셉트론은 입출력을 가지는 일종의 알고리즘이다. 입력에 따라 정해진 규칙에 따른 값을 반환한다.</li>
<li>퍼셉트론은 가중치와 편향을 매개변수로 지정한다.<ul>
<li>가중치</li>
<li>편향</li>
</ul>
</li>
<li>퍼셉트론으로 논리회로를 표현할 수 있다.</li>
<li>XOR 게이트의 경우 단층 퍼셉트론을 사</li>
<li>퍼셉트론은 샘플을 입력받아 가중치 w를 연결하여 net input을 계산한다. </li>
<li>net input은 입력벡터와 가중치 벡터의 내적이다. </li>
<li>net input은 activation 함수로 전달되어</li>
<li></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Perceptron">https://en.wikipedia.org/wiki/Perceptron</a></li>
<li><a href="https://towardsdatascience.com/perceptron-learning-algorithm-d5db0deab975">https://towardsdatascience.com/perceptron-learning-algorithm-d5db0deab975</a></li>
</ul>
]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>[Deep Leearing] 학습 규제하기(Handling Overfitting)</title>
    <url>/2022/06/15/DL-regularization/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling

#

#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>과적합 방지를 위한 기법을 규제라고 부른다.</strong></p>
<ul>
<li><a href="#weight-decay">Weight Decay</a></li>
<li><a href="#weight-constraint">Weight Constraint</a></li>
<li><a href="#dropout">Dropout</a></li>
<li><a href="#%EC%B6%94%EA%B0%80-%ED%95%99%EC%8A%B5%EC%97%90-batch-size%EA%B0%80-%EB%AF%B8%EC%B9%98%EB%8A%94-%EC%98%81%ED%96%A5">[추가] 학습에 batch size가 미치는 영향</a></li>
<li><a href="#references">References</a></li>
</ul>
<hr>
<h2 id="Weight-Decay"><a href="#Weight-Decay" class="headerlink" title="Weight Decay"></a>Weight Decay</h2><p>학습은 </p>
<p>$$Loss &#x3D; MSE + \lambda \times  * {w}^2$$</p>
<p>왜 이런 조치를 하는 것이 overfitting을 줄여주는가?</p>
<p>어딘가에 Global minimum이 존재</p>
<p>하지만 이 Global minimum은 <code>학습한</code> training set에서만 적용</p>
<p>Regularization 항을 추가할 경우 원점에 loss surface가 하나 더 생김</p>
<p>Global minimum에 빠질 경우 overfitting 이 일어나는데 loss surface를 하나 더 만듦으로써 다른 training set에서도 해당 모형이 잘 적용될 수 있게끔하는 것이다.</p>
<h2 id="Weight-Constraint"><a href="#Weight-Constraint" class="headerlink" title="Weight Constraint"></a>Weight Constraint</h2><h2 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="추가-학습에-batch-size가-미치는-영향"><a href="#추가-학습에-batch-size가-미치는-영향" class="headerlink" title="[추가] 학습에 batch size가 미치는 영향"></a>[추가] 학습에 batch size가 미치는 영향</h2><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://medium.com/mini-distill/effect-of-batch-size-on-training-dynamics-21c14f7a716e">batch size 관련</a> </li>
<li><a href="https://towardsdatascience.com/handling-overfitting-in-deep-learning-models-c760ee047c6e">overfitting in deeplearing models</a></li>
<li><a href="https://towardsdatascience.com/this-thing-called-weight-decay-a7cd4bcfccab">weight decay</a></li>
</ul>
<!--
- [L1 & L2 Regularization](https://www.youtube.com/watch?v=_sz3KTyB9Lk&t=1063s)
- [가중치 초기화 관련](https://youtu.be/ScWTYHQra5E)
- [Dropout](https://www.youtube.com/watch?v=ajeliDMD86U)
- [Ng 교수님의 하이퍼파라미터 설명](https://www.youtube.com/watch?v=wKkcBPp3F1Y)
- [parameter와 hyperparameter 차이](https://youtu.be/Kh06wgGbi78?t=12)
- [학습 규제 방식에 대한 설명 강의](https://youtu.be/_sz3KTyB9Lk?t=1005)
- [L1/L2-regularization](https://towardsdatascience.com/l1-and-l2-regularization-methods-ce25e7fc831c)
-->

<ul>
<li><a href="https://light-tree.tistory.com/125">L1 &amp; L2 용어정리</a></li>
</ul>
]]></content>
      <categories>
        <category>Neural Network</category>
      </categories>
  </entry>
  <entry>
    <title>[Metrics]회귀모델의 평가지표</title>
    <url>/2022/06/15/ML-Metrics-Regression/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>회귀모델의 평가지표 정리</strong></p>
<h3 id="회귀모델의-평가지표"><a href="#회귀모델의-평가지표" class="headerlink" title="회귀모델의 평가지표"></a>회귀모델의 평가지표</h3><ul>
<li>$R^2$ 외에, MAE는 단위 유닛이 같으므로 보다 해석에 용이함.</li>
<li>MSE는 제곱을 하기 때문에 특이값에 보다 민감. </li>
<li>RMSE는 MSE를 실제값과 유사한 단위로 변화시켜줌.</li>
<li>회귀문제에서 RMSE가 일반적으로 선호되는 방법이지만, 상황에 맞는 다른 방식을 사용. 특이값이 많은 경우에는 MAE를 사용.</li>
</ul>
<hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><p>MSE (Mean Squared Error) &#x3D;<br>$\frac{1}{n}\sum_{i&#x3D;1}^{n}(y_{i} - \hat{y_{i}})^{2}$</p>
</li>
<li><p>MAE (Mean absolute error) &#x3D; $\frac{1}{n}\sum_{i&#x3D;1}^{n}\left | y_{i} - \hat{y_{i}} \right |$</p>
</li>
<li><p>RMSE (Root Mean Squared Error) &#x3D;<br>$\sqrt{MSE}$</p>
</li>
<li><p>R-squared (Coefficient of determination) &#x3D;<br>$1 - \frac{\sum_{i&#x3D;1}^{n}(y_{i} - \hat{y_{i}})^{2}}{\sum_{i&#x3D;1}^{n}(y_{i} - \bar{y_{i}})^{2}} &#x3D; 1 - \frac{SSE}{SST} &#x3D; \frac {SSR}{SST}$</p>
</li>
<li><p>MAPE &#x3D; $\frac { \sum \vert \frac { y - \hat y}{y} \vert }{n}*100%$</p>
</li>
</ul>
<ul>
<li>참고<ul>
<li>SSE(Sum of Squares <code>Error</code>, 관측치와 예측치 차이): $\sum_{i&#x3D;1}^{n}(y_{i} - \hat{y_{i}})^{2}$</li>
<li>SSR(Sum of Squares due to <code>Regression</code>, 예측치와 평균 차이): $\sum_{i&#x3D;1}^{n}(\hat{y_{i}} - \bar{y_{i}})^{2}$</li>
<li>SST(Sum of Squares <code>Total</code>, 관측치와 평균 차이): $\sum_{i&#x3D;1}^{n}(y_{i} - \bar{y_{i}})^{2}$ , SSE + SSR</li>
</ul>
</li>
</ul>
<hr>
<h4 id="MSE"><a href="#MSE" class="headerlink" title="MSE"></a>MSE</h4><ul>
<li>모델의 예측값과 실제값 차이의 면적의 합.</li>
<li>특이값이 존재할 경우 수치가 많이 늘어남</li>
</ul>
<h4 id="MAE"><a href="#MAE" class="headerlink" title="MAE"></a>MAE</h4><ul>
<li>MSE 보다 특이치에 robust</li>
<li>절대값을 취하기 때문에 매우 직관적</li>
</ul>
<h4 id="RMSE"><a href="#RMSE" class="headerlink" title="RMSE"></a>RMSE</h4><ul>
<li>MSE의 제곱근. </li>
<li>큰 오류값에 대해 패널티를 주기 때문에 보통 이걸 사용</li>
</ul>
<h4 id="R-squared"><a href="#R-squared" class="headerlink" title="R-squared"></a>R-squared</h4><ul>
<li>설명량</li>
<li>$R^2$ 값이 1에 가까울 수록 데이터를 잘 설명하는 모델이 됨</li>
</ul>
<h4 id="MAPE"><a href="#MAPE" class="headerlink" title="MAPE"></a>MAPE</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MAPE</span>(<span class="params">y_true, y_pred</span>): </span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>((y_true - y_pred) / y_true)) * <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MAE를 퍼센트 변환한 것.</li>
<li>MAE와 마찬가지로 MSE보다 특이치에 robust하다.</li>
<li>모델에 대한 편향이 존재.</li>
<li>0 근처의 값에서는 사용하기 어렵습니다.</li>
</ul>
<h4 id="MPE"><a href="#MPE" class="headerlink" title="MPE"></a>MPE</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">MAPE</span>(<span class="params">y_true, y_pred</span>): </span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>((y_true - y_pred) / y_true)) * <span class="number">100</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>MAPE를 퍼센트 변환한 것.</li>
<li>절대값을 제외했기 때문에 overperformance인지 underperformance인지 쉽게 알 수 있다.</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.dataquest.io/blog/understanding-regression-error-metrics/">https://www.dataquest.io/blog/understanding-regression-error-metrics/</a></li>
<li><a href="https://machinelearningmastery.com/regression-metrics-for-machine-learning/">https://machinelearningmastery.com/regression-metrics-for-machine-learning/</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Regression</tag>
        <tag>Metrics</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tree]Decision Tree의 이해</title>
    <url>/2022/06/15/ML-SP-Decision_Tree/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="Decision-Tree의-이해"><a href="#Decision-Tree의-이해" class="headerlink" title="Decision Tree의 이해"></a>Decision Tree의 이해</h2><hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>Decision Tree(결정트리)</strong>: 질문을 던지고 답을 하는 과정을 연쇄적으로 반복해 집단을 분류하거나 예측하는 분석방법.</li>
<li><strong>threshold</strong> : 결정트리에서의 학습대상. 정확히는 데이터를 나누는 best feature의 best threshold를 찾는 것이 학습의 목적이다,</li>
<li><strong>full tree</strong> : 모든 학습데이터에 대해 분기한 상태.</li>
<li><strong>Entropy</strong> : Entropy 는 데이터셋의 불순도와 무질서한 정도를 나타내는 측정치</li>
<li><strong>지니 불순도</strong> : 데이터 집합에서 클래스 분포에 따라 무작위로 라벨이 지정된 경우 무작위로 선택한 요소들을 잘못 분류할 확률이다.(Chance of being incorrect if you randomly assign a label to an example in the same set)</li>
<li><strong>정보 이득</strong> : 정보 이득은 단순히 부모 노드의 불순도와 자식 노드의 불순도 합의 차이.</li>
<li><strong>Root Node</strong> : 초기노드. 데이터셋 혹은 샘플 전체. </li>
<li><strong>Leaf Node(Terminal Node)</strong> : 자식이 없는 노드.하위노드가 없다.</li>
<li><strong>Pure Node</strong> : 노드의 모든 데이터포인트가 하나의 클래스에 할당되어 있을 경우. 타깃 한개로만 이루어진 Leaf Node.</li>
<li><strong>Branch</strong> : sub-section of an entire tree.</li>
<li><strong>Splitting</strong> : 특정 노드를 나눠 하위노드를 생성하는 것.</li>
<li><strong>Pruning</strong> : 특정 노드의 하위노드를 날리는 것(삭제).</li>
<li><strong>Pre-prune</strong>: When you stop growing DT branches when information becomes unreliable.</li>
<li><strong>Post-prune</strong>: When you take a fully grown DT and then remove leaf nodes only if it results in a better model performance. This way, you stop removing nodes when no further improvements can be made.</li>
</ul>
<p><img src="https://miro.medium.com/max/888/1*FYEZGG-gEijSb87KuxSE_Q.png"></p>
<hr>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><hr>
<ul>
<li>SVM처럼 <strong>분기점(threshold)을 학습한다.</strong></li>
<li>기본적으로 정보이득량이 가장 커지는 방식으로 반복적으로 분할을 진행(recursive partitioning)한다.</li>
<li><strong>분기의 기준이 정보이득이라는 것이 핵심이다.</strong></li>
<li>과적합을 방지하기 위해 pruning이 필요하다.</li>
<li>선형모델과 달리 비선형(non-linear), 비단조(non-monotonic), 특성상호작용(feature interactions) 특징을 가지고 있는 데이터 분석에 용이하다.</li>
<li>특성을 해석하기 좋아 많이 쓰임</li>
<li><strong>샘플에 민감해 트리 고저가 자주 바뀐다.</strong></li>
<li>앙상블 방법의 기초가 된다.</li>
<li><strong>결정트리를 학습한다는 것은 정답에 가장 빨리 도달하는 예&#x2F;아니오 질문 목록을 학습한다는 것이다. 이러한 질문들을 test라고 한다.</strong></li>
<li>학습 데이터셋에 과대적합되는 경향이 있다.</li>
<li>결정트리의 트리를 제어하지 않으면 트리는 무한정 깁어지고 복잡해진다.(일반화 성능이 낮아진다.)</li>
<li>따라서 사전&#x2F;사후 가지치기를 통해 과대적합을 방지한다.</li>
<li>알고리즘 특성상 feature scaling이 필요하지 않지만 주로 다른 알고리즘과의 비교(시각화)를 위해 scaling을 해주는 경우도 있다.</li>
</ul>
<h3 id="불순도-지표"><a href="#불순도-지표" class="headerlink" title="불순도 지표"></a>불순도 지표</h3><hr>
<h4 id="Entropy"><a href="#Entropy" class="headerlink" title="Entropy"></a>Entropy</h4><hr>
<p><a href="https://www.analyticsvidhya.com/blog/2020/11/[]entropy-a-key-concept-for-all-data-science-beginners/">엔트로피 중요개념</a></p>
<p><a href="https://towardsdatascience.com/entropy-how-decision-trees-make-decisions-2946b9c18c8">매우중요</a></p>
<ul>
<li>Entropy 는 데이터셋의 불순도와 무질서한 정도를 나타내는 측정치이다.(measure disorder)</li>
<li>0~1의 값을 가진다.<ul>
<li>클래스가 완전히 균일하게 분포되어있을 경우(0.5) Entropy가 최대인 1이된다. </li>
<li>데이터셋의 요소의 분포가 특정 클래스에 치우쳐있을수록 Entropy가 0에 가까워진다.</li>
</ul>
</li>
<li>트리를 만들때 알고리즘은 가능한 모든 테스트에서 타깃값에 대해 가장 많은 정보를 가진 것을 고른다. -&gt; 엔트로피가 최소화되는 방향으로 학습을 진행한다.</li>
</ul>
<p align="center">
<img src="https://miro.medium.com/max/750/1*M15RZMSk8nGEyOnD8haF-A.png" alt="drawing" width="400"/>
</p>

<ul>
<li><strong>정보이득은 엔트로피의 변화량으로 계산된다.(1-엔트로피)</strong></li>
<li>N은 범주의 개수</li>
<li>$p_{i}$ 는 p 영역에 속한 데이터 중 i 범주에 속하는 데이터의 비율.</li>
</ul>
<p>$$\text { Entropy }(p)&#x3D;-\sum_{i&#x3D;1}^{N} p_{i} \log <em>{2} p</em>{i}$$</p>
<h4 id="지니불순도"><a href="#지니불순도" class="headerlink" title="지니불순도"></a>지니불순도</h4><hr>
<ul>
<li><strong>잘못 분류될 확률을 최소화하기 위한 기준이다.</strong><ul>
<li>정확히는 <code>데이터 집합에서 클래스 분포에 따라 무작위로 라벨이 지정된 경우 무작위로 선택한 요소들을 잘못 분류할 확률이다.(Chance of being incorrect if you randomly assign a label to an example in the same set)</code></li>
<li>기본적으로 Single Node에 대해 계산한 값이다,</li>
</ul>
</li>
<li>클래스의 비율이 완벽히 균등할 때 최대가 된다.</li>
<li>기본적으로 노드가 중요할수록 불순도가 크게 감소한다.</li>
<li>범주형데이터가 라벨이라면 카디널리티가 적을 수록 불순도는 낮아진다.</li>
<li><strong>Entropy와 지니불순도의 차이는 불순도의 max가 Entopy가 보다 높다는 것이다.</strong></li>
<li><strong>지니불순도가 가장 낮은 Feature statement를 의사결정 트리의 가장 위에 놓는다.</strong>(지니인덱스가 낮으면 불순도가 낮기 때문에 루트노드에 올 가능성이 높아진다.)<ul>
<li>불순도가 낮다는 것은 해당 Feature statement로 인한 정보이득이 높다는 것이다.</li>
</ul>
</li>
<li>최초 노드의 impurity(unsertainty)에서 마지막 노드의 uncertainty를 뺀 값이 information Gain 이다.</li>
<li>Entropy와 달리 식에 log가 없어 계산시 약간 유리하다.</li>
<li>Gain이 가장 큰쪽으로 가지치기를 반복하는 것이 기본적인 의사결정 트리 알고리즘이다.</li>
</ul>
<p>$$\text{Gini Impurity}&#x3D;\sum_{i&#x3D;1}^{N} p(i) *(1-p(i))$$</p>
<h4 id="information-Gain"><a href="#information-Gain" class="headerlink" title="information Gain"></a>information Gain</h4><hr>
<ul>
<li>leaf의 결과는 기본적으로 majority 를 반환한다.</li>
<li><strong>정보 이득은 단순히 부모 노드의 불순도와 자식 노드의 불순도 합의 차이이다.</strong><ul>
<li>이진트리의 경우 자식트리인 왼쪽,오른쪽 트리의 불순도의 합을 부모노드에서 뺀다.</li>
</ul>
</li>
<li>Information Gain is calculated for a split by subtracting the weighted entropies of each branch from the original entropy. When training a Decision Tree using these metrics, the best split is chosen by maximizing Information Gain.</li>
</ul>
<p>$$IG(Parent,Children) &#x3D; E(Parent) - E(Parent | Children)$$</p>
<ul>
<li><strong>자식 노드의 불순도가 낮을수록 정보 이득이 커진다.</strong> </li>
<li>보통 모듈에서 이진 결정 트리를 사용하므로 부모노드는 두 개의 자식 노드로 나눠진다.</li>
</ul>
<p>$$\text {E(parent)} - [\text {weighted average}] * E(children)$$</p>
<p><img src="https://tensorflowkorea.files.wordpress.com/2018/03/overview-plot.png"></p>
<ul>
<li>엔트로피보다 지니 불순도 방식이 불순도 값을 줄이기 위해 더 클래스 확률을 낮추어야 한다.</li>
<li>엔트로피를 불순도 지표로 사용할 경우 지니불순도를 사용하는 것보다 더 균형잡힌 트리를 만들 가능성이 높다.</li>
</ul>
<h3 id="결정트리의-최적화-문제"><a href="#결정트리의-최적화-문제" class="headerlink" title="결정트리의 최적화 문제"></a>결정트리의 최적화 문제</h3><hr>
<ul>
<li><a href="https://data-notes.co/decision-trees-how-to-optimize-my-decision-making-process-e1f327999c7a">최적화 원리와 코드</a></li>
</ul>
<p><strong>Training algorithm</strong></p>
<ul>
<li><p><strong>기본적으로 Best Threshold를 찾는 문제이다</strong></p>
</li>
<li><p>Start at the top node and at each node select the best split based o the best information gain</p>
</li>
<li><p>Greedy Search : Loop over all features and over all thresholds (<strong>all possible feature values</strong>)</p>
</li>
<li><p>Save the best split features and split threshold at each node</p>
</li>
<li><p>Build the tree recursively</p>
</li>
<li><p>Apply some stopping criteria to stop growing</p>
<ul>
<li>maximum depth</li>
<li>minimum samples</li>
<li>etc..</li>
</ul>
</li>
<li><p>When we have a leaf node, store the most common class label of this node</p>
</li>
</ul>
<p><strong>Predict :&#x3D; Traverse tree</strong></p>
<ul>
<li>Traverse the tree recursively.</li>
<li>At each node look at the best split feature of the test feature vector x and go left or right <strong>depending on x[feature idx] &lt;&#x3D; threshold</strong></li>
<li>When we reach the leaf node we return the stored most common class label</li>
</ul>
<h3 id="Pruning"><a href="#Pruning" class="headerlink" title="Pruning"></a>Pruning</h3><hr>
<p><strong>Put limits in How trees grow</strong></p>
<h4 id="PrePruning"><a href="#PrePruning" class="headerlink" title="PrePruning"></a>PrePruning</h4><hr>
<ul>
<li><p>트리의 최대 깊이 제한하기(max_depth)</p>
</li>
<li><p>리프의 최대 개수 제한하기</p>
</li>
<li><p>노드가 분할하기 위한 데이터 포인트의 최소 개수 지정</p>
</li>
<li><p>sklearn에서 제공하는 관련 Hyperparameter</p>
<ul>
<li>max_depth : 일반화 성능관련. 트리의 최대깊이<ul>
<li>min_sample_splite</li>
<li>max_feature : 최대 피처 사용수</li>
<li>random_state : random state</li>
<li>class_weight : 가중치 balance 맟추기</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="PostPruning"><a href="#PostPruning" class="headerlink" title="PostPruning"></a>PostPruning</h4><hr>
<p>Post-pruning is also known as backward pruning. In this, first generate the decision tree and then remove non-significant branches. Post-pruning a decision tree implies that we begin by generating the (complete) tree and then adjust it with the aim of improving the accuracy on unseen instances. There are two principal methods of doing this. One method that is widely used begins by converting the tree to an equivalent set of rules. Another commonly used approach aims to retain the decision tree but to replace some of its subtrees by leaf nodes, thus converting a complete tree to a smaller pruned one which predicts the classification of unseen instances at least as accurately. There are various methods for the post pruning.</p>
<h3 id="Feature-Importance-in-Decision-Tree"><a href="#Feature-Importance-in-Decision-Tree" class="headerlink" title="Feature Importance in Decision Tree"></a>Feature Importance in Decision Tree</h3><hr>
<h3 id="More-to-learn"><a href="#More-to-learn" class="headerlink" title="More to learn"></a>More to learn</h3><hr>
<ul>
<li>Pruning</li>
<li>Handling missing data</li>
<li>Building Trees for regression</li>
<li>Using trees to explore datasets</li>
</ul>
<p><strong>more</strong></p>
<ul>
<li>Gini-Index is providing us with the highest accuracy with max depth &#x3D; 6.</li>
<li>Entropy and Gini-index can behave similarly with appropriately selected min_weight_fraction_leaf.</li>
<li>With min_samples_split as 7, Entropy is outperforming Gini for a rudimentary assumption that More samples will provide more information gain and tend to skew the Gini index as the impurity increases.</li>
</ul>
<p>Therefore with taking the criteria as Gini and max_depth &#x3D; 6, we obtained the accuracy as 32% which is an 18% increase from without using parametric optimization. Hence, Optimizing the parameter rightfully, will increase the model accuracy and provide better results.</p>
<p><strong>결정트리의 장점</strong></p>
<ul>
<li>설명가능성</li>
</ul>
<p><strong>결정트리의 단점</strong></p>
<ul>
<li>과적합</li>
</ul>
<h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><hr>
<ul>
<li>numpy로 구현</li>
<li><strong>기본적으로 Best Split Threshold를 찾는 것이 목적이다.</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">entropy</span>(<span class="params">y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Compute the entropy of a label vector</span></span><br><span class="line"><span class="string">    :param y: label vector</span></span><br><span class="line"><span class="string">    :return: entropy</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    hist = np.bincount(y) <span class="comment"># class distribution # 0부터 max까지 class label의 빈도</span></span><br><span class="line">    ps = hist / <span class="built_in">len</span>(y) <span class="comment"># probability of each class</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -np.<span class="built_in">sum</span>([p * np.log2(p) <span class="keyword">for</span> p <span class="keyword">in</span> ps <span class="keyword">if</span> p != <span class="number">0</span>]) <span class="comment"># 음수에 대해서는 정의하지 않음</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,feature=<span class="literal">None</span>,threshold=<span class="literal">None</span>,left=<span class="literal">None</span>,right=<span class="literal">None</span>,*,value=<span class="literal">None</span></span>):</span><br><span class="line">        self.feature = feature</span><br><span class="line">        self.threshold = threshold</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_leaf</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="comment"># leaf node의 경우 value가 있다.</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecisionTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, min_samples_split=<span class="number">2</span>, max_depth=<span class="number">100</span>, n_feats = <span class="literal">None</span></span>):</span><br><span class="line">        self.min_samples_split = min_samples_split</span><br><span class="line">        self.max_depth = max_depth</span><br><span class="line">        self.n_feats = n_feats</span><br><span class="line">        self.root = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        <span class="comment"># grow tree</span></span><br><span class="line">        <span class="comment"># X.shape[1] : feature의 개수</span></span><br><span class="line">        </span><br><span class="line">        self.n_feats = X.shape[<span class="number">1</span>] <span class="keyword">if</span> <span class="keyword">not</span> self.n_feats <span class="keyword">else</span> <span class="built_in">min</span>(self.n_feats, X.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># if not self.n_feats -&gt; n.feats가 정의되있지 않을 경우  min(self.n_feats,X.shape[1]) </span></span><br><span class="line">        <span class="comment"># input의 feature 수보다 n_feats기 커지지 않게끔하는 </span></span><br><span class="line">        self.root = self._grow_tree(X, y)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_grow_tree</span>(<span class="params">self, X, y, depth=<span class="number">0</span></span>):</span><br><span class="line">        n_sample, n_feats = X.shape</span><br><span class="line">        n_labels = <span class="built_in">len</span>(np.unique(y))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># stopping criteria # 더 이상 분류할 수 없는 경우 혹은 pruning 기준에 도달한 경우</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            depth &gt;= self.max_depth </span><br><span class="line">            <span class="keyword">or</span> n_labels == <span class="number">1</span> </span><br><span class="line">            <span class="keyword">or</span> n_sample &lt; self.min_samples_split</span><br><span class="line">        ):</span><br><span class="line">            leaf_value = self._most_common_label(y)</span><br><span class="line">            <span class="keyword">return</span> Node(value=leaf_value)</span><br><span class="line">        </span><br><span class="line">        feat_idxs = np.random.choice(n_feats, self.n_feats, replace=<span class="literal">False</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># calculate information gain</span></span><br><span class="line">        best_feat, best_threshold = self._best_criteria(X, y, feat_idxs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># grow the children that result from splitting on the best feature</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 정보이득을 계산한 best_feature와 best threshold 기준으로 분할</span></span><br><span class="line">        left_idxs , right_idxs = self._split(X[:,best_feat], best_threshold)</span><br><span class="line">        left = self._grow_tree(X[left_idxs,:], y[left_idxs], depth+<span class="number">1</span>) <span class="comment"># depth+1</span></span><br><span class="line">        right = self._grow_tree(X[right_idxs,:], y[right_idxs], depth+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Node(best_feat, best_threshold, left, right) </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_best_criteria</span>(<span class="params">self,X,y,feat_idxs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find the best criteria to split the data</span></span><br><span class="line"><span class="string">        :param X: input data</span></span><br><span class="line"><span class="string">        :param y: label</span></span><br><span class="line"><span class="string">        :param feat_idxs: indices of features to consider</span></span><br><span class="line"><span class="string">        :return: best feature index, best threshold</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        best_gain = -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        split_idx, split_threshold = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> feat_idx <span class="keyword">in</span> feat_idxs:</span><br><span class="line">            X_col = X[:,feat_idx] <span class="comment"># X의 각 feature</span></span><br><span class="line">            thresholds = np.unique(X_col) <span class="comment"># 각 feature의 cardianlity</span></span><br><span class="line">            <span class="keyword">for</span> threshold <span class="keyword">in</span> thresholds:</span><br><span class="line">                gain = self._information_gain(y,X_col,threshold) <span class="comment"># 각 feuture의 모든 threshold에 대해서 gain을 계산</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> gain &gt; best_gain:</span><br><span class="line">                    best_gain = gain</span><br><span class="line">                    split_idx = feat_idx</span><br><span class="line">                    split_threshold = threshold</span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> split_idx, split_threshold</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_information_gain</span>(<span class="params">self,y,X_column,split_threshold</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Calculate information gain</span></span><br><span class="line"><span class="string">        E(parent) - [weight average] * E(Children)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># parent entropy</span></span><br><span class="line">        </span><br><span class="line">        parent_entropy = entropy(y)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># generate split</span></span><br><span class="line">        left_idxs, right_idxs = self._split(X_column, split_threshold)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 더이상 분할이 안될 경우 정보이득이 0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">len</span>(left_idxs) == <span class="number">0</span>) <span class="keyword">or</span> (<span class="built_in">len</span>(right_idxs)) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># compute the weighted avg. of the loss for the children</span></span><br><span class="line">        n = <span class="built_in">len</span>(y)</span><br><span class="line">        n_l, n_r = <span class="built_in">len</span>(left_idxs), <span class="built_in">len</span>(right_idxs)</span><br><span class="line">        e_l, e_r = entropy(y[left_idxs]), entropy(y[right_idxs])</span><br><span class="line">        child_entropy = (n_l / n) * e_l + (n_r / n) * e_r</span><br><span class="line"></span><br><span class="line">        <span class="comment"># information gain is difference in loss before vs. after split</span></span><br><span class="line">        ig = parent_entropy - child_entropy</span><br><span class="line">        <span class="keyword">return</span> ig</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_split</span>(<span class="params">self, X_column, split_threshold</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Split data according to the threshold</span></span><br><span class="line"><span class="string">        :param X_column: input data</span></span><br><span class="line"><span class="string">        :param split_threshold: threshold to split</span></span><br><span class="line"><span class="string">        :return: left and right indices</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># np.argwhere을 사용 조건에 해당하는 인덱스 반환.</span></span><br><span class="line">        left_idxs = np.argwhere(X_column &lt;= split_threshold).flatten()</span><br><span class="line">        right_idxs = np.argwhere(X_column &gt; split_threshold).flatten()</span><br><span class="line">        <span class="keyword">return</span> left_idxs, right_idxs</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_most_common_label</span>(<span class="params">self, y</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Find the most common label in the dataset</span></span><br><span class="line"><span class="string">        :param y: labels</span></span><br><span class="line"><span class="string">        :return: most common label</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        counter = Counter(y)</span><br><span class="line">        <span class="comment"># counter.most_common(1) -&gt; [(label, count)] # 리스트 안에 튜플</span></span><br><span class="line">        most_common = counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> most_common <span class="comment"># Counter(y) : Counter(&#123;0: 2, 1: 2&#125;) #value과 count중 value만 반환 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        <span class="comment"># traverse the tree</span></span><br><span class="line">        <span class="keyword">return</span> np.array([self._traverse_tree(x,self.root) <span class="keyword">for</span> x <span class="keyword">in</span> X]) <span class="comment"># X의 각 데이터포인트에 대해서 트리를 순회하며 각 데이터포인트에 대한 결과를 반환</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_traverse_tree</span>(<span class="params">self, x, node</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Traverse the tree from the root</span></span><br><span class="line"><span class="string">        :param x: input data</span></span><br><span class="line"><span class="string">        :param node: root node</span></span><br><span class="line"><span class="string">        :return: label</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> node.is_leaf(): <span class="comment"># check if leaf node</span></span><br><span class="line">            <span class="keyword">return</span> node.value</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x[node.feature] &lt;= node.threshold:</span><br><span class="line">            <span class="keyword">return</span> self._traverse_tree(x, node.left)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._traverse_tree(x, node.right)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line">    <span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y,y_pred</span>):</span><br><span class="line">        acc = np.<span class="built_in">sum</span>(y == y_pred) / <span class="built_in">len</span>(y)</span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">    </span><br><span class="line">    data = datasets.load_breast_cancer()</span><br><span class="line">    X, y = data.data, data.target</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    clf = DecisionTree(max_depth=<span class="number">10</span>)</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    </span><br><span class="line">    y_pred = clf.predict(X_test)</span><br><span class="line">    acc = accuracy(y_test, y_pred)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Accuracy : <span class="subst">&#123;acc&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://www.kdnuggets.com/2020/01/decision-tree-algorithm-explained.html">결정트리의 최적화 문제</a></li>
<li><a href="https://machinelearningmastery.com/information-gain-and-mutual-information/">정보이득</a></li>
<li><a href="https://victorzhou.com/blog/gini-impurity/">지니불순도</a></li>
<li><a href="https://tensorflow.blog/tag/%EC%A7%80%EB%8B%88-%EB%B6%88%EC%88%9C%EB%8F%84/">불순도 지표들</a></li>
<li><a href="-https://xzz201920.medium.com/post-pruning-techniques-in-decision-tree-4be56636172b">Post_Pruning</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Decision Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tree]주요 Decision Tree 알고리즘</title>
    <url>/2022/06/15/ML-SP-Main-Decision-Tree-Algorithms/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p>주요 의사결정트리 알고리즘 4개에 대해 간단히 살펴보자.</p>
<hr>
<h2 id="Main-Decision-Tree-Algorithms"><a href="#Main-Decision-Tree-Algorithms" class="headerlink" title="Main Decision Tree Algorithms"></a>Main Decision Tree Algorithms</h2><h3 id="CHAID"><a href="#CHAID" class="headerlink" title="CHAID"></a><strong>CHAID</strong></h3><p>The Chi-squared Automatic Interaction Detection (CHAID) is one of the oldest DT algorithms methods that produces multiway DTs (splits can have more than two branches) suitable for classification and regression tasks. When building Classification Trees (where the dependent variable is categorical in nature), CHAID relies on the Chi-square independence tests to determine the best split at each step. Chi-square tests check if there is a relationship between two variables, and are applied at each stage of the DT to ensure that each branch is significantly associated with a statistically significant predictor of the response variable.<br><strong>In other words, it chooses the independent variable that has the strongest interaction with the dependent variable.</strong></p>
<h3 id="CART"><a href="#CART" class="headerlink" title="CART"></a><strong>CART</strong></h3><p>CART is a DT algorithm that produces binary Classification or Regression Trees, depending on whether the dependent (or target) variable is categorical or numeric, respectively. It handles data in its raw form (no preprocessing needed), and can use the same variables more than once in different parts of the same DT, which may uncover complex interdependencies between sets of variables.</p>
<p><strong>Prepare Data for CART</strong></p>
<ul>
<li><p>The <strong>splitting of numerical features</strong> can be performed by sorting the features in the ascending order and trying each value as the threshold point and calculating the information gain for each value as the threshold. Finally, if that value obtained is equal to the threshold which gives the maximum I.G value then hurray..!!</p>
</li>
<li><p>Feature scaling(column standardization) not necessary to perform in decision trees. However, it helps with data visualization&#x2F;manipulation and might be useful if you intend to compare performance with other data or other methods like SVM.</p>
</li>
<li><p>In order to handle categorical features in Decision trees, we must never perform one hot encoding on a categorical variable even if the categorical variables are nominal since most of the libraries can handle categorical variables automatically. we can still assign a number for each variable if desired.</p>
</li>
<li><p>If height or depth of the tree is exactly one then such a tree is called as a decision stump.</p>
</li>
<li><p>Imbalanced class does have a detrimental impact on the tree’s structure so it can be avoided by either using upsampling or by using downsampling depending upon the dataset.</p>
</li>
<li><p>Apart from skewed classes, high dimensionality can also have an adverse effect on the structure of the tree if dimensionality is very high that means we have a lot of features which means that to find the splitting criterion on each node it will consume a lot of time.</p>
</li>
<li><p>Outliers also impact the tree’s structure as the depth increases the chance of outliers in the tree increases.</p>
</li>
<li><p>Feature importance can be determined by calculating the normalized sum at every level as we have t reduce the entropy and we then select the feature that helps to reduce the entropy by the large margin. so for whichever feature the normalized sum is highest, we can then think of it as the most important feature. similarly, feature which has the second highest normalized sum can be thought of as a second important feature.</p>
</li>
</ul>
<h3 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a><strong>ID3</strong></h3><p>The Iterative Dichotomiser 3 (ID3) is a DT algorithm that is mainly used to produce Classification Trees. Since it hasn’t proved to be so effective building Regression Trees in its raw data, ID3 is mostly used for classification tasks (although some techniques such as building numerical intervals can improve its performance on Regression Trees).</p>
<h3 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a><strong>C4.5</strong></h3><p>C4.5 is the successor of ID3 and represents an improvement in several aspects. C4.5 can handle both continuous and categorical data, making it suitable to generate Regression and Classification Trees. Additionally, it can deal with missing values by ignoring instances that include non-existing data.</p>
<p>Unlike ID3 (which uses Information Gain as splitting criteria), C4.5 uses Gain Ratio for its splitting process. Gain Ratio is a modification of the Information Gain concept that reduces the bias on DTs with huge amount of branches, by taking into account the number and size of the branches when choosing an attribute. Since Information Gain shows an unfair favoritism towards attributes with many outcomes, Gain Ratio corrects this trend by considering the intrinsic information of each split (it basically “normalizes” the Information Gain by using a split information value). This way, the attribute with the maximum Gain Ratio is selected as the splitting attribute.<br>Additionally, C4.5 includes a technique called windowing, which was originally developed to overcome the memory limitations of earlier computers. Windowing means that the algorithm randomly selects a subset of the training data (called a “window”) and builds a DT from that selection. This DT is then used to classify the remaining training data, and if it performs a correct classification, the DT is finished. Otherwise, all the misclassified data points are added to the windows, and the cycle repeats until every instance in the training set is correctly classified by the current DT. This technique generally results in DTs that are more accurate than those produced by the standard process due to the use of randomization, since it captures all the “rare” instances together with sufficient “ordinary” cases.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://towardsdatascience.com/the-complete-guide-to-decision-trees-28a4e3c7be14">https://towardsdatascience.com/the-complete-guide-to-decision-trees-28a4e3c7be14</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Decision Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tree]Random Forest의 이해</title>
    <url>/2022/06/15/ML-SP-Random_Forest/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="Random-Forest"><a href="#Random-Forest" class="headerlink" title="Random Forest"></a>Random Forest</h2><hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>Bagging</strong> : 랜덤 복원추출을 통해 샘플링한 데이터를 바탕으로 피팅한 모델들의 예측결과를 다수결이나 평균을 내어 예측하는 것. </li>
<li><strong>weak learner</strong> : 서로 독립적으로 만들어지며 <strong>상관이 낮은</strong> 약한 분류기.</li>
<li><strong>Random Subspace Method</strong> : Bagging과 유사하지만 Bagging에 추가로 feature를 일부 선택해서 분할하는 것. Random Forest에서 사용</li>
<li><strong>Random Forest</strong> : 여러 <code>week learner</code>들을 합쳐서 하나의 트리를 만드는 것. boosting에 비해 과적합이 덜되는 경향이 있다.</li>
<li><strong>Bootstrap</strong> : datapoint가 n개일 때 n의 크기를 가지는 표본을 복원추출하는 것. 기본적으로 데이터가 편중되지 않게끔 한다.</li>
<li><strong>OOB</strong> : Out of Bag. 부트스트랩에서 추출되지 않는 36.8% 의 샘플.</li>
</ul>
<hr>
<blockquote>
<p>A large number of relatively uncorrelated models (trees) operating as a committee will outperform any of the individual constituent models.</p>
</blockquote>
<p><strong>랜덤포레스트의 핵심적인 컨셉은 위의 인용처럼 서로 상관이 낮은 약한 분류기들을을 합쳐서 강력한 하나의 모델을 만드는 것이다.</strong></p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><img src="https://www.researchgate.net/profile/Xiaogang_He2/publication/309031320/figure/fig1/AS:422331542708224@1477703094069/Schematic-of-the-RF-algorithm-based-on-the-Bagging-Bootstrap-Aggregating-method.png" width="700" />

<p>배깅의 핵심적인 목표는 <strong>의사결정 트리 사이의 분산을 줄이는 것이다.</strong> . Bagging은 기본적으로 모델의 bias를 상승시키지 않으면서 variance를 줄이는 방법이다.이를 위해 배깅에서는 <code>부트스트래핑</code>을 통한 데이터의 서브셋을 각각 학습시켜 독립적이고 서로 상관이 낮은 여러 기본모델들을 만든다. 이렇게 만든 여러 기본모델들의 앙상블이 <code>랜덤 포레스트</code>이다. <code>랜덤포레스트</code>는 한 트리의 오류가 전파되지 않아서 노이즈(이상치)에 강하며 따라서 일반적인 의사결정나무의 약점인 과적합에 강한 모습을 보인다.</p>
<h3 id="Random-Subspace-method"><a href="#Random-Subspace-method" class="headerlink" title="Random Subspace method"></a>Random Subspace method</h3><ul>
<li><p>Bagging과 유사하지만 Bagging에 추가로 feature를 일부 선택해서 분할하는 것. Random Forest에서 사용.</p>
</li>
<li><p>train dataset의 feature가 1개만 있다면 랜덤포레스트와 배깅의 알고리즘이 동일해진다.</p>
</li>
<li><p><strong>feature를 일부 선택해서 분할하는 이유는 설명력이 높은 feature가 모든 <code>weak learner</code>에서 선택되어 모델 간의 예측값의 상관이 높아지는 것을 방지하기 위함이다.</strong></p>
</li>
<li><p>기본모델 생성시 <strong>특성 m개 중 일부분 k개의 특성을 선택(sampling)한다</strong> </p>
</li>
<li><p>k개에서 최적의(information gain이 가장 높은) 특성을 찾아내어 분할함. k개는 일반적으로 $log_2 m$ 를 사용.</p>
</li>
<li><p>$\sqrt{m}$을 k로 활용할 수도 있다.</p>
</li>
<li><p>k가 작아질 수록 각 트리들이 모두 다르게 구성되어 예측력이 향상.</p>
</li>
<li><p>k가 너무 작아지면 가중치가 적은 feature가 상위노드에 들어가 불순도가 높아진다.</p>
</li>
<li><p>k가 너무 커지면 각 트리간 상관이 높아짐(트리들이 비슷해짐).예측력이 하락한다 </p>
</li>
<li><p>서로 상관이 높은 feature가 많은 경우 k를 적게 하는 것이 유리하다.**</p>
</li>
<li><p>트리의 수가 증가해도 과적합되지 않는다. 일정 수준이상으로 많아지면 error rate는 안정되는 경향을 보인다.<br><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/caLvgA/btraSXTXHT3/T0aBmdkrhHd3FCKGsSWN9k/img.png"></p>
</li>
</ul>
<p><strong>배깅과 Random subspave method의 비교</strong></p>
<ul>
<li>bagging: it is better when the training samples are sparse(결측값이 많은 경우)</li>
<li>Random subspace method: it is better when the classes are compact and the boundaries are smooth.</li>
</ul>
<h3 id="Random-Forest-알고리즘"><a href="#Random-Forest-알고리즘" class="headerlink" title="Random Forest 알고리즘"></a>Random Forest 알고리즘</h3><ul>
<li>m개의 feature와 n개의 데이터포인트가 있는 학습데이터에서 부트스트래핑을 통해 서브셋을 추출한다.</li>
<li>m개의 feature에서 각각 k개의 feature를 추출한 서브셋을 가지고 학습해 약한 분류기를 여러개 만든다. </li>
<li>각각의 약한 분류기로 결과를 예측한다.</li>
<li>각 분류기의 예측결과를 모아 최종결과를 도출한다.<ul>
<li>분류 문제일 경우 다수결을 통해 최종 결과를 도출한다</li>
<li>회귀 문제일 경우 평균을 통해 최종결과를 도출한다.</li>
</ul>
</li>
</ul>
<h3 id="Random-Forest-주요-hyperparameter"><a href="#Random-Forest-주요-hyperparameter" class="headerlink" title="Random Forest 주요 hyperparameter"></a>Random Forest 주요 hyperparameter</h3><p><a href="https://www.analyticsvidhya.com/blog/2015/06/tuning-random-forest-model/">Randomforest Hyperparameter</a><br>sklearn에서 제공하는 하이퍼파라미터 기준으로 정리</p>
<ul>
<li>max_featuers : 기본트리에 사용되는 feature의 수. default는 전부 사요하는 것.</li>
<li>n_estimators : 기본트리 수. 커질수록 퍼포먼스가 좋아지지만 학습시간이 오래걸린다.</li>
<li>min_sample_leaf : 리프노드 샘플의 최소값. 작을 수록 학습데이터의 이상치를 잡기 어려워진다. 보통 50이상으로 놓는다.</li>
<li>oob_score : boolen 값. cross validation이랑 비슷. oob sample을 바탕으로 평가를 수행하는 것.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 보통 고려하는 것들</span></span><br><span class="line">&#123;<span class="string">&#x27;bootstrap&#x27;</span>: <span class="literal">True</span>,</span><br><span class="line"> <span class="string">&#x27;criterion&#x27;</span>: <span class="string">&#x27;mse&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;max_depth&#x27;</span>: <span class="number">3</span>, <span class="comment"># depth가 3일때까지만 split</span></span><br><span class="line"> <span class="string">&#x27;max_features&#x27;</span>: <span class="string">&#x27;auto&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;max_leaf_nodes&#x27;</span>: <span class="number">4</span>, <span class="comment"># leaf node가 4개일때까지만 split</span></span><br><span class="line"> <span class="string">&#x27;min_impurity_decrease&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line"> <span class="string">&#x27;min_impurity_split&#x27;</span>: <span class="literal">None</span>,</span><br><span class="line"> <span class="string">&#x27;min_samples_leaf&#x27;</span>: <span class="number">3</span>, <span class="comment"># 생성될 노드들의 샘플 수가 3개 이상이여만 split </span></span><br><span class="line"> <span class="string">&#x27;min_samples_split&#x27;</span>: <span class="number">5</span>, <span class="comment"># 5개 이상의 샘플만 split</span></span><br><span class="line"> <span class="string">&#x27;min_weight_fraction_leaf&#x27;</span>: <span class="number">0.0</span>,</span><br><span class="line"> <span class="string">&#x27;n_estimators&#x27;</span>: <span class="number">10</span>,</span><br><span class="line"> <span class="string">&#x27;n_jobs&#x27;</span>: <span class="number">1</span>,</span><br><span class="line"> <span class="string">&#x27;oob_score&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line"> <span class="string">&#x27;random_state&#x27;</span>: <span class="number">42</span>,</span><br><span class="line"> <span class="string">&#x27;verbose&#x27;</span>: <span class="number">0</span>,</span><br><span class="line"> <span class="string">&#x27;warm_start&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Random-Forest-장단점"><a href="#Random-Forest-장단점" class="headerlink" title="Random Forest 장단점"></a>Random Forest 장단점</h3><p><strong>장점</strong></p>
<ul>
<li>과적합에 강하다.</li>
<li>이상치에 크게 영향받지 않는다.</li>
<li>Scaling이 필요가 없다.</li>
<li>결측값에 크게 영향받지 않는다.</li>
</ul>
<p><strong>단점</strong></p>
<ul>
<li>고차원의 희소한 데이터에 대해 성능이 저하된다.</li>
<li>training 속도 느림(메모리 소모)</li>
<li>개별 트리 분석이 어럽다.</li>
</ul>
<h3 id="Random-Forest-구현"><a href="#Random-Forest-구현" class="headerlink" title="Random Forest 구현"></a>Random Forest 구현</h3><ul>
<li>sklearn을 활용한 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_classification</span><br><span class="line">X, y = make_classification(n_samples=<span class="number">1000</span>, n_features=<span class="number">4</span>,</span><br><span class="line">                            n_informative=<span class="number">2</span>, n_redundant=<span class="number">0</span>,</span><br><span class="line">                            random_state=<span class="number">0</span>, shuffle=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">clf = RandomForestClassifier(max_depth=<span class="number">2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line">RandomForestClassifier(...)</span><br><span class="line"><span class="built_in">print</span>(clf.predict([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]]))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>numpy를 활용한 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .decision_tree <span class="keyword">import</span> DecisionTree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bootstrap_sample</span>(<span class="params">X, y</span>):</span><br><span class="line">    n_samples = X.shape[<span class="number">0</span>]</span><br><span class="line">    idxs = np.random.choice(n_samples, n_samples, replace=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X[idxs], y[idxs]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">most_common_label</span>(<span class="params">y</span>):</span><br><span class="line">    counter = Counter(y)</span><br><span class="line">    most_common = counter.most_common(<span class="number">1</span>)[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> most_common</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomForest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_trees=<span class="number">10</span>, min_samples_split=<span class="number">2</span>, max_depth=<span class="number">100</span>, n_feats=<span class="literal">None</span></span>):</span><br><span class="line">        self.n_trees = n_trees</span><br><span class="line">        self.min_samples_split = min_samples_split</span><br><span class="line">        self.max_depth = max_depth</span><br><span class="line">        self.n_feats = n_feats</span><br><span class="line">        self.trees = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>):</span><br><span class="line">        self.trees = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_trees):</span><br><span class="line">            tree = DecisionTree(</span><br><span class="line">                min_samples_split=self.min_samples_split,</span><br><span class="line">                max_depth=self.max_depth,</span><br><span class="line">                n_feats=self.n_feats,</span><br><span class="line">            )</span><br><span class="line">            X_samp, y_samp = bootstrap_sample(X, y)</span><br><span class="line">            tree.fit(X_samp, y_samp)</span><br><span class="line">            self.trees.append(tree)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        tree_preds = np.array([tree.predict(X) <span class="keyword">for</span> tree <span class="keyword">in</span> self.trees])</span><br><span class="line">        tree_preds = np.swapaxes(tree_preds, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        y_pred = [most_common_label(tree_pred) <span class="keyword">for</span> tree_pred <span class="keyword">in</span> tree_preds]</span><br><span class="line">        <span class="keyword">return</span> np.array(y_pred)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://towardsdatascience.com/understanding-random-forest-58381e0602d2">https://towardsdatascience.com/understanding-random-forest-58381e0602d2</a></li>
<li><a href="https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html">https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Random Forest</tag>
      </tags>
  </entry>
  <entry>
    <title>[SVM]서포트벡터머신의 이해</title>
    <url>/2022/06/15/ML-SP-SVM/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<!--
진짜 ref
https://excelsior-cjh.tistory.com/165


진짜 가장중요한 ref
https://www.baeldung.com/cs/svm-hard-margin-vs-soft-margin

-->

<hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>결정 경계</strong>: 서로 다른 두 데이터를 구분하는 기준선(threshold). 선형 SVM의 결정 경계는 데이터 feature의 n차원의 초평면(hyperplane)이다.</li>
<li><strong>초평면(hyperplane)</strong> : flat affine subspace of p-1 (p는 데이터의 차원) </li>
<li><strong>Support Vector</strong> : 결정 경계와 가장 가까운 데이터 포인트. Soft Margin의 끝에 있는 데이터포인트</li>
<li><strong>Margin</strong> : 결정경계와 Support Vector사이의 거리(threshold와 데이터포인트 사이의 최소거리)</li>
<li><strong>Support Vector Machine</strong> : 마진을 최대화 하는 결정 경계를 찾는 알고리즘.<ul>
<li><strong>Soft Margin</strong> : <strong>Allow misclassification</strong>. outlier의 오분류를 허용함으로써 과적합으로 인한 문제(low bias, high variance) 를 완화시키려고 하는 것. Soft Margin은 오분류를 허용한 경우의 Margin을 뜻한다.</li>
<li><strong>Hard Margin</strong>: 결정경계면이 선형이며 오분류를 허용하지 않는 Margin. 오차항이 없는 경우의 soft margin 을 hard margin이라 한다.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><hr>
<ul>
<li>데이터가 p차원일 경우 분류기(Support Vector Classifier)는 p-1차원의 subspace에 존재한다. 이를 hyperplane이라 한다.</li>
<li>기본적인 컨셉은 margin을 최대화 하는 결정경계를 찾는 것이다.</li>
<li>margin을 크게 할 수록 일반화 성능이 좋아진다.(과적합이 덜 된다.)</li>
<li>마진이 커질경우 일반화 성능이 좋아지지만 bias가 상승한다,</li>
<li>패널티 항을 추가해서 생각하면 SVM에서의 최적화는 결국 마진을 크게 하는 것과 에러에 대한 페널티를 크게 하는 것의 균형으로 볼 수 있다.<ul>
<li>maximizing the margin and minimizing the loss</li>
</ul>
</li>
</ul>
<p><img src="https://www.baeldung.com/wp-content/uploads/sites/4/2021/03/svm-all.png"></p>
<p>margin이 최대화 하려면 결정경계에 해당하는 wx+b&#x3D;0이 되게끔 하는 w를 찾아야 한다.<br>이는 <code>wx+b=0</code>에 수직인 벡터(법선벡터)인 $\frac{2}{|\boldsymbol{w}|}$ 최대화 하는 것이다.(w의 유클리드 norm에 대해 2를 곱해준 것)<br>따라서 $\frac{2}{|\boldsymbol{w}|}$ 를 최대화 하는 것이 SVM의 기본적인 목적이 된다.<br>Graidient 계산을 보다 용이하게 하기 위해 $\frac{2}{|\boldsymbol{w}|}$을 최대화하는 문제를 아래와 같이 치환할 수 있다.</p>
<p>$$\min _{\boldsymbol{w}, b} \frac{1}{2}|\boldsymbol{w}|^{2} \equiv \min _{\boldsymbol{w}, b} \frac{1}{2} \boldsymbol{w}^{T} \boldsymbol{w}$$</p>
<p>class label을 각각 1,-1로 가정할 때 데이터포인트를 정하게 분류하기 위해 다음과 같은 제약조건이 필요하다.</p>
<ul>
<li><strong>양성 plane 보다 위에 있는 관측치는 1보다 커야하고 음성 plane 보다 아래 있는 관측치들은 -1 보다 작아야 한다.</strong></li>
</ul>
<p>이를 모두 만족하는 제약식은 아래와 같다.</p>
<p>$\quad y_{i}\left(\boldsymbol{w}^{T} \boldsymbol{x}_{i}+b\right) \geq 1$</p>
<p>따라서 최적화 문제를 최종적으로 아래와 같이 정리 할 수 있다.</p>
<p>$$\min _{\boldsymbol{w}, b} \frac{1}{2} \boldsymbol{w}^{T} \boldsymbol{w}$$</p>
<p>$$\text { s.t. } \quad y_{i}\left(\boldsymbol{w}^{T} \boldsymbol{x}_{i}+b\right) \geq 1$$</p>
<h3 id="Soft-Margin"><a href="#Soft-Margin" class="headerlink" title="Soft Margin"></a>Soft Margin</h3><hr>
<p>소프트마진은 분류기에 오차를 나타내는 slack variable $\zeta$ 를 목적함수에 추가한다. </p>
<p>hyperparameter C를 통해 loss에 대한 비용을 조정할 수 있다. C가 클 수록 분류오차에 민감해진다. 즉 C값이 커질 경우 마진이 커진다.</p>
<p>반대로 C값을 줄일 경우 bias가 늘어나는 대신 variance가 줄어든다.</p>
<p>소프트 마진 SVM의 최적화 함수는 다음과 같다.</p>
<p>아래의 제약조건을 포함해 생각하면 slack vairable $\zeta$가 0&gt;인 경우를 최소화하고 margin을 최대화 하는 hyperplane을 찾는 것이  Soft Margin SVM의 목적이 된다.</p>
<p>$$\min \frac{1}{2}|\mathbf{w}|^{2}+C \sum_{i&#x3D;1}^{m} \zeta_{i}$$</p>


$$\quad y_{i}\left(\mathbf{w}^{T} \mathbf{x}_{i}+b\right) \geq 1-\zeta_{i} \quad i=1, \ldots, n, \quad \zeta_{i} \geq 0$$



<h3 id="Hinge-Loss"><a href="#Hinge-Loss" class="headerlink" title="Hinge Loss"></a>Hinge Loss</h3><hr>
<p>max(0, 1−yi(wTxi − b)) 는 SVM의 loss function으로 기능한다.</p>
<p>SVM의 loss function은 <code>hinge loss</code> 라고 불리는 데 yi(wTxi − b)이 safety margin인 1보다 크면 loss를 0으로 두고 1보다 작을수록 loss가 크도록 유도한 것이다.</p>
<p>SVM의 hyperparmeter C 는 단순히 hinge loss에 대한 계수이다.</p>
<p>결정경계로 부터의 거리가 0보다 작을 경우 hinge loss가 커지고 이는 데이터포인트가 결정경계의 잘못된 부분에 있는 것을 의미한다.</p>
<p>결정경계로 부터의 거리가 0 과 1 사이에 있는 경우에도 기본적인 loss가 존재하지만 기본적으로 결정경계로부터의 거리가 0보다 커질 경우  loss는 0으로 수렴한다.</p>
<p><img src="https://miro.medium.com/max/1150/1*PGqpYm7o5GCbDXxXErr2JA.png"></p>
<h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><ul>
<li>iris data set에 대해 soft margin 구현</li>
</ul>
<p>사실 직접 구현보다는 그냥 잘 만들어진 프레임워크를 쓰는 것이 훨씬 낫다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> svc</span><br><span class="line">linear_svm = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>,C=<span class="number">1.0</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">linear_svm.fit(X_train,y_train)</span><br></pre></td></tr></table></figure>

<ul>
<li>numpy로 직접구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># numpy로 svm구현</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVM</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,learning_rate=<span class="number">0.0001</span>,lambda_param =<span class="number">0.01</span>,n_iter =<span class="number">1000</span></span>):</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line">        self.lambda_param = lambda_param</span><br><span class="line">        self.n_iters = n_iters</span><br><span class="line">        self.w = <span class="literal">None</span></span><br><span class="line">        self.b = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y</span>):</span><br><span class="line">        y_ = np.where(y&lt;=<span class="number">0</span> ,-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        n_samples = X.shape</span><br><span class="line"></span><br><span class="line">        self.w = np.zeros(n_features) <span class="comment"># 가중치 초기화</span></span><br><span class="line">        self.b = <span class="number">0</span> <span class="comment"># 편향 초기화</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iters):</span><br><span class="line">            <span class="keyword">for</span> idx, x_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(X):</span><br><span class="line">                <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                current index, data point</span></span><br><span class="line"><span class="string">                &quot;&quot;&quot;</span></span><br><span class="line">                condition = y_[idx] * (np.dot(x_i,self.w)) &gt;= <span class="number">1</span> <span class="comment"># 제약조건 구현</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 가중치 업데이트(hinge loss의 gradient update)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> condition:</span><br><span class="line">                    self.w -= self.lr * (<span class="number">2</span> * self.lambda_param * self.w)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.w -= self.lr * (<span class="number">2</span> * self.lambda_param * self.w - np.dot(x_i,y_[idx]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">        linear_output = np.dot(X,self.w) - self.b</span><br><span class="line">        <span class="keyword">return</span> np.sign(linear_output) <span class="comment"># numpy 부호 판별 함수 부호에 따라 -1,1,0 중 하나를 반환</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># weight가 주어졌을 경우 SVM을 시각화하는 함수</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualize_svm</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_hyperplane_value</span>(<span class="params">x, w, b, offset</span>):</span><br><span class="line">        <span class="keyword">return</span> (-w[<span class="number">0</span>] * x + b + offset) / w[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], marker=<span class="string">&quot;o&quot;</span>, c=y)</span><br><span class="line"></span><br><span class="line">    x0_1 = np.amin(X[:, <span class="number">0</span>])</span><br><span class="line">    x0_2 = np.amax(X[:, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    x1_1 = get_hyperplane_value(x0_1, clf.w, clf.b, <span class="number">0</span>)</span><br><span class="line">    x1_2 = get_hyperplane_value(x0_2, clf.w, clf.b, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    x1_1_m = get_hyperplane_value(x0_1, clf.w, clf.b, -<span class="number">1</span>)</span><br><span class="line">    x1_2_m = get_hyperplane_value(x0_2, clf.w, clf.b, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    x1_1_p = get_hyperplane_value(x0_1, clf.w, clf.b, <span class="number">1</span>)</span><br><span class="line">    x1_2_p = get_hyperplane_value(x0_2, clf.w, clf.b, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax.plot([x0_1, x0_2], [x1_1, x1_2], <span class="string">&quot;y--&quot;</span>)</span><br><span class="line">    ax.plot([x0_1, x0_2], [x1_1_m, x1_2_m], <span class="string">&quot;k&quot;</span>)</span><br><span class="line">    ax.plot([x0_1, x0_2], [x1_1_p, x1_2_p], <span class="string">&quot;k&quot;</span>)</span><br><span class="line"></span><br><span class="line">    x1_min = np.amin(X[:, <span class="number">1</span>])</span><br><span class="line">    x1_max = np.amax(X[:, <span class="number">1</span>])</span><br><span class="line">    ax.set_ylim([x1_min - <span class="number">3</span>, x1_max + <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>Reference &amp; Annotaion</strong></p>
<ul>
<li><a href="https://youtu.be/efR1C6CvhmE">https://youtu.be/efR1C6CvhmE</a></li>
<li><a href="https://en.wikipedia.org/wiki/Support-vector_machine">https://en.wikipedia.org/wiki/Support-vector_machine</a></li>
<li><a href="https://towardsdatascience.com/a-definitive-explanation-to-hinge-loss-for-support-vector-machines-ab6d8d3178f1">https://towardsdatascience.com/a-definitive-explanation-to-hinge-loss-for-support-vector-machines-ab6d8d3178f1</a></li>
<li>데이터가 비선형일 경우 커널 트릭을 활용한 고차원 매핑을 시행한다.</li>
<li>법선벡터를 최대화 하는 문제를 최적화 문제로 바꾸는 변환에 주의할 것.</li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Supervised Learning</category>
      </categories>
      <tags>
        <tag>SVM</tag>
        <tag>hyperplane</tag>
      </tags>
  </entry>
  <entry>
    <title>[Regression]머신러닝 관정에서의 회귀</title>
    <url>/2022/06/15/ML-SP-optimization/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h3 id="머신러닝-관점에서의-회귀"><a href="#머신러닝-관점에서의-회귀" class="headerlink" title="머신러닝 관점에서의 회귀"></a>머신러닝 관점에서의 회귀</h3><p>회귀분석에서 MSE은 비용함수이다.<br>비용함수를 최소화 하는 최적화 관점에서 머신러닝을 볼 수 있다.<br>기울기 업데이트를 통해 비용함수(MSE)의 최소값을 찾는다.</p>
<hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>Gradient Descent</strong> : 함수의 기울기(즉, gradient)를 이용해 x의 값을 어디로 옮겼을 때 함수가 최소값을 찾는지 알아보는 방법. 함수값을 최소화 하는 독립변수를 찾는 방법</li>
<li><strong>learning rate</strong> : 학습을 한 내용을 다음 학습에 얼마나 반영할지의 문제. 정확히는 Loss 값을 각각의 가중치로 편미분하여 얻어낸 값에 얼마나 수정을 해야 할 지를 결정하는 하이퍼파라미터 <ul>
<li>learning rate가 너무 크다면 최적점에 도달하지 못하고 모델이 발산할 수 있다.</li>
<li>learning rate가 너무 작다면 최적점에 도달하지 못하고 학습이 끝날 수 있다.</li>
</ul>
</li>
<li><strong>iteration</strong> : 학습(가중치 업데이트)의 반복횟수</li>
<li><strong>weight</strong> : 경사하강법을 통해 업데이트 되는 feature의 가중치</li>
<li><strong>bias</strong> : 활성함수에서 활성화가 잘 될지 안될지를 조절하는 hypterparameter의 일종.기본적으로 function curve 자체를 조정한다.(선형 비선형 상관없이)</li>
</ul>
<hr>
<h4 id="Cost-function-of-Linear-Regression"><a href="#Cost-function-of-Linear-Regression" class="headerlink" title="Cost function of Linear Regression"></a>Cost function of Linear Regression</h4><ul>
<li>이는 가설함수-실제 target 인 오차 제곱합에 대해 평균을 취한 것이다.</li>
<li>비용을 최소화 하는 w와 b를 찾는 것이 머신러닝에서의 학습의 목적이 된다.</li>
<li>이를 아래와 같이 일반화 할 수 있다.</li>
</ul>
<p>$$cost(w, b) &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^{n} \left[y^{(i)} - H(x^{(i)})\right]^2$$</p>
<ul>
<li>단순선형회귀의 경우 아래와 같다</li>
</ul>
<p>$$ f(m,b) &#x3D;  \frac{1}{N} \sum_{i&#x3D;1}^{n} (y_i - (mx_i + b))^2$$</p>
<h4 id="Gradiant-Descent"><a href="#Gradiant-Descent" class="headerlink" title="Gradiant Descent"></a>Gradiant Descent</h4><ul>
<li>경사하강법은 비용함수를 최소화하는 최적화 알고리즘의 일종이다.</li>
<li>오차가 낮아지는 방향으로 이동할 목적으로 현재 위치를 미분한다.</li>
<li><strong>경사하강법의 원리는 반복적인 미분을 통한 w값의 업데이트를 통해 w, cost 지점의 경사(기울기)가 0이 되도록 만드는 것이다.</strong></li>
</ul>
<p><strong>경사하강법의 원리</strong><br><img src="https://i.ytimg.com/vi/b4Vyma9wPHo/maxresdefault.jpg"></p>
<p>일단 비용함수인 MSE부터 시작한다.</p>
<p>$$f(m,b) &#x3D;  \frac{1}{N} \sum_{i&#x3D;1}^{n} (y_i - (mx_i + b))^2$$</p>
<p>미분할 경우 아래와 같이 변하며</p>
<p>$$(y_i - (mx_i + b))^2 &#x3D; A(B(m,b))$$</p>
<p>$$A(x) &#x3D; x^2 $$</p>
<p>$$\frac{df}{dx} &#x3D; A’(x) &#x3D; 2x$$</p>
<p>따라서 다음와 같이 미분할 수 있다.</p>
<p>$$B(m,b) &#x3D; y_i - (mx_i + b) &#x3D; y_i - mx_i - b \~\ $$</p>
<p>$$\frac{dx}{dm} &#x3D; B’(m) &#x3D; 0 - x_i - 0 &#x3D; -x_i \~\ $$</p>
<p>$$\frac{dx}{db} &#x3D; B’(b) &#x3D; 0 - 0 - 1 &#x3D; -1 $$</p>
<p>미분의 <code>Chain Rule</code> 을 활용하여 가중치와 편향의 미분값을 구할 수 있다.</p>
<p>$$\frac{df}{dm} &#x3D; \frac{df}{dx} \frac{dx}{dm} \~\$$</p>
<p>$$ \frac{df}{db} &#x3D; \frac{df}{dx} \frac{dx}{db} $$</p>
<p>가중치와 절편에 Chain Rule을 적용해 미분을 하면 다음과 같다.</p>
<p>$$\frac{df}{dm} &#x3D; A’(B(m,f)) B’(m) &#x3D; 2(y_i - (mx_i + b)) \cdot -x_i \~\$$</p>
<p>$$\frac{df}{db} &#x3D; A’(B(m,f)) B’(b) &#x3D; 2(y_i - (mx_i + b)) \cdot -1$$</p>
<p>따라서 비용함수(MSE)의 Gradiant를 아래과 같이 유도할 수 있다.</p>
<p>$$<br>  \begin{align}<br>  f’(m,b) &#x3D;<br>    \begin{bmatrix}<br>      \frac{df}{dm}\<br>      \frac{df}{db}\<br>    \end{bmatrix}<br>  &amp;&#x3D;<br>    \begin{bmatrix}<br>      \frac{1}{N} \sum -x_i \cdot 2(y_i - (mx_i + b)) \<br>      \frac{1}{N} \sum -1 \cdot 2(y_i - (mx_i + b)) \<br>    \end{bmatrix}\<br>  &amp;&#x3D;<br>    \begin{bmatrix}<br>       \frac{1}{N} \sum -2x_i(y_i - (mx_i + b)) \<br>       \frac{1}{N} \sum -2(y_i - (mx_i + b)) \<br>    \end{bmatrix}<br>  \end{align}<br>$$</p>
<p><strong>최적의 비용함수는 Learning Rate(학습률)와 기울기(Gradient)를 곱한 값을 기존 가중치에서 빼서 새로운 가중치로 설정하는 것을 반복하는 방식으로 구한다.</strong></p>
<p><strong>따라서 최적화하고자 하는 함수 f(x)에 대해 아래와 같이 정리할 수 있다.</strong></p>
<p>$$x_{i+1} &#x3D; x_i - \alpha \frac{df}{dx}(x_i)$$</p>
<p><strong>기본적으로 반복횟수가 많아질수록 오차가 줄어들어야 한다.</strong></p>
<p><img src="https://ml-cheatsheet.readthedocs.io/en/latest/_images/linear_regression_training_cost.png"></p>
<h4 id="Gradiant-Descent를-활용한-선형회귀-구현"><a href="#Gradiant-Descent를-활용한-선형회귀-구현" class="headerlink" title="Gradiant Descent를 활용한 선형회귀 구현"></a>Gradiant Descent를 활용한 선형회귀 구현</h4><ul>
<li>dw는 비용함수인 MSE를 가중치 W에 대하여 편미분한 것이다.</li>
<li>db는 비용함수인 MSE를 편향 b에 대하여 편미분한 것이다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r2_score</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    corr_matrix = np.corrcoef(y_true, y_pred)</span><br><span class="line">    corr = corr_matrix[<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> corr ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinearRegression</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lr = <span class="number">0.001</span>, n_iters = <span class="number">1000</span></span>):</span><br><span class="line">    self.lr = lr</span><br><span class="line">    self.n_iters = n_iters</span><br><span class="line">    self.weigts = <span class="literal">None</span></span><br><span class="line">    self.bias = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># init paremeters : 시작지점을 초기화 한다.</span></span><br><span class="line">    n_samples , n_features = X.shape</span><br><span class="line">    self.weigts = np.zeros(n_features)</span><br><span class="line">    self.bias = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iters):</span><br><span class="line">      y_pred = np.dot(X,self.weigts) + self.bias</span><br><span class="line"></span><br><span class="line">      dw = (<span class="number">1</span>/n_samples) * np.dot(X.T,(y_pred - y)) <span class="comment"># 가중치의 기울기(Gradiant)(미분값)</span></span><br><span class="line">      db = (<span class="number">1</span>/n_samples) * np.<span class="built_in">sum</span>(y_pred - y) <span class="comment"># 편향의 기울기</span></span><br><span class="line"></span><br><span class="line">      self.weigts -= self.lr * dw <span class="comment"># 기울기 업데이트</span></span><br><span class="line">      self.bias -= self.lr * db <span class="comment"># 편향 업데이트</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">    y_pred = np.dot(X,self.weigts) + self.bias</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://angeloyeo.github.io/2020/08/24/linear_regression.html">경사하강법과 회귀</a></li>
<li><a href="https://youtu.be/4swNt7PiamQ?list=PLqnslRFeH2Upcrywf-u2etjdxxkL8nl7E">ML from scratch</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Classification]로지스틱 회귀와 크로스엔트로피</title>
    <url>/2022/06/15/ML-SP-logistic_regression/</url>
    <content><![CDATA[<!--

<center >Kaggle Customer Score Dataset</center>

- Machine Learning
- Deep Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->


<h2 id="Logistic-Regression"><a href="#Logistic-Regression" class="headerlink" title="Logistic Regression"></a>Logistic Regression</h2><p><strong>로지스틱회귀의 파라미터 추정은 Feature X에 대한 선형회귀모델을 X에 대한 target의 log odds에 Fitting하는 것이다.</strong></p>
<p><strong>Fitting의 방식</strong></p>
<p>Maximum Likelyhood를 최대화하는 것 &#x3D; 이항편차(binary deviance)를 줄이는 것 &#x3D; cross entropy loss 를 줄이는 것</p>
<p>MLE(Maximum Likelyhood Estimation)를 통해 이해할 수도 있지만 여기서는 Cross Entropy를 통한 최적화 관점에서의 Logistic 회귀를 주로 다룬다.</p>
<hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>Cross Entropy</strong> :두 개의 확률분포 p와 q에 대해 하나의 사건 X가 갖는 정보량<ul>
<li><strong>Cross Entropy</strong> 는 기본적으로 <strong>추정된 분포가 실제의 분포와 열마나 가까운지</strong> 를 결정한다.</li>
</ul>
</li>
<li><strong>sigmoid</strong> : input을 0과 1사이로 조정하여 반환하는 활성화 함수의 일종</li>
<li><strong>softmax</strong> : 로지스틱 회귀를 다중 클래스 분류로 확장할때 사용하는 활성화 함수.분류될 클래스가 n개라 할 때, n차원의 벡터를 입력받아, 각 클래스에 속할 확률을 추정한다.</li>
<li><strong>모수(Parameter)</strong> : 머신러닝에서 파라미터는 <strong>모델의 형태를 결정하는 값</strong>으로 정의할 수 있다. 예를 들어 y &#x3D; wx+b라는 모델이 주어졌을 때 w,b가 모델의 모수가 된다.</li>
<li><strong>우도</strong> : 확률 분포의 모수가, 어떤 확률변수의 표집값과 일관되는 정도를 나타내는 값. <strong>관측값이 고정되어있을 때</strong> 그 관측치가 어떤 확률분포에서 나왔는가의 문제 </li>
<li><strong>최대우도추정(Maxium Likelyhood Estimation)</strong> :얻어진 데이터를 토대로 그 확률변수의 모수를 구하는 방법이다. 어떤 모수가 주어졌을 때, 원하는 값들이 나올 우도함수를 최대로 만드는 <strong>모수를 선택하는 방법</strong>이다.<ul>
<li>**관측값(데이터) 가 주어진 상태에서 그 관측값이 나올 우도함수 **</li>
<li>– MLE관점에서 볼때 로지스틱회귀는 x와 w가 주어졌을 때 y의 확률. y의 확률이 나올 수 있는 w의 최대값을 구하는 문제이다.</li>
</ul>
</li>
<li>우도함수 :  가능도함수는 모수가 $\theta$일 때, 특정 표본 x 가 나타날 함수.</li>
</ul>
<hr>
<p><strong>정리</strong></p>
<ul>
<li>Linear regression 에서는 연속적인 값을 출력하는 반면 Logistic regression에서 기본적으로 기대되는 output은 확률이다.</li>
<li><strong>오차함수의 기본적인 검증 방식이 0이나 1로부터 예측값이 얼마나 떨어져 있는 지를 측정하는 것이다</strong></li>
<li>확률을 도출하기 위해 <strong>선형모델에 sigmoid 함수를 적용</strong>한다.</li>
<li>기본적으로 L2규제를 적욯하기 때문에 규제를 강하게 하면 계수가 0에 가깝게 되지만 완전히 0이 되지는 않는다.</li>
<li>설명하기 쉬운 모델을 원한다면 특성의 개수를 제한하는 L1규제를 사용한다. <ul>
<li>L1규제는 0이 많은 sparse data에 적합하다.</li>
</ul>
</li>
<li>Hyperparameter C를 통해 규제의 강도를 결정한다.</li>
<li>C는 Ridge나 Lasso에서의 규제강도인 alpha($\lambda$)의 inverse이다. 다시말해 <strong>C 값이 높을 수록 규제가 감소하고 C값이 낮으면 계수 벡터가 0에 가까워진다</strong>.(피쳐의 영향이 줄어든다.)</li>
<li>이는 C의 값이 낮다면 데이터 포인트를 다수에 맞추려고 하는 반면 C의 값이 높다면 개개의 데이터 포인트를 명확하게 분류하고자 하는 알고리즘으로 볼 수 있다.</li>
</ul>
<h4 id="Cost-function-in-Logistic-Regression-Cross-Entropy"><a href="#Cost-function-in-Logistic-Regression-Cross-Entropy" class="headerlink" title="Cost function in Logistic Regression (Cross Entropy)"></a>Cost function in Logistic Regression (Cross Entropy)</h4><ul>
<li><strong>Cross Entropy는 두 개의 확률분포 p와 q에 대해 하나의 사건 X가 갖는 정보량이다</strong>. 즉, 서로 다른 두 확률분포에 대해 같은 사건이 가지는 정보량을 계산한 것이다.</li>
<li>기본적으로 <strong>추정된 분포가 실제의 분포와 열마나 가까운지</strong> 를 결정한다.<ul>
<li>p(x)는 true label의 분포를 one-hot encoding 형식으로 나타낸 것이다.</li>
<li>q(x)는 현재 예측모델의 추정값의 분포이다.</li>
</ul>
</li>
<li>모형이 예측한 확률분포들 중 정답에 해당하는 위치의 뉴런에 -log를 취한 것이 출력값이 된다.</li>
<li><code>-log</code> 를 취하는 이유는 출력값이 0,1 사이의 확률값으로 나와하 하기때문이다.</li>
</ul>
<p><img src="https://i.stack.imgur.com/gNip2.png" alt="크로스 엔트로피 수식"></p>
<ul>
<li><p>MSE을 비용함수로 사용할 경우 국소 최소값에 빠질 가능성이 있어 크로스 엔트로피 함수를 사용한다.</p>
</li>
<li><p><strong>정답에 해당하는 뉴런값의 오차만 계산에 들어간다는 것이 특징이다.</strong></p>
</li>
<li><p>정답에 해당하는 위치의 뉴런이 0에 가까워 질수록 y값이 exponential하게 증가하게 된다.</p>
</li>
<li><p>Best case는 모델이 예측한 분포와 타겟의 분포가 같은 경우. 이 경우 오차가 0이된다.</p>
</li>
<li><p>worst case는 target 위치의 뉴런 값이 0인 경우이며 이 때 Cross Entropy 오차는 무한히 증가한다.</p>
</li>
</ul>
<p><img src="https://ml-cheatsheet.readthedocs.io/en/latest/_images/y1andy2_logistic_function.png" alt="크로스 엔트로피 오차"></p>
<ul>
<li>크로스 엔트로피 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">p = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>])             <span class="comment"># True probability (one-hot)</span></span><br><span class="line">q = np.array([<span class="number">0.228</span>, <span class="number">0.619</span>, <span class="number">0.153</span>]) <span class="comment"># Predicted probability</span></span><br><span class="line"></span><br><span class="line">cross_entropy_loss = -np.<span class="built_in">sum</span>(p * np.log(q))</span><br><span class="line"><span class="built_in">print</span>(cross_entropy_loss)</span><br><span class="line"><span class="comment"># 0.47965000629754095</span></span><br></pre></td></tr></table></figure>

<ul>
<li>크로스 엔트로피 비용함수를 통해 로지스틱 회귀 모형의 목적함수를 정의할 수 있다.<ul>
<li>$\lambda \rVert W \rVert_2$ 는 l2 규제항이다.</li>
<li>$\lambda$ 가 0이 되면 규제항이 없는 단순 로지스틱회귀가 된다. </li>
<li>$\lambda$가 커질수록 W가 줄어든다.($\lambda$가 무한대로 가면 가중치는 0으로 수렴)</li>
<li>$\lambda$ 수치를 조정함으로서  fit과 magnitude 사이에서 균형을 맞출 수 있다.</li>
<li>C는 $\lambda$ 역수로 sklearn에서 hyperparameter로 쓰인다.</li>
</ul>
</li>
</ul>
<p>$$J(w) &#x3D; -\frac{1}{m} \sum_{i&#x3D;1}^{m} [y^{(i)}logH(x^{(i)}) + (1-y^{(i)})log(1-H(x^{(i)}))]+\lambda \rVert W \rVert_2$$</p>
<p>아래와 같이 보다 간소화 해서 작성할 수 있다.</p>
<p>$$J(w)&#x3D;\frac{1}{m} \sum_{i&#x3D;1}^{m} \operatorname{Cost}\left(h\left(x^{(i)}\right), y^{(i)}\right)+\frac{\lambda}{2 m} \sum_{j&#x3D;1}^{n} w_{j}^{2}$$</p>
<p>이 경우 업데이트 시 <strong>Gradiant를</strong> 아래아 같이 작성할 수 있다.</p>
<p>$$\frac{\partial}{\partial w_{i}} J(w)&#x3D;\frac{1}{m}\left[\sum_{j&#x3D;1}^{m}\left(h\left(x^{(j)}\right)-y^{(j)}\right) x_{i}^{(j)}+\lambda w_{i}\right]$$</p>
<h4 id="Sigmoid-Function"><a href="#Sigmoid-Function" class="headerlink" title="Sigmoid Function"></a>Sigmoid Function</h4><ul>
<li>input을 0과 1사이로 조정하여 반환하는 활성화 함수의 일종.</li>
<li>기준점인 0.5를 기준으로 출력값을 결정한다.</li>
<li>w가 커질수록 기울기가 커진다.</li>
<li>b의 크기에 따라 함수 자체가 이동한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 시그모이드 구현</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sigmoid non-convex logistic least squares cost function</span></span><br><span class="line"><span class="comment"># convex 한것은 비용함수가 구불구불해서 국소 최저점이 존재하는 것</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid_least_squares</span>(<span class="params">w</span>):</span><br><span class="line">    cost = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> <span class="built_in">range</span>(y.size):</span><br><span class="line">        x_p = x[:,p]</span><br><span class="line">        y_p = y[:,p]</span><br><span class="line">        cost += (sigmoid(w[<span class="number">0</span>] + w[<span class="number">1</span>]*x_p) - y_p)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> cost/y.size</span><br></pre></td></tr></table></figure>

<p><img src="https://jermwatt.github.io/machine_learning_refined/mlrefined_images/superlearn_images/sigmoid.png"></p>
<h3 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h3><ul>
<li>로지스틱 회귀를 다중클래스 분류로 확장한 것.</li>
<li>분류하고자 하는 클래스가 n개일 때, n차원의 벡터를 입력받아서 모든 벡터 원소의 값을 0과 1사이의 값으로 값을 변경하여 다시 k차원의 벡터를 리턴한다.</li>
<li>소프트맥스 함수는 분류될 클래스가 n개라 할 때, n차원의 벡터를 입력받아, 각 클래스에 속할 확률을 추정한다.</li>
</ul>
<p><img src="https://www.gstatic.com/education/formulas2/397133473/en/softmax_function.svg"></p>
<ul>
<li><p><strong>확률의 총합이 1이다.</strong></p>
</li>
<li><p>식 자체는 단순하게 <code>probability = exp(value) / sum v in list exp(v)</code> 로 나타낼 수 있다. <code>n번째 일 확률 / 전체 확률</code> 로 생각하면 된다. </p>
</li>
<li><p><a href="https://gooopy.tistory.com/53">지수함수(exp)가 식에 포함된 이유</a></p>
</li>
<li><p>softmax 구현</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: <span class="keyword">from</span> numpy <span class="keyword">import</span> exp</span><br><span class="line">   ...:</span><br><span class="line">   ...: </span><br><span class="line">   ...: <span class="keyword">def</span> <span class="title function_">softmax</span>(<span class="params">vector</span>):</span><br><span class="line">   ...:   e = exp(vector)</span><br><span class="line">   ...:   <span class="keyword">return</span> e / e.<span class="built_in">sum</span>()</span><br><span class="line">   ...:</span><br><span class="line">   ...: </span><br><span class="line">   ...: data = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">   ...: <span class="comment"># convert list of numbers to a list of probabilities</span></span><br><span class="line">   ...: result = softmax(data)</span><br><span class="line">   ...: <span class="comment"># report the probabilities</span></span><br><span class="line">   ...: <span class="built_in">print</span>(result)</span><br><span class="line">   ...: <span class="comment"># report the sum of the probabilities</span></span><br><span class="line">   ...: <span class="built_in">print</span>(<span class="built_in">sum</span>(result))</span><br><span class="line">[<span class="number">0.09003057</span> <span class="number">0.66524096</span> <span class="number">0.24472847</span>]</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h3><ul>
<li><p>numpy를 활용한 구현</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 정확도를 측정하기 위한 accuracy 함수</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_true,y_pred</span>):</span><br><span class="line">  accuracy = np.<span class="built_in">sum</span>(y_true==y_pred)/<span class="built_in">len</span>(y_true)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LogisticRegression</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,lr=<span class="number">0.001</span>,n_iters=<span class="number">1000</span></span>):</span><br><span class="line">    self.lr = lr</span><br><span class="line">    self.n_iters = n_iters</span><br><span class="line">    self.weigts = <span class="literal">None</span></span><br><span class="line">    self.bias = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y</span>):</span><br><span class="line">    <span class="comment"># init parameters</span></span><br><span class="line"></span><br><span class="line">    n_samples, n_features = X.shape</span><br><span class="line"></span><br><span class="line">    self.weigts = np.zeros(n_features)</span><br><span class="line">    self.bias =<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># gradient descent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(self.n_iters):</span><br><span class="line">      linear_model = np.dot(X,self.weigts)+self.bias</span><br><span class="line"></span><br><span class="line">      y_pred = self._sigmoid(linear_model) <span class="comment"># 선형모델에 sigmoid 적용</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      dw = (<span class="number">1</span>/n_samples) * np.dot(X.T,(y_pred-y)) <span class="comment"># W에 대해 편미분</span></span><br><span class="line">      db = (<span class="number">1</span>/n_samples) * np.<span class="built_in">sum</span>(y_pred-y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      self.weigts = -= self.lr * dw</span><br><span class="line">      self.bias = -= self.lr*db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">    linear_model = np.dot(X,self.weigts)+self.bias</span><br><span class="line">    y_pred = self._sigmoid(linear_model) <span class="comment"># 0~1 사이의 float을 반환</span></span><br><span class="line"></span><br><span class="line">    y_pred_class = [<span class="number">1</span> <span class="keyword">if</span> i &gt; <span class="number">0.5</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> y_pred] <span class="comment"># 값을 0,1로 고정</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> y_pred_class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">_sigmoid</span>(<span class="params">self,x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(<span class="number">1</span>+np.exp(-x))</span><br></pre></td></tr></table></figure>
</li>
<li><p>sklearn을 활용한 구현</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">X, y = load_iris(return_X_y=<span class="literal">True</span>)</span><br><span class="line">clf = LogisticRegression(random_state=<span class="number">0</span>).fit(X, y)</span><br><span class="line">clf.predict(X[:<span class="number">2</span>, :])</span><br><span class="line"></span><br><span class="line">clf.predict_proba(X[:<span class="number">2</span>, :]) <span class="comment"># 확률 출력</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clf.score(X, y)</span><br></pre></td></tr></table></figure>

<ul>
<li>tensorflow를 활용한 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">0.42264594</span>, <span class="number">0.4524148</span> , <span class="number">0.93797131</span>, <span class="number">0.36534474</span>, <span class="number">0.40276151</span>,<span class="number">0.29153749</span>, <span class="number">0.05982402</span>, <span class="number">0.24713247</span>, <span class="number">0.91650771</span>, <span class="number">0.45207763</span>])</span><br><span class="line">y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]) </span><br><span class="line"></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(<span class="number">1</span>, input_dim=<span class="number">1</span>, activation=<span class="string">&#x27;sigmoid&#x27;</span>))</span><br><span class="line"></span><br><span class="line">sgd = optimizers.SGD(lr=<span class="number">0.001</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=sgd ,loss=<span class="string">&#x27;binary_crossentropy&#x27;</span>, metrics=[<span class="string">&#x27;binary_accuracy&#x27;</span>])</span><br><span class="line"></span><br><span class="line">model.fit(x, y, epochs=<span class="number">200</span>)</span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://stackoverflow.com/questions/41990250/what-is-cross-entropy/41990932">Cross Entropy</a></li>
<li><a href="https://youtu.be/yIYKR4sgzI8?list=PLblh5JKOoLUKxzEP5HA2d-Li7IJkHfXSe">Logistic Regression</a></li>
<li><a href="https://ml-cheatsheet.readthedocs.io/en/latest/logistic_regression.html">로지스틱 회귀 구현</a></li>
<li><a href="https://developers.google.com/machine-learning/crash-course/multi-class-neural-networks/softmax">소프트맥스</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Logistic Regression</tag>
        <tag>Cross Entropy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]단순선형회귀 구현하기(Simple Regression)</title>
    <url>/2021/06/08/ML-SP-simple_regression/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul>
<li>Python 선형회귀 연습하기</li>
<li>nbconvert를 활용해 ipynb파일을 마크다운 파일로 변환</li>
</ul>
<h2 id="scikit-learn을-활용한-단순선형회귀"><a href="#scikit-learn을-활용한-단순선형회귀" class="headerlink" title="scikit-learn을 활용한 단순선형회귀"></a>scikit-learn을 활용한 단순선형회귀</h2><h3 id="데이터-불러오기-및-전처리"><a href="#데이터-불러오기-및-전처리" class="headerlink" title="데이터 불러오기 및 전처리"></a>데이터 불러오기 및 전처리</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">&#x27;../data/kc_house_data.csv&#x27;</span>)</span><br><span class="line">df.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>date</th>
      <th>price</th>
      <th>bedrooms</th>
      <th>bathrooms</th>
      <th>sqft_living</th>
      <th>sqft_lot</th>
      <th>floors</th>
      <th>waterfront</th>
      <th>view</th>
      <th>...</th>
      <th>grade</th>
      <th>sqft_above</th>
      <th>sqft_basement</th>
      <th>yr_built</th>
      <th>yr_renovated</th>
      <th>zipcode</th>
      <th>lat</th>
      <th>long</th>
      <th>sqft_living15</th>
      <th>sqft_lot15</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>7129300520</td>
      <td>20141013T000000</td>
      <td>221900.0</td>
      <td>3</td>
      <td>1.00</td>
      <td>1180</td>
      <td>5650</td>
      <td>1.0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>7</td>
      <td>1180.0</td>
      <td>0</td>
      <td>1955</td>
      <td>0</td>
      <td>98178</td>
      <td>47.5112</td>
      <td>-122.257</td>
      <td>1340</td>
      <td>5650</td>
    </tr>
    <tr>
      <th>1</th>
      <td>6414100192</td>
      <td>20141209T000000</td>
      <td>538000.0</td>
      <td>3</td>
      <td>2.25</td>
      <td>2570</td>
      <td>7242</td>
      <td>2.0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>7</td>
      <td>2170.0</td>
      <td>400</td>
      <td>1951</td>
      <td>1991</td>
      <td>98125</td>
      <td>47.7210</td>
      <td>-122.319</td>
      <td>1690</td>
      <td>7639</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5631500400</td>
      <td>20150225T000000</td>
      <td>180000.0</td>
      <td>2</td>
      <td>1.00</td>
      <td>770</td>
      <td>10000</td>
      <td>1.0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>6</td>
      <td>770.0</td>
      <td>0</td>
      <td>1933</td>
      <td>0</td>
      <td>98028</td>
      <td>47.7379</td>
      <td>-122.233</td>
      <td>2720</td>
      <td>8062</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2487200875</td>
      <td>20141209T000000</td>
      <td>604000.0</td>
      <td>4</td>
      <td>3.00</td>
      <td>1960</td>
      <td>5000</td>
      <td>1.0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>7</td>
      <td>1050.0</td>
      <td>910</td>
      <td>1965</td>
      <td>0</td>
      <td>98136</td>
      <td>47.5208</td>
      <td>-122.393</td>
      <td>1360</td>
      <td>5000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1954400510</td>
      <td>20150218T000000</td>
      <td>510000.0</td>
      <td>3</td>
      <td>2.00</td>
      <td>1680</td>
      <td>8080</td>
      <td>1.0</td>
      <td>0</td>
      <td>0</td>
      <td>...</td>
      <td>8</td>
      <td>1680.0</td>
      <td>0</td>
      <td>1987</td>
      <td>0</td>
      <td>98074</td>
      <td>47.6168</td>
      <td>-122.045</td>
      <td>1800</td>
      <td>7503</td>
    </tr>
  </tbody>
</table>
<p>5 rows × 21 columns</p>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 가 파이썬에서 뭘 의미하는지 찾아보자</span></span><br><span class="line"><span class="comment"># https://mingrammer.com/understanding-the-asterisk-of-python/</span></span><br><span class="line"><span class="comment"># https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/</span></span><br><span class="line">use_col = df.columns.tolist()[<span class="number">3</span>:]</span><br><span class="line"><span class="built_in">print</span>(*use_col, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>bedrooms
bathrooms
sqft_living
sqft_lot
floors
waterfront
view
condition
grade
sqft_above
sqft_basement
yr_built
yr_renovated
zipcode
lat
long
sqft_living15
sqft_lot15
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 상관행렬 구하기</span></span><br><span class="line">corrMatrix = df.corr()</span><br><span class="line"><span class="comment"># 상관행렬에서 타겟변수 추출</span></span><br><span class="line">price_col = corrMatrix[<span class="string">&#x27;price&#x27;</span>].to_frame().reset_index()</span><br><span class="line"><span class="comment"># 상관계수높은 순으로 정렬</span></span><br><span class="line">price_col.sort_values(<span class="string">&#x27;price&#x27;</span>,ascending=<span class="literal">False</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">price_col.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>index</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>price</td>
      <td>1.000000</td>
    </tr>
    <tr>
      <th>4</th>
      <td>sqft_living</td>
      <td>0.702035</td>
    </tr>
    <tr>
      <th>10</th>
      <td>grade</td>
      <td>0.667434</td>
    </tr>
    <tr>
      <th>11</th>
      <td>sqft_above</td>
      <td>0.605567</td>
    </tr>
    <tr>
      <th>18</th>
      <td>sqft_living15</td>
      <td>0.585379</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 가장 상관관계가 높은 변수 시각화</span></span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&#x27;whitegrid&#x27;</span>, context=<span class="string">&#x27;notebook&#x27;</span>)</span><br><span class="line">g=sns.pairplot(df[[<span class="string">&#x27;price&#x27;</span>,<span class="string">&#x27;sqft_living&#x27;</span>]])</span><br><span class="line"><span class="keyword">for</span> ax <span class="keyword">in</span> g.axes.flatten(): <span class="comment"># y축 한정 과학적 표기법을 일반 표기법으로 바꿔주기</span></span><br><span class="line">    ax.ticklabel_format(style=<span class="string">&#x27;plain&#x27;</span>, scilimits=(<span class="number">0</span>,<span class="number">0</span>), axis=<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="comment">#plt.ticklabel_format(style=&#x27;plain&#x27;, axis=&#x27;y&#x27;)</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>


<p><img src="/ML-SP-simple_regression/1_simple-regression_6_0.png" alt="png"></p>
<h3 id="Baseline-Model-만들기"><a href="#Baseline-Model-만들기" class="headerlink" title="Baseline Model 만들기"></a>Baseline Model 만들기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># get baseline model</span></span><br><span class="line">baseline = df[<span class="string">&#x27;price&#x27;</span>].mean()</span><br><span class="line">errors = df[<span class="string">&#x27;price&#x27;</span>] - baseline</span><br><span class="line">mae = errors.<span class="built_in">abs</span>().mean()</span><br><span class="line"></span><br><span class="line">sns.lineplot(x=df[<span class="string">&#x27;grade&#x27;</span>], y=baseline, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">sns.scatterplot(data=df, x=<span class="string">&quot;grade&quot;</span>, y=<span class="string">&quot;price&quot;</span>)</span><br><span class="line">plt.ticklabel_format(style=<span class="string">&#x27;plain&#x27;</span>, axis=<span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="/ML-SP-simple_regression/1_simple-regression_8_0.png" alt="png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#기본적으로 모델이 다중회귀를 가정하기 때문에 Feature의 선언을 배열로 해줘야 한다.</span></span><br><span class="line"></span><br><span class="line">X = df[[<span class="string">&#x27;sqft_living&#x27;</span>]] </span><br><span class="line">y = df[<span class="string">&#x27;price&#x27;</span>]</span><br><span class="line">m = LinearRegression()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m.fit(X,y)</span><br></pre></td></tr></table></figure>




<pre><code>LinearRegression()
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_test = [[<span class="number">6000</span>]]</span><br><span class="line">y_pred = m.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;sqft_living이 <span class="subst">&#123;X_test[<span class="number">0</span>][<span class="number">0</span>]&#125;</span>인 경우의 예상 가격은 <span class="subst">&#123;<span class="built_in">int</span>(y_pred)&#125;</span>로 나타남&#x27;</span>)</span><br></pre></td></tr></table></figure>

<pre><code>sqft_living이 6000인 경우의 예상 가격은 1640160로 나타남
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 통계량 확인</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;coefficient-score : &quot;</span>,m.coef_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;intercept : &quot;</span> , m.intercept_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;coefficient of determination: &#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(m.score(X,y)))</span><br></pre></td></tr></table></figure>

<pre><code>coefficient-score :  [280.6235679]
intercept :  -43580.74309447361
coefficient of determination: 0.49
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://scikit-learn.org/stable/modules/linear_model.html">https://scikit-learn.org/stable/modules/linear_model.html</a></li>
<li><a href="https://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html#sphx-glr-auto-examples-linear-model-plot-ols-py">https://scikit-learn.org/stable/auto_examples/linear_model/plot_ols.html#sphx-glr-auto-examples-linear-model-plot-ols-py</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Supervised Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Unsupervised Learning]주성분분석(PCA)의 이해</title>
    <url>/2021/05/29/ML-US-PCA/</url>
    <content><![CDATA[<ul>
<li><strong>비지도학습은 라벨이 달린 데이터를 이용해 데이터를 학습하는 과정 없이 데이터로부터 의미를 추출하는 것이다.</strong></li>
<li><strong>비지도학습의 목적은 크게 차원축소와 클러스터링 두 가지로 나눌 수 있다.</strong></li>
</ul>
<hr>
<ul>
<li><strong>비지도학습</strong><ul>
<li><strong>차원축소(PCA)</strong> : 데이터의 변수를 관리 가능한 수준으로 차원을 줄이는 것, 변수와 레코드의 수가 아주 큰 상황이라면 차원축소를을 EDA의 연장으로 볼 수있다. <ul>
<li>PCA</li>
<li>LDA</li>
<li>SVD</li>
<li>요인분석</li>
<li>etc</li>
</ul>
</li>
<li><strong>클러스터링</strong>: 라벨이 정해진 응답변수가 없는 상황에서 예측 규칙을 만드는 것(그룹화)<ul>
<li>K평균 클러스터링</li>
<li>계층적 클러스터링</li>
<li>모델기반 클러스터링</li>
<li>etc</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="주성분분석-PCA"><a href="#주성분분석-PCA" class="headerlink" title="주성분분석(PCA)"></a>주성분분석(PCA)</h2><blockquote>
<p><strong>주성분분석은 데이터의 차원을 줄이기 위해, 공분산 행렬에서 고유 벡터&#x2F;고유값을 구하고 가장 분산이 큰 방향을 가진 고유벡터에 입력데이터를 선형변환하는 것이다.</strong></p>
</blockquote>
<p>위 말을 이해하기 위해서는 차원축소를 하는 이유와 선형대수 관련 개념을 조금 알아야 한다.</p>
<h3 id="차원을-줄이는-이유"><a href="#차원을-줄이는-이유" class="headerlink" title="차원을 줄이는 이유"></a>차원을 줄이는 이유</h3><p>차원을 줄이는 이유는 크게 두 가지가 있는데 하나는 메모리 소모를 줄이기 위해서고 다른 하나는 차원의 저주 때문이다.</p>
<p><strong>메모리 소모 문제</strong><br>R을 생각해보자. R을 써본 사람은 알겠지만 정말 개같이 느린 언어이다. 이는 R이 물리적 메모리를 저장하는 방식을 사용하기 때문이다.물론 파이썬도 그렇게 빠른 언어는 아니다. 넘파이가 빠른거지 파이썬이 빠른게 아니다. 그리고 넘파이는 C랑 포트란으로 짜여졌다.<br>이처럼 수치해석을 하기에는 너무나도 느린 언어들로 큰 데이터를 분석하다보면 시간은 시간대로 날려먹고 제대로된 결과를 뽑지 못할 가능성이 높다. 따라서 데이터양이(정확히는 데이터 n값과 predictor의 수의 곱이) 너무 많을 경우 PCA등의 차원축소기법을 사용해 데이터의 차원을 줄여 분석에 쓰이는 연산량을 줄이는 방법을 사용한다.</p>
<p><strong>차원의 저주(curse of demention)</strong><br>데이터의 수보다 데이터의 차원이 더 큰 경우를 차원의 저주라고 하는데 이경우 모델링이 복잡해지고 예측력이 낮아진다. 이러면 모델링 자체가 쓸모없어지기에 차원이 너무 많은 경우 Feature Selection이나 Feature Extraction 등을 통해 사전 처리를 해줄 필요가 있다. </p>
<h3 id="공분산행렬"><a href="#공분산행렬" class="headerlink" title="공분산행렬"></a><strong>공분산행렬</strong></h3><p>공분산행렬만 이해하면 PCA는 사실 그렇게 어렵지는 않다. PCA는 단순히 공분산행렬의 고유벡터를 기저벡터로 바꾼 것에 불과하다.일단 공분산이 뭔지 알아야 한다.<br>공분산은 교차곱편차의 평균이다. 이는 각 변수들의 편차들의 곱들을 모두 더해 n으로 나눈 값을 의미한다.</p>
<p>데이터 매트릭스 X에 대해서 공분산행렬을 아래와 같이 나타낼 수 있다.(자유도때문에 n-1로 나눠줌)</p>
<p>$$Cov(X) &#x3D; \frac{1}{n-1}X^TX$$</p>
<p>공분산은 <strong>기본적으로 변수들이 함께 변화하는 정도</strong>이다.</p>
<p>공분산행렬은 <strong>대각성분을 설명변수의 분산으로 채우고 나머지를 공분산으로 채운 행렬이다.</strong></p>
<p><img src="/covariance_matrix.png"><br><strong>그림1. 한번에 이해하는 공분산 행렬</strong></p>
<h3 id="선형변환"><a href="#선형변환" class="headerlink" title="선형변환"></a>선형변환</h3><ul>
<li><strong>행렬은 선형변환을 나타낸다.</strong></li>
<li>선형은 곱하고 더하는 것으로만 이루어져 있다.(문과식 이해의 한계)</li>
<li>벡터 <code>[a,b]</code> 의 와 행렬 M을 곱해 벡터 <code>[c,d]</code>가 나왔을 경우 </li>
<li><code>[c,d]</code>는 유닛 벡터 <code>[x,y]</code> 의 의 a배와 b 배의 합으로 이해할 수 있다. </li>
<li>이처럼 선형변환은 기본적으로 행렬과 벡터의 곱의 형태로 나타낼 수잇다.</li>
</ul>
<p>다시 생각해 보면 다음과 같다.</p>
<ul>
<li><code>f</code> 라는 어떤 매핑을 사용하여 </li>
<li>임의의 벡터 <code>[a, b]</code>에 대해서, </li>
<li><code>[2a + b, a -2b ]</code>로 바꾼다는 것은 아래와 같이 나타낼 수 있다.</li>
</ul>
<p>$$\begin{align}<br>f(\begin{bmatrix}a \ b \end{bmatrix}) &#x3D; \begin{bmatrix} 2a + b \ a -2b \  \end{bmatrix}<br>\end{align}$$</p>
<p>여기서 <code>[2a + b, a -2b ]</code>는 <code>[c,d]</code> 이며 특정 유닛벡터 (여기서는 <code>[2+b/a, a/b-2]</code>) 에 각각 a배, b배 한 값이 된다.</p>
<p><strong>여기서 <code>f</code>를 행렬을 곱하는 것으로 생각하면 놀랍게도 행렬과 벡터의 곱이 벡터의 선형변환과 동일하다는 것을 알 수 있다.</strong></p>
<h3 id="Eigenvalue-Eigenvector"><a href="#Eigenvalue-Eigenvector" class="headerlink" title="Eigenvalue,Eigenvector"></a><strong>Eigenvalue,Eigenvector</strong></h3><ul>
<li>일단 행렬이 선형변환이라는 것을 알아야 한다. <a href="https://angeloyeo.github.io/2019/07/15/Matrix_as_Linear_Transformation.html">진짜 설명 오지는 레퍼런스</a>를 읽어보자.</li>
<li>Eigenvector 는 특정 벡터에 대해 선형변환을 했을 때 크기만 바뀌고 방향은 바뀌지 않는 벡터(축)이다.(행렬의 방향성을 유지하는 선형변환의 주축)</li>
<li>Eigenvector 는 행렬이 벡터에 작용하는 주축이다.</li>
<li><strong>Eigenvector 는 어떤 행렬이 벡터에 작용하는 힘의 방향을 나타낸다.</strong><ul>
<li>만약 그 행렬이 공분산 행렬일 경우 그 공분산 행렬의 고유 벡터는 데이터가 어떤 방향으로 분산되어 있는지, 즉 어떤 방향으로 힘이 작용하는 지 나타낸다.-&gt; 공분산행렬의 Eigenvector가 원데이터의 분산이 최대가 되는 축이다.</li>
</ul>
</li>
<li><strong>Eigenvalue는 Eigenvector의 방향으로 크기가 얼마나 변화하는 지를 나타내는 값이다.</strong></li>
</ul>
<!--
$$ T \cdot v = v' = \lambda \cdot v $$



-->

<p>$$A &#x3D; cov(v)$$</p>
<p>$$Ax &#x3D; \lambda x$$</p>
<ul>
<li>A는 행렬 v의 공분산행렬이다.</li>
<li>여기서의 $\lambda$가 Eigenvalue이다.</li>
<li>x가 Eigenvector이다.</li>
</ul>
<p>x가 0이 아니여야 식이 성립하기 때문에 행렬식을 활용해 다음을 만족하는 벡터를 찾는다.</p>
<p>$$(A-\lambda I)\vec{x}&#x3D;0$$</p>
<p>$$det(A−\lambda I)&#x3D;0$$</p>
<p>$$\begin{bmatrix} a &amp; b \ c &amp; d \end{bmatrix}\begin{bmatrix} x \ y \end{bmatrix} &#x3D; \begin{bmatrix} ax+by \ cx+dy \end{bmatrix} &#x3D; \lambda \begin{bmatrix} x \ y \end{bmatrix}<br>$$</p>
<h3 id="주성분"><a href="#주성분" class="headerlink" title="주성분"></a><strong>주성분</strong></h3><p>결국 PCA에서 하고자 하는 것은 차원을 축소하면서 데이터 벡터를 <strong>어떤 벡터</strong>에 내적하는 것이 가능한 정보량(분산)을 유지하는 것인지 알아내는 것이다. 차원을 축소하면서 정보손실을 적게 하려면 원데이터의 분산이 최대가 되는 축을 찾아야 한다. 여기서 축이 되는 <strong>어떤 벡터</strong>가 주성분이며 공분산행렬의 eigenvector이다. </p>
<p><strong>linear combination</strong><br>주성분은 변수들의 선형 결합으로 표현된다. 이는 어떤 주성분 PC1이 있다고 했을때 이 PC1는 마치 다중회귀식마냥 기존 변수들의 조합으로 표현된다는 것이다.</p>
<p><img src="/PCA_lc.png"><br><strong>그림2. 선형결합으로서의 주성분</strong></p>
<h3 id="Feature-Selection-amp-Extraction"><a href="#Feature-Selection-amp-Extraction" class="headerlink" title="Feature Selection &amp; Extraction"></a><strong>Feature Selection &amp; Extraction</strong></h3><p>차원축소는 크게 변수선택과 변수추출로 나뉘며 PCA는 그 중 변수 추출에 속한다.</p>
<ul>
<li><strong>변수선택</strong><ul>
<li>덜 중요한 피처를 제거하는 방식으로 차원을 축소하는 방식</li>
<li>ex) <code>Lasso</code>,<code>Generic algorithm</code></li>
</ul>
</li>
<li><strong>변수추출</strong><ul>
<li>기존변수를 조합해서 새 변수를 만드는 방식</li>
<li>변수간 연관성을 고려할 수있다</li>
<li>해석이 어렵다.</li>
</ul>
</li>
</ul>
<p><img src="/FS_FE.png"><br><strong>그림3 변수선택과 변수추출의 직관적 이해</strong></p>
<h3 id="정리"><a href="#정리" class="headerlink" title="정리"></a><strong>정리</strong></h3><ul>
<li><p><strong>선형변환</strong></p>
<ul>
<li>행렬은 선형변환이다.</li>
<li>즉, 임의의 $\mathbb{R}^2$ 벡터를 다른 $\mathbb{R}^2$ 내부의 벡터로 변환 하는 과정은 특정 $M$라는 매트릭스를 곱하는 것과 같다.</li>
</ul>
</li>
<li><p><strong>공분산행렬</strong></p>
<ul>
<li>공분산은 교차곱편차의 평균이며 각 변수들이 얼마나 함께 변화하는 지를 나타낸다.</li>
<li>공분산을 표준화하면 상관계수이다. </li>
<li>공분산행렬은 각 feature들의 변동이 얼마나 유사한지를 나타낸다.</li>
<li>공분산행렬 자체는 단순히 정사각행렬의 대각성분을 각 변수의 분산으로 채우고 나머지를 공분산으로 채운 것이다.</li>
<li>공분산행렬의 서로다른 eigenvector 끼리는 직교한다.따라서 해당 eigenvector를 기저벡터로 하게끔 좌표축이 바뀐 데이터는 서로 상관이 없게 된다.</li>
</ul>
</li>
<li><p><strong>고윳값&#x2F;고유벡터</strong></p>
<ul>
<li>고윳값은 벡터의 크기이다</li>
<li>고유벡터는 특정 벡터에 선형변환을 했을 때 크기만 바뀌고 뱡향은 바뀌지않는 벡터이다. 기본적으로 방향이다.</li>
<li>공분산행렬의 고유벡터의 열벡터가 주성분이다.</li>
<li>고유값은 기존벡터에서 고유벡터로 정사영했을 때의 분산이다.따라서 고유벡터로 사영할 경우 분산이 최대가 된다.</li>
</ul>
</li>
<li><p><strong>주성분분석</strong></p>
<ul>
<li>주성분은 수치형 예측변수의 선형결합(linear combination)이다.</li>
<li>주성분은 공분산행렬의 eigenvector이다.</li>
<li>주성분은 서로간의 상관관계가 최소화 되어 중복성이 줄어들도록 한다 </li>
<li>차원의 수만큼 주성분이 존재하며 모든 차원의 주성분의 설명량은 1이다.</li>
<li>주성분의 일부만으로도 전체 분산의 대부분을 설명할 수 있다.</li>
<li>첫번째 주성분이 가장 큰 분산을 가지고 있고 두번째 주성분은 첫번째 주성분과 직교한다는 전제 하에 두번째로 큰 분산을 가지고 있다.</li>
<li>부하(loading)는 예측변수들을 주성분으로 변동할때 쓰이는 가중치이다. 계수이다.</li>
<li>Screeplot은 성분들의 변동을 나타낸다. 정확히는 성분의 수에 따른 분산의 변화량을 나타낸다. </li>
<li>다음의 두 가지 경우 PCA의 적용이 어렵다<ul>
<li>데이터의 분포가 정규성을 띄지 않는 경우 적용 어려움<ul>
<li>이 경우 커널 PCA 사용</li>
</ul>
</li>
<li>분류 &#x2F; 예측 문제에 대해서 데이터의 라벨을 고려하지 않기 때문에 효과적 분리가 어려움<ul>
<li>이 경우 PLS 사용</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="구현하기-R-Python"><a href="#구현하기-R-Python" class="headerlink" title="구현하기(R, Python)"></a>구현하기(R, Python)</h2><blockquote>
<p>사실 이해하는게 어렵지 다른 대부분의 분석들과 마찬가지로 구현 자체는 매우 쉽다.</p>
</blockquote>
<h3 id="Eigenvalue-Eigenvector-구하기"><a href="#Eigenvalue-Eigenvector-구하기" class="headerlink" title="Eigenvalue, Eigenvector 구하기"></a>Eigenvalue, Eigenvector 구하기</h3><ul>
<li>R을 활용한 Eigenvalue, Eigenvector 계산 <figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># eigen()을 사용해 매우 쉽게 구할 수 있다</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> M <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>data.frame<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">,</span><span class="number">0</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="operator">-</span><span class="number">2</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="operator">&gt;</span> M</span><br><span class="line">     c.1...1..0. c.1..2..1. c..2..1...1.</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>           <span class="number">1</span>          <span class="number">1</span>           <span class="operator">-</span><span class="number">2</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>          <span class="operator">-</span><span class="number">1</span>          <span class="number">2</span>            <span class="number">1</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>           <span class="number">0</span>          <span class="number">1</span>           <span class="operator">-</span><span class="number">1</span></span><br><span class="line"><span class="operator">&gt;</span> eigen<span class="punctuation">(</span>M<span class="punctuation">)</span></span><br><span class="line">eigen<span class="punctuation">(</span><span class="punctuation">)</span> decomposition</span><br><span class="line"><span class="operator">$</span>values</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>  <span class="number">2</span>  <span class="number">1</span> <span class="operator">-</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">$</span>vectors</span><br><span class="line">          <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span>       <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span>          <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.3015113</span> <span class="operator">-</span><span class="number">0.8017837</span>  <span class="number">7.071068e-01</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.9045340</span> <span class="operator">-</span><span class="number">0.5345225</span> <span class="operator">-</span><span class="number">1.922963e-16</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span> <span class="number">0.3015113</span> <span class="operator">-</span><span class="number">0.2672612</span>  <span class="number">7.071068e-01</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="공분산행렬-구하기"><a href="#공분산행렬-구하기" class="headerlink" title="공분산행렬 구하기"></a>공분산행렬 구하기</h3><ul>
<li>R을 활용한 Eigenvalue, Eigenvector 계산 <figure class="highlight r"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">- R을 활용한 Eigenvalue, Eigenvector 계산 </span><br><span class="line">```python</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="PCA구현하기"><a href="#PCA구현하기" class="headerlink" title="PCA구현하기"></a>PCA구현하기</h3><ul>
<li><p>R을 활용한 pca</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> data<span class="punctuation">[</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&#x27;a&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;b&#x27;</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">pca<span class="operator">&lt;-</span>princomp<span class="punctuation">(</span>df<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">pca<span class="operator">$</span>loadings <span class="comment"># 주성분 부하량 확인</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>python을 활용한 pca</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>) <span class="comment"># n_components로 주성분의 수를 지정할 수 있다.</span></span><br><span class="line">pca_values = pca.fit_transform(data_use) <span class="comment"># 설명량</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;누적설명량 &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">sum</span>(pca.explained_variance_ratio_)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;각 차원의 설명량 &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(pca.explained_variance_ratio_))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="PCA-시각화-관련-참고"><a href="#PCA-시각화-관련-참고" class="headerlink" title="PCA 시각화 관련 참고"></a>PCA 시각화 관련 참고</h3><ul>
<li>seaborn을 활용한 시각화<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># seaborn을 활용한 시각화</span></span><br><span class="line"></span><br><span class="line">sns.scatterplot(pca_v[<span class="number">0</span>],pca_v[<span class="number">1</span>],data=pca_v,hue = <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">style = <span class="string">&#x27;target&#x27;</span>,</span><br><span class="line">s = <span class="number">100</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>matplotlib을 활용한 시각화(1)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">df = px.data.iris()</span><br><span class="line">features = [<span class="string">&quot;sepal_width&quot;</span>, <span class="string">&quot;sepal_length&quot;</span>, <span class="string">&quot;petal_width&quot;</span>, <span class="string">&quot;petal_length&quot;</span>]</span><br><span class="line"></span><br><span class="line">pca = PCA()</span><br><span class="line">components = pca.fit_transform(df[features])</span><br><span class="line">labels = &#123;</span><br><span class="line">    <span class="built_in">str</span>(i): <span class="string">f&quot;PC <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> (<span class="subst">&#123;var:<span class="number">.1</span>f&#125;</span>%)&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i, var <span class="keyword">in</span> <span class="built_in">enumerate</span>(pca.explained_variance_ratio_ * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fig = px.scatter_matrix(</span><br><span class="line">    components,</span><br><span class="line">    labels=labels,</span><br><span class="line">    dimensions=<span class="built_in">range</span>(<span class="number">4</span>),</span><br><span class="line">    color=df[<span class="string">&quot;species&quot;</span>]</span><br><span class="line">)</span><br><span class="line">fig.update_traces(diagonal_visible=<span class="literal">False</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></li>
<li>matplotlib을 활용한 시각화(2)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig = plt.figure(figsize = (<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>) </span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Principal Component 1&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Principal Component 2&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">&#x27;2 component PCA&#x27;</span>, fontsize = <span class="number">20</span>)</span><br><span class="line">targets = [<span class="string">&#x27;Iris-setosa&#x27;</span>, <span class="string">&#x27;Iris-versicolor&#x27;</span>, <span class="string">&#x27;Iris-virginica&#x27;</span>]</span><br><span class="line">colors = [<span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> target, color <span class="keyword">in</span> <span class="built_in">zip</span>(targets,colors):</span><br><span class="line">    indicesToKeep = finalDf[<span class="string">&#x27;target&#x27;</span>] == target</span><br><span class="line">    ax.scatter(finalDf.loc[indicesToKeep, <span class="string">&#x27;principal component 1&#x27;</span>]</span><br><span class="line">               , finalDf.loc[indicesToKeep, <span class="string">&#x27;principal component 2&#x27;</span>]</span><br><span class="line">               , c = color</span><br><span class="line">               , s = <span class="number">50</span>)</span><br><span class="line">ax.legend(targets)</span><br><span class="line">ax.grid()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li>책<ul>
<li>Practical Statistics for Data Science</li>
</ul>
</li>
<li>블로그<ul>
<li><a href="https://wiserloner.tistory.com/1297">https://wiserloner.tistory.com/1297</a> # 고유값과 고유벡터</li>
<li><a href="https://huidea.tistory.com/126">https://huidea.tistory.com/126</a> #기술면접 참고</li>
<li><a href="https://rfriend.tistory.com/380">https://rfriend.tistory.com/380</a> #python 선형대수 함수</li>
<li><a href="https://rfriend.tistory.com/181">https://rfriend.tistory.com/181</a> #고유값과 고유벡터 구현</li>
<li><a href="https://youtu.be/jNwf-JUGWgg">https://youtu.be/jNwf-JUGWgg</a> # 공분산행렬의 이해</li>
<li><a href="https://ratsgo.github.io/linear%20algebra/2017/03/14/operations/">https://ratsgo.github.io/linear%20algebra/2017/03/14/operations/</a> # 행렬연산과 공분산행렬</li>
<li>시각화<ul>
<li><a href="https://plotly.com/python/pca-visualization/">https://plotly.com/python/pca-visualization/</a></li>
<li><a href="https://towardsdatascience.com/pca-using-python-scikit-learn-e653f8989e60">https://towardsdatascience.com/pca-using-python-scikit-learn-e653f8989e60</a></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>PCA</category>
      </categories>
      <tags>
        <tag>Unsupervised Learning</tag>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title>[Unsupervised Learning]KNN을 활용한 분류</title>
    <url>/2022/06/15/ML-US-knn/</url>
    <content><![CDATA[<!--

- ML
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<hr>
<h2 id="간단한-컨셉"><a href="#간단한-컨셉" class="headerlink" title="간단한 컨셉"></a>간단한 컨셉</h2><p><strong>KNN</strong></p>
<ul>
<li><p>새로운 데이터에 대해 기존 데이터 가운데 가장 가까운 K개 이웃의 정보로 새로운 데이터를 예측하는 방법론.</p>
</li>
<li><p>회귀문제와 분류문제 해결에 모두 사용되는 지도학습</p>
</li>
<li><p>하이퍼파라미터는 기본적으로 거리측정방법과 탐색할 이웃 수 2가지 이다.</p>
</li>
<li><p><strong>K(이웃)을 적게 사용하면 모델 복잡도가 높아지고 많이 사용하면 복잡도가 낮아진다(K의 수를 늘릴수록 결정경계가 부드러워진다.).</strong></p>
</li>
<li><p>KNN은 회귀분석에도 쓰이며 여러개의 K를 사용할 경우 이웃들의 종속변수의 평균이 예측된다.</p>
</li>
<li><p>거리측정방법</p>
<ul>
<li>유클리디안 거리 : 데이터포인트 사이 직선 최단거리</li>
<li>마할라노비스 거리 : 공분산을 고려해 거리를 계산한다. 변수간 상관관계를 고려한 거리지표.</li>
<li>맨해튼 거리 : 각 좌표축 방향으로만 이동할 경우 계산된다. 격자모양의 길을 따라간다.</li>
</ul>
</li>
<li><p>주의점</p>
<ul>
<li>기본적으로 거리기반이기 때문에 KNN을 돌리기 전 반드시 변수를 정규화 해야 한다.</li>
<li>불균형 데이터의 분류문제를 풀 경우 학습데이터 범주의 사전확률(Prior Probability)를 고려해야핟다.</li>
</ul>
</li>
<li><p>장단점</p>
<ul>
<li>장점 : 학습 데이터 내 노이즈의 영향들 덜받음. 학습데이터가 많으면 효과적 </li>
<li>단점 : 어떤 거리척도가 분석에 적랍한지 불분명. 계산시간이 오래 걸림</li>
</ul>
</li>
</ul>
<h2 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h2><ul>
<li>유클라디안 거리를 활용한 KNN 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euclidean_distance</span>(<span class="params">x1,x2</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(np.<span class="built_in">sum</span>((x1-x2)**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KNN</span>:</span><br><span class="line"></span><br><span class="line">    self __init__(self, k=<span class="number">3</span>):</span><br><span class="line">        self.k = k </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, y</span>): <span class="comment"># triain sample and label</span></span><br><span class="line">        self.X_train = X</span><br><span class="line">        self.y_train = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        predicted_labels = [self._predict(x) <span class="keyword">for</span> x <span class="keyword">in</span> X]</span><br><span class="line">        <span class="keyword">return</span> np.array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_predict</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        1. 거리 계산하기</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        2. k nearest sample</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        3. majority vote, get most common class</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        distances = [euclidean_distance(x,x_train) <span class="keyword">for</span> x_train <span class="keyword">in</span> X_train]</span><br><span class="line"></span><br><span class="line">        k_indices = np.argsort(distances)[:self.k]</span><br><span class="line">        k_nearest_labels = [self.y_train[i] <span class="keyword">for</span> i <span class="keyword">in</span> k_indices]</span><br><span class="line"></span><br><span class="line">        most_common = Counter(k_nearest_labels).most_common(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> most_common[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="분류문제-풀이"><a href="#분류문제-풀이" class="headerlink" title="분류문제 풀이"></a>분류문제 풀이</h2><ul>
<li>iris 데이터를 바탕으로 분류문제 풀이</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">cmap = ListedColormap([<span class="string">&quot;#FF0000&quot;</span>, <span class="string">&quot;#00FF00&quot;</span>, <span class="string">&quot;#0000FF&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">y_true, y_pred</span>):</span><br><span class="line">    accuracy = np.<span class="built_in">sum</span>(y_true == y_pred) / <span class="built_in">len</span>(y_true)</span><br><span class="line">    <span class="keyword">return</span> accuracy</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(</span><br><span class="line">        X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1234</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">k = <span class="number">3</span></span><br><span class="line">clf = KNN(k=k)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">predictions = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;KNN classification 정확도&quot;</span>, accuracy(y_test, predictions))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$KNN</span> classification accuracy 1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>sklearn에서도 knn 분류기가 구현되어 있다.<ul>
<li>irsis data load까지는 동일하게 진행된다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeiborsClassifier</span><br><span class="line"></span><br><span class="line">clf = KNeiborsClassifier(n_neighbors =<span class="number">3</span>)</span><br><span class="line">clf.fit()</span><br><span class="line"></span><br><span class="line">pred = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;KNN classification 정확도&quot;</span>, clf.score(X_test,y_test))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="K값과-모델-복잡도의-관계"><a href="#K값과-모델-복잡도의-관계" class="headerlink" title="K값과 모델 복잡도의 관계"></a>K값과 모델 복잡도의 관계</h2><ul>
<li>위스콘신 유방암데이터로 구현한다.</li>
<li>k의 수가 1개일 때는(적을 때는) train 데이터에 대해서만 예측력이 높고 test에서는 낮은 과적합된 모습을 보인다.</li>
<li>k의 수가 많을 수록 모델이 단순해지고 train 데이터의 정확도는 줄어든다.</li>
<li>k의 수가 10개일 때는 모델이 너무 단순해 train과 test모두에서 예측력이 낮은 모습을 보인다.</li>
<li>중간정도의 범위에서 k의 수를 선정할 필요가 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X_train , X_test , y_train , y_test = train_test_split(cancer.data,</span><br><span class="line">                                                       cancer.target,</span><br><span class="line">                                                       stratify = cancer.target, <span class="comment"># stratify 값을 target으로 지정해주면 각각의 class 비율(ratio)을 train / validation에 유지해준다. (한 쪽에 쏠려서 분배되는 것을 방지)</span></span><br><span class="line">                                                       random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">train_acc = []</span><br><span class="line">test_acc = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">k_indices = <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_indices:</span><br><span class="line">    clf = KNeiborsClassifier(n_neighbors=k)</span><br><span class="line">    clf.fit()</span><br><span class="line">    train_acc.append(clf.score(X_train,y_train))</span><br><span class="line">    test_acc.append(clf.score(X_test,y_test))</span><br><span class="line"></span><br><span class="line">plt.plot(neighbors_settings, training_accuracy, label=<span class="string">&quot;훈련 정확도&quot;</span>)</span><br><span class="line">plt.plot(neighbors_settings, test_accuracy, label=<span class="string">&quot;테스트 정확도&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;정확도&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;n_neighbors&quot;</span>)</span><br><span class="line">plt.legend(</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="https://tensorflowkorea.files.wordpress.com/2017/06/2-7.png?w=1024"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://docs.python.org/3/library/collections.html">https://docs.python.org/3/library/collections.html</a></li>
<li><a href="https://tensorflow.blog/%EA%B0%9C%EC%A0%95%ED%8C%90-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D/">파이싼 라이브러리를 활용한 머신러닝</a></li>
<li><a href="https://ratsgo.github.io/machine%20learning/2017/04/17/KNN/">https://ratsgo.github.io/machine%20learning/2017/04/17/KNN/</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Unsupervised Learning</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>[XAI]PDP Plot의 이해와 구현</title>
    <url>/2022/06/15/ML-XAI-PDP/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning

- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="PDP-plot"><a href="#PDP-plot" class="headerlink" title="PDP plot"></a>PDP plot</h2><hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li><strong>ICE(Indivisual Conditional Expectation)</strong> :하나의 관측치에 대해 특정 feature의 값을 변화시킬 때 모델의 예측.</li>
<li><strong>marginal effect</strong> :독립변수의 변화예 따른 종속변수의 변화</li>
<li><strong>Partial Dependence Plot</strong> : 1개나 2개의 특성의 변화(상호작용)에 따른 모델 예측의 변화를 그린 것.</li>
</ul>
<hr>
<blockquote>
<p>The partial dependence plot (short PDP or PD plot) shows the marginal effect one or two features have on the predicted outcome of a machine learning model (J. H. Friedman 200130). A partial dependence plot can show whether the relationship between the target and a feature is linear, monotonic or more complex. </p>
</blockquote>
<ul>
<li>feature가 모델에 미치는 긍정적&#x2F;부정적 영향 확인</li>
<li>특정 feture에 대해 여유분(buffer)을 함께 표시 -&gt; feature간 독립을 보장하지 못하는 환경에서 모델에 어느정도 있을 수 있는 지를 확인할 수 있게끔 함</li>
</ul>
<h3 id="기본적인-컨셉에-대한-이해"><a href="#기본적인-컨셉에-대한-이해" class="headerlink" title="기본적인 컨셉에 대한 이해"></a>기본적인 컨셉에 대한 이해</h3><p>$$\hat{f}<em>S(x_S)&#x3D;E</em>{X_C}\left[\hat{f}(x_S,X_C)\right]&#x3D;\int\hat{f}(x_S,X_C)d\mathbb{P}(X_C)$$</p>
<p>$$\hat{f}<em>S(x_S)&#x3D;\frac{1}{n}\sum</em>{i&#x3D;1}^n\hat{f}(x_S,x^{(i)}_{C})$$</p>
<ul>
<li>$X_S$는 분석하고자 하는 feature이다.</li>
<li>$X_C$는 분석하고자 하는 feauture 외의 모델의 feauture들이다.</li>
<li>여기서 $f(x_{S}, x_{C}^{(i)})$ 가 하나의 ICE 곡선을 나타낸다.</li>
<li>Partial Dependence는 단순히 $X_C$를 를 고정시킨 상태에서 $X_S$를 변화시키며 모델의 예측값을 계산 후 그 값을 평균한 것이다.</li>
<li><strong>target과 관련이 있는 특성에 대한 Global한 설명이 필요할 때 사용한다.</strong></li>
</ul>
<h3 id="ICE-Indivisual-Conditional-Expectation"><a href="#ICE-Indivisual-Conditional-Expectation" class="headerlink" title="ICE(Indivisual Conditional Expectation)"></a>ICE(Indivisual Conditional Expectation)</h3><ul>
<li><p>ICE 곡선은 하나의 관측치에 대해 관심 특성을 변화시킴에 따른 타겟값 변화 곡선. </p>
</li>
<li><p>PDP는 기본적으로 여러 ICE곡선의 평균이다.</p>
</li>
<li><p><code>frac_to_plot</code> : 라인 수 조정 파라미터. 라인 수 혹은 비율</p>
</li>
<li><p><strong>ICE와 PDF에 대한 직관적 이해</strong> : <a href="https://twitter.com/i/status/1066398522608635904">https://twitter.com/i/status/1066398522608635904</a></p>
</li>
<li><p>부분 의존성 계산 및 PDP plot 그리기</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ice = pdp.pdp_isolate(</span><br><span class="line">      model = clf,</span><br><span class="line">      dataset = df,</span><br><span class="line">      model_features=features</span><br><span class="line">      feature = <span class="string">&quot;feature_1&quot;</span> <span class="comment"># 분석하고자 하는 feature</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># PDP plot</span></span><br><span class="line"></span><br><span class="line">fig, axes = pdp.pdp_plot(</span><br><span class="line">            ice,</span><br><span class="line">            <span class="string">&quot;feature_1&quot;</span>,</span><br><span class="line">            plot_line = <span class="literal">False</span>,</span><br><span class="line">            frac_to_plot = <span class="number">0.5</span>,</span><br><span class="line">            plot_pts_dist = <span class="literal">True</span></span><br><span class="line">                         )</span><br></pre></td></tr></table></figure>



<h3 id="PDP-interaction"><a href="#PDP-interaction" class="headerlink" title="PDP interaction"></a>PDP interaction</h3><ul>
<li><p>두 특성간 상호작용 확인</p>
</li>
<li><p>등고선 그래프를 그렸을 때 특정 축에 평행할 경우 다른 축의 값에 상관없이 </p>
<ul>
<li>X축에 평행할 경우 모델의 예측 X축의 변수에 보다 의존적.</li>
<li>Y축의 변수의 값에 상관없이 X축의 값에 따라 모델 예측이 결정됨</li>
</ul>
</li>
<li><p>해석하기에는 Grid로 그래프를 그리는 것이 더 나을 수 있다. </p>
</li>
<li><p>skearn으로 구현한 등고선 그래프<br><img src="https://scikit-learn.org/stable/_images/sphx_glr_plot_partial_dependence_003.png" alt="ICE"></p>
</li>
<li><p>pdp plot 패키지로 구현한 상호작용</p>
<ul>
<li>모델이 없이 두 feature의 상호작용에 따른 target의 값을 보여준다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pdpbox <span class="keyword">import</span> info_plots, get_dataset</span><br><span class="line"></span><br><span class="line">test_titanic = get_dataset.titanic()</span><br><span class="line">titanic_data = test_titanic[<span class="string">&#x27;data&#x27;</span>]</span><br><span class="line">titanic_target = test_titanic[<span class="string">&#x27;target&#x27;</span>]</span><br><span class="line"></span><br><span class="line">fig, axes, summary_df = info_plots.target_plot_interact(</span><br><span class="line">    df=titanic_data, features=[<span class="string">&#x27;Sex&#x27;</span>, [<span class="string">&#x27;Embarked_C&#x27;</span>, <span class="string">&#x27;Embarked_Q&#x27;</span>, <span class="string">&#x27;Embarked_S&#x27;</span>]],</span><br><span class="line">    feature_names=[<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Embarked&#x27;</span>], target=titanic_target)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="PDP-plot에서-범주형-변수-Decoding하기"><a href="#PDP-plot에서-범주형-변수-Decoding하기" class="headerlink" title="PDP plot에서 범주형 변수 Decoding하기"></a>PDP plot에서 범주형 변수 Decoding하기</h3><ul>
<li>범주형 변수는 Ordinal Encoder나 target Encoder로 인코딩 한 후 사용된다.</li>
<li>인코딩을 하게되면 학습 후 PDP 를 그릴 때 인코딩된 값이 나오게 되어 카테고리특성의 실제 값을 확인하기 어려운 문제가 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> make_pipeline</span><br><span class="line"></span><br><span class="line">df = sns.load_dataset(<span class="string">&#x27;titanic&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;age&#x27;</span>] = df[<span class="string">&#x27;age&#x27;</span>].fillna(df[<span class="string">&#x27;age&#x27;</span>].median())</span><br><span class="line">df = df.drop(columns=<span class="string">&#x27;deck&#x27;</span>) <span class="comment"># NaN 77%</span></span><br><span class="line">df = df.dropna()</span><br><span class="line"></span><br><span class="line">target = <span class="string">&#x27;survived&#x27;</span></span><br><span class="line">features = df.columns.drop([<span class="string">&#x27;survived&#x27;</span>, <span class="string">&#x27;alive&#x27;</span>])</span><br><span class="line"></span><br><span class="line">X = df[features]</span><br><span class="line">y = df[target]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 파이프라인 생성 및 학습</span></span><br><span class="line">pipe = make_pipeline(</span><br><span class="line">    OrdinalEncoder(), </span><br><span class="line">    RandomForestClassifier(n_estimators=<span class="number">100</span>, random_state=<span class="number">42</span>, n_jobs=-<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line">pipe.fit(X, y);</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">encoder = pipe.named_steps[<span class="string">&#x27;ordinalencoder&#x27;</span>]</span><br><span class="line">X_encoded = encoder.fit_transform(X)</span><br><span class="line">rf = pipe.named_steps[<span class="string">&#x27;randomforestclassifier&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>범주형 변수에 대한 ice plot</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pdpbox <span class="keyword">import</span> pdp</span><br><span class="line">feature = <span class="string">&#x27;sex&#x27;</span></span><br><span class="line">pdp_dist = pdp.pdp_isolate(model=rf, dataset=X_encoded, model_features=features, feature=feature)</span><br><span class="line">pdp.pdp_plot(pdp_dist, feature); <span class="comment"># 인코딩된 sex 값을 확인할 수 있습니다</span></span><br></pre></td></tr></table></figure>

<ul>
<li>자동으로 PDP 카테고리 매핑</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 이번에는 PDP 카테고리값 맵핑을 자동으로 해보겠습니다</span></span><br><span class="line"></span><br><span class="line">feature = <span class="string">&#x27;sex&#x27;</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> encoder.mapping:</span><br><span class="line">    <span class="keyword">if</span> item[<span class="string">&#x27;col&#x27;</span>] == feature:</span><br><span class="line">        feature_mapping = item[<span class="string">&#x27;mapping&#x27;</span>] <span class="comment"># Series</span></span><br><span class="line">        </span><br><span class="line">feature_mapping = feature_mapping[feature_mapping.index.dropna()]</span><br><span class="line">category_names = feature_mapping.index.tolist()</span><br><span class="line">category_codes = feature_mapping.values.tolist()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pdp.pdp_plot(pdp_dist, feature)</span><br><span class="line"></span><br><span class="line"><span class="comment"># xticks labels 설정을 위한 리스트를 직접 넣지 않아도 됩니다 </span></span><br><span class="line">plt.xticks(category_codes, category_names);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>PDP 상호작용</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2D PDP 를 Seaborn Heatmap으로 그리기 위해 데이터프레임으로 만듭니다</span></span><br><span class="line">pdp = interaction.pdp.pivot_table(</span><br><span class="line">    values=<span class="string">&#x27;preds&#x27;</span>, </span><br><span class="line">    columns=features[<span class="number">0</span>], </span><br><span class="line">    index=features[<span class="number">1</span>]</span><br><span class="line">)[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">pdp = pdp.rename(columns=<span class="built_in">dict</span>(<span class="built_in">zip</span>(category_codes, category_names)))</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">5</span>))</span><br><span class="line">sns.heatmap(pdp, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.2f&#x27;</span>, cmap=<span class="string">&#x27;viridis&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;PDP decoded categorical&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><strong>References &amp; annotation</strong></p>
<ul>
<li><a href="https://pdpbox.readthedocs.io/en/latest/index.html">https://pdpbox.readthedocs.io/en/latest/index.html</a></li>
<li><a href="https://christophm.github.io/interpretable-ml-book/pdp.html">https://christophm.github.io/interpretable-ml-book/pdp.html</a></li>
<li><a href="https://scikit-learn.org/stable/modules/partial_dependence.html">https://scikit-learn.org/stable/modules/partial_dependence.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>XAI</tag>
      </tags>
  </entry>
  <entry>
    <title>[XAI]Shap을 활용한 모델해석</title>
    <url>/2022/06/15/ML-XAI-shap/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>굵은 글씨로 뭔가 쓴다.</strong></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>XAI</tag>
      </tags>
  </entry>
  <entry>
    <title>[NLP]NLU &amp; QA task</title>
    <url>/2022/06/15/NLP-NLU/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h1 id="NLU"><a href="#NLU" class="headerlink" title="NLU"></a>NLU</h1><blockquote>
<p>NLP의 하위 분야인 NLU를 소개하고 NLU 의 subtask 중 하나인 QA(Question Answering) 에 대해 정리</p>
</blockquote>
<p>: Natural Language Understanding<br>기계가 자연어에 대한 Synthetic과 Semantic Understanding을 보인다면 그 기계는 NLU를 수행하고 있다고 볼 수 있다.</p>
<h2 id="Question-Answering-task"><a href="#Question-Answering-task" class="headerlink" title="Question Answering(task)"></a>Question Answering(task)</h2><p>특정 자연어 텍스트를 기계가 올바르게 이해하고 답변하는지 평가하는 Reading Comprehension의 일종이다.</p>
<p>질문에 대해 기계가 답변하는 QA의 형태를 가지고 있다는 점에서 NLU task라고 볼 수 있다.</p>
<p>QA task의 경우 질문에 대한 답이 Input인 지문안에 분명히 존재하기 때문에 평가지표로 Accuracy와 F1 Score를 사용할 수 있다.</p>
<h4 id="대표적인-데이터셋"><a href="#대표적인-데이터셋" class="headerlink" title="대표적인 데이터셋"></a>대표적인 데이터셋</h4><h4 id="SQuAD"><a href="#SQuAD" class="headerlink" title="SQuAD"></a>SQuAD</h4><p>: Stanford Question Answering Dataset</p>
<p>QA와 같은 Reading Comprehension 문제의 해결을 위해 스탠포스에서 개발한 대표 Benchmark.</p>
<p>Input은 지문인 Context와 지문 내에서 답을 찾을 수 있는 Question으로 구성된다.</p>
<p>SQuAD 데이터 셋을 통해 QA task를 수행할 경우 기계는 출력값으로 지문(Context) 내에 포함된 질문의 답의 시작과 끝의 인덱스를 반환해야 한다,</p>
<ul>
<li>ex) SQuAD의 예시</li>
</ul>
<p><img src="https://www.researchgate.net/publication/326569892/figure/fig1/AS:651759777234944@1532403048781/An-example-from-SQuAD-dataset.png"></p>
<h3 id="SOTA-models-for-QA-task"><a href="#SOTA-models-for-QA-task" class="headerlink" title="SOTA models for QA task"></a>SOTA models for QA task</h3><h4 id="T5-Text-to-Text-Transfer"><a href="#T5-Text-to-Text-Transfer" class="headerlink" title="T5 (Text to Text Transfer)"></a>T5 (Text to Text Transfer)</h4><p>T5는 전이학습을 기반으로한 구글에서 개발한 Transformer 기반 Language Model이다.</p>
<p>현 시점에서 QA task에서 가장 높은 성능을 보이는 SOTA 모델의 하나이다.</p>
<p><img src="https://media.vlpt.us/images/yjinheon/post/2b661472-0508-4446-b808-95b7d2a5b4d2/Velog_1_12.png"></p>
<h4 id="전이학습-Transfer-Learning"><a href="#전이학습-Transfer-Learning" class="headerlink" title="전이학습(Transfer Learning)"></a>전이학습(Transfer Learning)</h4><ul>
<li>전이학습은 이미 학습된 큰 데이터셋의 가중치를 가지고 와서 해결하고자 하는 다른 과제에 맞게 튜닝해서 사용하는 방법론이다.</li>
<li>T5 paper에서는 하나의 언어모델을 비지도로 pre-train한 뒤 세부 task에 따라 지도학습으로 fine tuning하는 방식을 사용하였다.</li>
</ul>
<h4 id="XLNet-Generalized-Autoregressive-Pretraining-for-Language-Understanding"><a href="#XLNet-Generalized-Autoregressive-Pretraining-for-Language-Understanding" class="headerlink" title="XLNet: Generalized Autoregressive Pretraining for Language Understanding"></a>XLNet: Generalized Autoregressive Pretraining for Language Understanding</h4><p>BERT의 Autoencoding method에 Autoregressive기법을 더해 성능을 개선시킨 언어모델.</p>
<h4 id="Autoregressive-Pretrained-method"><a href="#Autoregressive-Pretrained-method" class="headerlink" title="Autoregressive Pretrained method"></a>Autoregressive Pretrained method</h4><ul>
<li>AR(자기회귀) 방법론은 기존 BERT가 가지고 있는 masking을 보완하기 위해 사용되었다.</li>
<li>AR은 BERT가 가지고 있는 문제점을 보완할 수 있지만 알고리즘 특성상 단방향 만을 고려한다는 문제점이 있다.</li>
<li>BERT의 경우 AutoEncoding 과정에서 토큰이 독립적으로 예측되기 때문에 토큰 간 Dependency가 학습이 안되는 문제점이 있었다.</li>
<li>XLNet에서는 permutation을 이용해 모든 가능한 sequence를 고려해서 (Factorization Order) AR 방법론을 적용하여 AR과 AutoEncoding 방법론을 모두 보완해 성능을 개선시켰다.</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://rajpurkar.github.io/SQuAD-explorer/">https://rajpurkar.github.io/SQuAD-explorer/</a></li>
<li><a href="https://arxiv.org/pdf/1910.10683v3.pdf">Text to Text Transfer</a></li>
<li><a href="https://arxiv.org/pdf/1906.08237v2.pdf">XLNet: Generalized Autoregressive Pretraining<br>for Language Understanding</a></li>
<li><a href="https://qa.fastforwardlabs.com/no%20answer/null%20threshold/bert/distilbert/exact%20match/f1/robust%20predictions/2020/06/09/Evaluating_BERT_on_SQuAD.html#Metrics-for-QA">QA task의 평가지표</a></li>
<li><a href="https://yhdosu.github.io/2019/11/12/T5.html">T5 paper설명</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>NLU</tag>
        <tag>QA</tag>
      </tags>
  </entry>
  <entry>
    <title>[NLP]Word Embedding과 Text Classification</title>
    <url>/2022/03/02/NLP-wordembedding/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h1 id="NLP-subtask에-대한-정리"><a href="#NLP-subtask에-대한-정리" class="headerlink" title="NLP subtask에 대한 정리"></a>NLP subtask에 대한 정리</h1><p>: 주요 NLP task인 Word Embedding과 Text Classfication에 대해 간단히 정리</p>
<h2 id="1-Word-Embedding"><a href="#1-Word-Embedding" class="headerlink" title="1.Word Embedding"></a>1.Word Embedding</h2><h3 id="1-1-Word-Embedding에서-고려하는-task"><a href="#1-1-Word-Embedding에서-고려하는-task" class="headerlink" title="1.1 Word Embedding에서 고려하는 task"></a>1.1 Word Embedding에서 고려하는 task</h3><p>Word Embedding은 단어를 저차원의 실수벡터로 dense mapping하는 word representation 방식의 하나이다.</p>
<p>Embedding 자체는 토큰을 고정된 길이의 벡터로 표현하는 것을 뜻한다.</p>
<p><strong>단어의 구문(Syntax)와 의미(Semantics)를 실수벡터의 형태로 표현하는 것이 그 목적이다.</strong></p>
<p><img src="https://miro.medium.com/max/1050/1*lzjgo2KaWFRPkV3LCJDr7Q.png"></p>
<h4 id="1-1-1-차원의-저주"><a href="#1-1-1-차원의-저주" class="headerlink" title="1.1.1 차원의 저주"></a>1.1.1 차원의 저주</h4><p>단어를 실수벡터의 형태로 dense mapping하는 이유는 차원의 저주를 피하기 위함이다.</p>
<p>문서의 모든 단어를 One Hot encoding으로 표현할 경우 feature가 기하급수적으로 많아진 희소행렬이 생성되고 이 경우 연산비용이 증가하는 문제점이 발생한다.</p>
<p>이를 피하기 위해 Word Embedding을 통해 단어를 저차원 벡터에 고정시켜 나타내게 된다.</p>
<h4 id="1-1-2-Distribution-Hypothesis"><a href="#1-1-2-Distribution-Hypothesis" class="headerlink" title="1.1.2 Distribution Hypothesis"></a>1.1.2 Distribution Hypothesis</h4><p>Distribution Hypothesis는 비슷한 위치에서 등장하는 단어들은 비슷한 의미를 가진다는 가설이다.</p>
<p>Word embedding은 이 분포 가설에 기반하여 주변 단어 분포를 기준으로 타겟이 되는 단어의 벡터 표현을 결정한다. </p>
<p>따라서 Word Embedding을 통해 생성된 두 단어 벡터의 거리가 가까울 수록 원문에서 두 단어가 유사한 의미와 용법을 가졌다고 볼 수 있다.</p>
<h4 id="1-1-3-Predictive-Method"><a href="#1-1-3-Predictive-Method" class="headerlink" title="1.1.3 Predictive Method"></a>1.1.3 Predictive Method</h4><p>Word Embedding은 기본적으로 단어의 예측을 학습하는 것으로 이루어진다.</p>
<h3 id="1-2-대표적인-데이터셋"><a href="#1-2-대표적인-데이터셋" class="headerlink" title="1.2 대표적인 데이터셋"></a>1.2 대표적인 데이터셋</h3><h4 id="Words-in-Context"><a href="#Words-in-Context" class="headerlink" title="Words in Context"></a>Words in Context</h4><p>Word in Context는 문맥에 따른 단어의 용법을 모아놓은 데이터 셋이다.</p>
<p>과거의 Word Embedding 기법들이 문맥에 따라 달라지는 단어의 의미를 구분하지 못한다는 문제점을 보완하기 위해 만들어졌다.</p>
<p>Word in Context을 통해 문맥정보를 학습한 임베딩을 생성할 수 있다.</p>
<p>데이터셋은 타겟단어 , 타겟이 되는 타겟단어의 Context 문장 2개와 해당 문장이 문맥상 같은 의미로 쓰여졌는지에 대한 label로 구성되어 있다.</p>
<p><img src="https://images.velog.io/images/yjinheon/post/b44f7201-b8ac-4c98-9646-510f7b2ef6a3/Velog_1_10.png"></p>
<h3 id="Contextual-Embedding-SOTA-Technique"><a href="#Contextual-Embedding-SOTA-Technique" class="headerlink" title="Contextual Embedding(SOTA Technique)"></a>Contextual Embedding(SOTA Technique)</h3><p>Word Embedding은 기본적으로 모델링이 아니라 NLP task의 input을 만드는 작업이기 때문에  BERT, ELMO, GPT-1와 같은 SOTA 모델에서 사용하는 Embedding 방식인 Contextual Embedding에 대해 기술하고자 한다.</p>
<p>과거의 Word Embedding 대표적인 문제점은 하나의 단어당 하나의 벡터 값 만이 매핑된다는 것이다. 따라서 단어의 문맥에 따라 달라지는 의미를 고려하기 어려워지고 성능에 부적인 영향을 주게 된다.</p>
<p>이러한 문제점을 보완하기 위해 Deep contextualized word representations(ELMO)에서 Contextual Embedding이 제시되었다.</p>
<h4 id="biLM-bidirectional-Language-Model-as-function"><a href="#biLM-bidirectional-Language-Model-as-function" class="headerlink" title="biLM(bidirectional Language Model) as function"></a>biLM(bidirectional Language Model) as function</h4><p>Contextual Embedding과 기존 임베딩의 차이점은 각 단어마다 고정된 크기의 벡터를 사용한 것이 아니라 pretrained model 자체를 일종의 함수으로 기능하게끔 하여 문맥정보를 학습에 반영한다는 것이다.</p>
<p>ELMo(Embedding from Language Model)는 여기서 단순한 Language Model이 아니라 일종의 함수이며 문장에 따라 같은 단어라도 다른 임베딩(단어 벡터)을 출력할 수 있다.</p>
<p>여기서 biLM은 단순히 forword LSTM(앞의 단어들로 뒤에 나올 단어를 예측)과 backword LSTM(뒤의 단어들로 앞의 단어를 예픅)을 합친 양방향 모델을 말하며 ELmo의 학습에 사용된다.</p>
<h2 id="Text-Classification"><a href="#Text-Classification" class="headerlink" title="Text Classification"></a>Text Classification</h2><h3 id="Text-Classification의-주요-task"><a href="#Text-Classification의-주요-task" class="headerlink" title="Text Classification의 주요 task"></a>Text Classification의 주요 task</h3><p>Text Classification은 문서의 내용을 바탕으로 특징을 추출해서 특정한 카테고리에 분류하는 것을 그 목적으로 한다.</p>
<h3 id="대표적인-데이터셋"><a href="#대표적인-데이터셋" class="headerlink" title="대표적인 데이터셋"></a>대표적인 데이터셋</h3><h4 id="IMDB-Movie-Review"><a href="#IMDB-Movie-Review" class="headerlink" title="IMDB Movie Review"></a>IMDB Movie Review</h4><p>IMDB에 게시된 영화 리뷰와 Positive&#x2F;Negative label로 구성된 데이터셋이며 주로 감성분석과 추천시스템 구현에 사용된다.</p>
<h3 id="BERT-SOTA-Technique"><a href="#BERT-SOTA-Technique" class="headerlink" title="BERT(SOTA Technique)"></a>BERT(SOTA Technique)</h3><p>BERT는 구글에서 개발한 신경망 구조이며 Text Classification 뿐 만 아니라 질의응답, 기계번역 , 문서요약과 같은 다양한 task에 적용할 수 있는 대표적인 SOTA Model이다.</p>
<h4 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h4><ul>
<li>Transformer는 Encoder Decoder 구조를 가지는 딥러닝 모델이다.</li>
<li>기본적으로 여러개의 Encoder Decoder Layer가 존재하기 때문에 순차적으로 단어정보를 입력받지 않아 연산에서의 부담이 상대적으로 적은 편이다.</li>
<li>Encoder 내부에서는 self attention 기법으로 한 문장에서 한 단어가 다른 단어와 어떤 관계를 갖고 있는지 수치화한다.</li>
<li>문장의 Context를 학습하기 위해 Positional Encoding이라는 특수한 Input을 사용한다.<ul>
<li>Positional Encoding 을 통해 input으로 주어지는 단어의 vector안에 단어의 위치정보를 포함시킬 수 있다.</li>
</ul>
</li>
<li>BERT(Bidirectional Encoder Representations from Transformers)는 양방향 입력을 받는 Encoder를 여러개 쌓아올린 구조로 이루어져 있다.</li>
</ul>
<p>BERT에서는 일부 단어를 마스킹하고 해당 단어를 예측하거나(Masked L). 문장단위로 예측을 수행하는 기법(Next Sentence Prediction)</p>
<p>단어 토큰을 보다 세분화하는 WordPiece 기법을 사용한다.</p>
<h4 id="fine-tuning"><a href="#fine-tuning" class="headerlink" title="fine tuning"></a>fine tuning</h4><p>Transformer와 함께 BERT의 핵심 컨셉중 하나로 <em>기존의 학습된 모델을 기반으로 레이어를 새로운 task에 맞게 변형하고 이미 학습된 모델가중치를 업데이트하거나 모델의 파라미터를 재조정하는 것</em>을 뜻한다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://machinelearningmastery.com/what-are-word-embeddings/">https://machinelearningmastery.com/what-are-word-embeddings/</a></li>
<li><a href="https://pilehvar.github.io/wic/">https://pilehvar.github.io/wic/</a></li>
<li><a href="https://arxiv.org/pdf/1808.09121v3.pdf">WiC: the Word-in-Context Dataset</a></li>
<li><a href="https://arxiv.org/pdf/1802.05365.pdf">Deep contextualized word representations</a></li>
<li><a href="https://paperswithcode.com/method/elmo">https://paperswithcode.com/method/elmo</a></li>
<li><a href="https://skyjwoo.tistory.com/entry/positional-encoding%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">Positional Encoding의 이해</a></li>
</ul>
]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>NLP</tag>
        <tag>Deep Learning</tag>
        <tag>WordEmbedding</tag>
      </tags>
  </entry>
  <entry>
    <title>[Data Transformation]Feature Scaling의 이해</title>
    <url>/2022/06/15/Preprocessing-dt-Scaler/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="Feature-Scaling"><a href="#Feature-Scaling" class="headerlink" title="Feature Scaling"></a>Feature Scaling</h2><!--

진짜 렉카

standar

- https://datascience.stackexchange.com/questions/45900/when-to-use-standard-scaler-and-when-normalizer

조건수의 의미
- https://datascienceschool.net/03%20machine%20learning/04.03%20%EC%8A%A4%EC%BC%80%EC%9D%BC%EB%A7%81.html


조건수가 크면 약간의 오차만 있어도 해가 전혀 다른 값을 가진다. 따라서 조건수가 크면 회귀분석을 사용한 예측값도 오차가 커지게 된다.

회귀분석에서 조건수가 커지는 경우는 크게 두 가지가 있다.

1) 변수들의 단위 차이로 인해 숫자의 스케일이 크게 달라지는 경우. 이 경우에는 스케일링(scaling)으로 해결한다.

2) 다중 공선성 즉, 상관관계가 큰 독립 변수들이 있는 경우, 이 경우에는 변수 선택이나 PCA를 사용한 차원 축소 등으로 해결한다.


다음의 경우

- 데이터가 편포된 경우
- 독립변수와 예측치가 비선형인 경우



https://deepinsight.tistory.com/113

-->

<h3 id="Feature-Scaling에서-overflow와-underflow의-의미"><a href="#Feature-Scaling에서-overflow와-underflow의-의미" class="headerlink" title="Feature Scaling에서 overflow와 underflow의 의미"></a>Feature Scaling에서 overflow와 underflow의 의미</h3><p><strong>no blog</strong></p>
<p>A common pre-processing step is to normalize&#x2F;rescale inputs so that they are not too high or low.</p>
<p>However, even on normalized inputs, overflows and underflows can occur:</p>
<p>Underflow: Joint probability distribution often involves multiplying small individual probabilities. Many probabilistic algorithms involve multiplying probabilities of individual data points that leads to underflow. Example : Suppose you have 1000 data points, where the probability of each is &lt; 1 lets say around 0.8, we have 0.8 ^ 1000 &#x3D; 1.2302319e-97 which is close to 0. This is underflow.<br>A common way to combat this is to work in the log probability space: <a href="http://blog.smola.org/post/987977550/log-probabilities-semirings-and-floating-point">http://blog.smola.org/post/987977550/log-probabilities-semirings-and-floating-point</a></p>
<p>Overflow: Imagine you have a deep network, error gradients an keep accumulating and often become  vary large gradients. This results in an overflow where the values of the gradients become NAN. Weight regularization and gradient clipping are some common ways of dealing with this problem.</p>
<h3 id="Scaling을-하는-이유"><a href="#Scaling을-하는-이유" class="headerlink" title="Scaling을 하는 이유"></a>Scaling을 하는 이유</h3><hr>
<p>feature scaling을 하는 가장 직관적인 이유는 <strong>분석 단위(크기)를 맟줘주기 위해서이다.</strong> 모델 학습시 각 feature의 크기를 맟줘 줌으로서 학습 시 특정 feature의 영향이 너무 커지는 것을 방지할 수 있다.</p>
<p><strong>scaling은 공분산행렬의 조건수(condition number)를 감소시킨다.</strong></p>
<p>조건수는 행렬에서 eigen value와 가장 작은 eigen value의 비율을 말한다.</p>
<p>$$\text{condition number} &#x3D; \dfrac{\lambda_{\text{max}}}{\lambda_{\text{min}}}$$</p>
<p>조건수가 커질수록 약간의 오차에 대해서도 회귀방정식의 해의 오차가 민감하게 변하기 때문에 회귀식의 에러가 커진다.</p>
<p>조건수의 eigen value는 분산을 바탕으로 구해지기 때문에 scaling을 통해 condition number를 줄일 수 있다.</p>
<p>feature가 scaling이 되지 않을 경우 조건수가 커져서 에러가 증폭된다.</p>
<p><strong>scaling은 데이터의 크기와 범위를 제한해서 Gradient Explode나 Gradient Vanishing을 제한한다.</strong></p>
<ul>
<li>feature마다 </li>
<li>데이터의 범의를 줄여서 Neural network의 최적화 과정에서 수렴속도를 빠르게 한다.  </li>
<li>Neural network model에서 sigmoid 활성화 함수의 <code>saturation</code>(포화) 문제를 완화한다.(Gradient Vanishing)</li>
</ul>
<p><strong>정리하면 Scaling의 핵심은 데이터가 유사한 범위를 가지도록 데이터의 범위를 제한한다는 것이다.</strong></p>
<ol>
<li>데이터의 범위를 제한해서 조건수를 낮춰 예측오차에 덜 민감해게끔 만든다.</li>
<li>데이터의 범위를 제한해서 기울기 폭발,소실 문제를 완화한다.</li>
</ol>
<h3 id="어떤-경우에-Feature-Scaling을-고려해야-하는가"><a href="#어떤-경우에-Feature-Scaling을-고려해야-하는가" class="headerlink" title="어떤 경우에 Feature Scaling을 고려해야 하는가?"></a>어떤 경우에 Feature Scaling을 고려해야 하는가?</h3><hr>
<p><strong>거리 기반 모델의 경우 Scaling이 매우 중요하다</strong></p>
<ul>
<li>KNN,K-means clausturing : 유클리디안 거리를 기반으로 데이터 유사성을 결정하기 때문에 Scaling의 영향을 크게 받는다.</li>
<li>SVM : margin(거리)를 최대화하는 것이 최적화 문제에 포함된 </li>
<li>PCA : 알고리즘의 목적 자체가 분산이 가장 큰 방향을 가지는 고유벡터를 찾는 것이기 때문에 Scaling의 영향을 크게 받는다. 따라서 반드시 사전에 모든 수치형 변수들의 Scaling을 해줘야 한다.</li>
</ul>
<p><strong>Gradient Descent 기반 모델의 경우</strong></p>
<p>신경망을 기반으로 하는 모델의 경우 loss function을 최소화 하는 방식으로 최적화를 진행한다.<br>이는 각 feature의 범위와 크기가 다를 경우 feature 마다 다른 step size를 적용해야 한다는 것을 뜻한다.<br>따라서 scaling를 통해 범위를 맞춰줄 경우 gradient descent의 수렴이 보다 빠르게 이루어진다.</p>
<p><strong>tree기반 알고리즘의 경우 Scaling에 따라 성능에 영향받지 않는다.</strong></p>
<p>대표적으로 tree기반 알고리즘에 해당하는 CART,RandomForest 등은 학습의 대상이 거리와 관련이 없기 때문에 (학습의 대상이 일종의 분기점) Scaling을 해줄 필요가 없다. Scaling을 해주는 경우가 가끔 있지만 이는 Scailng을 요구하는 다른 알고리즘과의 비교를 위해서이다.</p>
<p><strong>언제 Scaling을 하는가?</strong></p>
<p><strong>반드시 학습데이터와 검증 데이터를 나눈 이후에 Scaling을 시행한다.</strong></p>
<p>이는 data leakage로 인해 test data의 정보가 모델링에 포함 될 수 있기 때문이다.</p>
<ul>
<li>train test split 이후의 Scaling 예시</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">normalizer = preprocessing.Normalizer().fit(X_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">X_train = normalizer.transform(X_train) </span><br><span class="line">X_test = normalizer.transform(X_test) </span><br></pre></td></tr></table></figure>


<!--

언제 scaling을 하는가?

렉카

https://datascience.stackexchange.com/questions/54908/data-normalization-before-or-after-train-test-split

https://stackoverflow.com/questions/49444262/normalize-data-before-or-after-split-of-training-and-testing-data


Normalization across instances should be done after splitting the data between training and test set, using only the data from the training set.

This is because the test set plays the role of fresh unseen data, so it's not supposed to be accessible at the training stage. Using any information coming from the test set before or during training is a potential bias in the evaluation of the performance.

[Precision thanks to Neil's comment] When normalizing the test set, one should apply the normalization parameters previously obtained from the training set as-is. Do not recalculate them on the test set, because they would be inconsistent with the model and this would produce wrong predictions.


Gradient Descent의 의미

Gradient descent is an iterative optimisation algorithm that takes us to the minimum of a function.
Machine learning algorithms like linear regression and logistic regression rely on gradient descent to minimise their loss functions or in other words, to reduce the error between the predicted values and the actual values.
Having features with varying degrees of magnitude and range will cause different step sizes for each feature. Therefore, to ensure that gradient descent converges more smoothly and quickly, we need to scale our features so that they share a similar scale.
Check out this video where Andrew Ng explains the gradient descent algorithm in more detail.


Data leakage와 싸우기 위한 5가지 팁!



-일시적 제거 : 관찰이 일어난 시간보다 사실이나 관찰에 대해 배운 시간에 초점을 맞추어 관심 이벤트 직전의 모든 데이터를 제거하십시오.

-소음 추가. 입력 데이터에 임의의 노이즈를 추가하여 누출 가능성이있는 변수의 영향을 부드럽게합니다.

-누출 변수를 제거하십시오. 간단한 규칙 기반 모델을 평가하려면 OneR에 계좌 번호 및 ID 등과 같은 변수를 사용하여 이러한 변수가 누출인지 확인하고 누락 된 경우이를 제거하십시오. 변수가 누설 된 것으로 의심되면 제거하는 것을 고려하십시오.


-파이프 라인을 사용하십시오. R의 caret 패키지 및 scikit-learn의 파이프 라인과 같은 교차 검증 폴드 내에서 일련의 데이터 준비 단계를 수행 할 수있는 파이프 라인 아키텍처를 많이 사용합니다.

-데이터를 따로 보유하십시요. validation데이터 셋을 따로 보유한후 마지막에 최종적으로 모델을 평가하는데 사용하면 됩니다.


-->



<h3 id="Scaler의-종류"><a href="#Scaler의-종류" class="headerlink" title="Scaler의 종류"></a>Scaler의 종류</h3><hr>
<p>Scaling 대표적인 기법</p>
<ul>
<li><strong>Normalization(정규화)</strong></li>
</ul>
<p>보통 값을 0,1 사이로 고정시킨다.</p>
<ul>
<li><strong>Standardization(표준화)</strong></li>
</ul>
<h4 id="MinMaxScaler"><a href="#MinMaxScaler" class="headerlink" title="MinMaxScaler"></a>MinMaxScaler</h4><ul>
<li>대부분의 Scaler가 그런 것 처럼 이상치에 민감하다.</li>
<li>데이터가 가우시안 분포가 아니고 사이즈가 작을 경우 유용하다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 직접 구현</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">minmax</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> (x-<span class="built_in">min</span>(x))/(<span class="built_in">max</span>(x)-<span class="built_in">min</span>(x))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn 에서 제공하는 MinMazScaler</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line">X_train_new = scaler.fit_transform(X_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Robust-Scaler"><a href="#Robust-Scaler" class="headerlink" title="Robust Scaler"></a>Robust Scaler</h4><ul>
<li>중앙값과 IQR을 사용해 이상치의 영향을 줄인 Scaler</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sklearn 구현</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> RobustScaler</span><br><span class="line">rbs = RobustScaler()</span><br><span class="line">rbs.fit_transform(X_train)</span><br></pre></td></tr></table></figure>

<h4 id="StandardScaler"><a href="#StandardScaler" class="headerlink" title="StandardScaler"></a>StandardScaler</h4><ul>
<li>기본적으로 정규분포를 가정한다.</li>
<li>평균을 0, 분산은 1인 분포로 feature를 변환</li>
<li>이상치의 영향이 크기 때문에 이상치가 많을 경우 사전에 제거해주거나 다른 Scaler를 고려해야함</li>
<li>데이터의 최소 최대를 모르는 경우 사용</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 직접구현</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_standard</span>(<span class="params">x</span>):</span><br><span class="line">    mean = np.mean(x)</span><br><span class="line">    rescale = x-mean/np.std(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rescale</span><br><span class="line"></span><br><span class="line"><span class="comment"># slearn</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">scaler = StandardScaler()</span><br><span class="line"></span><br><span class="line">X_train_new = scaler.fit_transform(X_train)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Normalizer"><a href="#Normalizer" class="headerlink" title="Normalizer"></a>Normalizer</h4><ul>
<li>column-wise가 아니라 row wise로 정규화를 적용</li>
<li>최적화 과정에서 gradient exlosion이나 gradient vanishing을 막기 위해 사용</li>
</ul>
<p><strong>Reference &amp; Annotaion</strong></p>
<ul>
<li><a href="https://www.quora.com/What-are-condition-numbers-and-poor-conditioning-How-are-they-related-to-deep-learning">condition number의 의미</a></li>
<li><a href="https://towardsdatascience.com/gradient-descent-the-learning-rate-and-the-importance-of-feature-scaling-6c0b416596e1">importance of feature scaling</a></li>
<li><code>saturation</code>은 sigmoid 활성화 함수의 특정구간에서 gradient가 0에 가까워지는 것이다.(Gradient Vanishing 문제)</li>
<li><a href="https://www.youtube.com/watch?v=F6GSRDoB-Cg&amp;t=74s">https://www.youtube.com/watch?v=F6GSRDoB-Cg&amp;t=74s</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
  </entry>
  <entry>
    <title>[Python]numpy 연산과 활용법</title>
    <url>/2022/06/15/Preprocessing-numpy-basics/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><p><strong>numpy 기능들</strong></p>
<ul>
<li>벡터 배열상에서 데이터 가공, 정제, 부분집합 필터링, 변형 및 기타연산</li>
<li>정렬, unique 탐색, 집합연산같은 일반적인 배열처리 알고리즘</li>
</ul>
<p>numpy의 중요한 특징은 <strong>파이썬 반복문을 사용하지 않고</strong> 대용량 배열에 대한 복잡한 연산이 가능하다는 것이다.</p>
<p>기본적으로 C랑 포트란 기반으로 짜여졌기 때문에 같은 연산이라면 pandas랑 비교도 안되게 빠르게 수행할 수 있다.</p>
<hr>
<h3 id="numpy-basics"><a href="#numpy-basics" class="headerlink" title="numpy basics"></a>numpy basics</h3><ul>
<li>배열 생성<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">   ...: arr = np.arange(<span class="number">0</span>,<span class="number">10</span>) <span class="comment"># 0에서 9까지 의 </span></span><br><span class="line">   ...:</span><br><span class="line">   ...: arr.reshape(<span class="number">2</span>,<span class="number">5</span>) <span class="comment"># 배열 형태 변환</span></span><br><span class="line">Out[<span class="number">5</span>]:</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">   ...: arr = np.arange(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">   ...:</span><br><span class="line">   ...: arr=arr.reshape(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>배열 형태 확인(ndim,shape,len)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: arr.ndim <span class="comment"># 차원 수</span></span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: arr.shape <span class="comment"># 모양</span></span><br><span class="line">Out[<span class="number">8</span>]: (<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="built_in">len</span>(arr)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>배열 데이터 타입 확인(dtype)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: arr_2 = np.random.rand(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: arr_2</span><br><span class="line">Out[<span class="number">16</span>]: array([<span class="number">0.55155657</span>, <span class="number">0.32745746</span>, <span class="number">0.92681611</span>, <span class="number">0.04614794</span>, <span class="number">0.17832697</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: arr_2.dtype</span><br><span class="line">Out[<span class="number">17</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: arr_3 = np.array([<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>],dtype = np.float64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: arr_3.dtype</span><br><span class="line">Out[<span class="number">19</span>]: dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>배열 데이터 타입 변환(astype)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: arr_2=arr_2.astype(np.int64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: arr_2.dtype</span><br><span class="line">Out[<span class="number">25</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: arr_3=arr_3.astype(np.int64)</span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: arr_3.dtype</span><br><span class="line">Out[<span class="number">27</span>]: dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<p><strong>배열 생성함수들</strong></p>
<ul>
<li><p><code>array</code> : 입력데이터를 다차원 배열로 변환.</p>
</li>
<li><p><code>arange</code> : <code>range</code>와 동일하지만 다차원 배열을 반환.</p>
</li>
<li><p><code>np.empty(a)</code> ,<code>np.empty_like(M)</code> : 0 이나 1로 값을 초기화하지 않은 배열을 반환.</p>
</li>
<li><p><code>np.ones(a)</code> : a 크기의 1으로 채워진 배열을 반환 </p>
</li>
<li><p><code>np.ones_like(M)</code> M 배열의 사이즈와 같은 1으로 채워진 배열을 반환</p>
</li>
<li><p><code>np.zeros(a)</code> : a 크기의 0으로 채워진 배열을 반환 </p>
</li>
<li><p><code>np.zeros_like(M)</code> M 배열의 사이즈와 같은 0으로 채워진 배열을 반환</p>
</li>
<li><p><strong><code>np.full</code> :인자로 값과 형태를 받고. 인자로 받은 형태에 값을 채운다.(자주쓴다.)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># np full 용법</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
<li><p><code>np.full_like</code> : 인자로 값과 형태를 받고. 인자로 받은 형태에 값을 채운다.</p>
</li>
<li><p><code>eye</code> , <code>identity</code>: N * N 크기의 단위행렬생성</p>
</li>
<li><p><code>np.random.rand(n)</code> : n 크기 난수 배열 생성</p>
</li>
</ul>
<h3 id="numpy-indexing"><a href="#numpy-indexing" class="headerlink" title="numpy indexing"></a>numpy indexing</h3><ul>
<li>기본 파이썬 list indexing과 유사하지만 차원이 복잡해지면 어려워진다.</li>
</ul>
<h4 id="기초-슬라이싱과-인덱싱"><a href="#기초-슬라이싱과-인덱싱" class="headerlink" title="기초 슬라이싱과 인덱싱"></a>기초 슬라이싱과 인덱싱</h4><ul>
<li>기본적으로 list의 그것과 다를 건 없다.</li>
<li><code>i:j:k</code> 형태로 인덱싱한다.<ul>
<li>i는 starting index </li>
<li>j는 stopping index(j-1 까지 슬라이싱된다.)</li>
<li>k는 step</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: x = np.array(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: x[<span class="number">1</span>:<span class="number">7</span>:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">3</span>]: array([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: x[-<span class="number">2</span>:<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">4</span>]: array([<span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: x[-<span class="number">3</span>:<span class="number">3</span>:-<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">5</span>]: array([<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: x[<span class="number">5</span>:]</span><br><span class="line">Out[<span class="number">6</span>]: array([<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>인덱스 리스트를 통해 쉽게 배열의 값에 접근할 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: arr_2d = np.arange(<span class="number">1</span>,<span class="number">10</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: arr_2d</span><br><span class="line">Out[<span class="number">51</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: arr_2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">52</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 보통 두 번째 방법을 많이 사용한다.</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: arr_2d[<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">53</span>]: <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>다차원 슬라이싱하기</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: arr_2d[:<span class="number">2</span>,<span class="number">1</span>:]</span><br><span class="line">Out[<span class="number">54</span>]:</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>좀 복잡한 형태의 다차원 슬라이싱</li>
</ul>
<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/Numpy1.jpg"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 다차원 배열 인덱싱 예시</span></span><br><span class="line"> [[<span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>] </span><br><span class="line">  [<span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line">  [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">16</span> <span class="number">17</span>]</span><br><span class="line">  [<span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">  [<span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span> <span class="number">29</span>]</span><br><span class="line">  [<span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span> <span class="number">34</span> <span class="number">35</span>]]</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>, <span class="number">3</span>:<span class="number">5</span>]  =  [<span class="number">3</span> <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">4</span>:, <span class="number">4</span>:] = [[<span class="number">28</span> <span class="number">29</span>],</span><br><span class="line">             [<span class="number">34</span> <span class="number">35</span>]]</span><br><span class="line"></span><br><span class="line">a[:, <span class="number">2</span>] =  [<span class="number">2</span> <span class="number">8</span> <span class="number">14</span> <span class="number">20</span> <span class="number">26</span> <span class="number">32</span>]</span><br><span class="line"></span><br><span class="line">a[<span class="number">2</span>:;<span class="number">2</span>, ::<span class="number">2</span>] = [[<span class="number">12</span> <span class="number">14</span> <span class="number">16</span>],</span><br><span class="line">                [<span class="number">24</span> <span class="number">26</span> <span class="number">28</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>:</code> 연산자를 통해  <code>:</code> 가 위치하는 축의 모든 값에 접근할 수 있다.</li>
<li>배열 자체에 <code>[:]</code> 를 사용할 경우 배열의 모든 값이 할당된다.<ul>
<li><strong>기본적으로 데이터가 복사되지 않는다.</strong></li>
<li>데이터를 복사해야 할 경우 <code>copy</code> 함수를 따로 사용한다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">44</span>]: arr</span><br><span class="line">Out[<span class="number">44</span>]:</span><br><span class="line">array([[<span class="number">0.23061655</span>, <span class="number">0.86734388</span>, <span class="number">0.27967631</span>],</span><br><span class="line">       [<span class="number">0.63734555</span>, <span class="number">0.47048728</span>, <span class="number">0.04833744</span>],</span><br><span class="line">       [<span class="number">0.99362969</span>, <span class="number">0.87636748</span>, <span class="number">0.59988875</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: arr[:,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">45</span>]: array([<span class="number">0.86734388</span>, <span class="number">0.47048728</span>, <span class="number">0.87636748</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: arr[:,<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">46</span>]: array([<span class="number">0.86734388</span>, <span class="number">0.47048728</span>, <span class="number">0.87636748</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: arr[:]</span><br><span class="line">Out[<span class="number">47</span>]:</span><br><span class="line">array([[<span class="number">0.23061655</span>, <span class="number">0.86734388</span>, <span class="number">0.27967631</span>],</span><br><span class="line">       [<span class="number">0.63734555</span>, <span class="number">0.47048728</span>, <span class="number">0.04833744</span>],</span><br><span class="line">       [<span class="number">0.99362969</span>, <span class="number">0.87636748</span>, <span class="number">0.59988875</span>]])</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>배열의 일부는 원본배열의 View 이기 때문에 파이썬 <code>list</code> 와 달리 배열의 일부에 대한 변경은 그대로 원본배열에 반영된다.</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">28</span>]: arr_new = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: arr_new[<span class="number">4</span>:<span class="number">7</span>] = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: arr_new</span><br><span class="line">Out[<span class="number">30</span>]: array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>])</span><br></pre></td></tr></table></figure>


<h4 id="boolen-indexing"><a href="#boolen-indexing" class="headerlink" title="boolen indexing"></a>boolen indexing</h4><ul>
<li>실질적으로 가장 자주쓰는 인덱싱이다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: temp=np.random.rand(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: temp[temp&gt;<span class="number">0.5</span>]</span><br><span class="line">Out[<span class="number">63</span>]:</span><br><span class="line">array([<span class="number">0.77402793</span>, <span class="number">0.59064775</span>, <span class="number">0.67170741</span>, <span class="number">0.51967736</span>, <span class="number">0.75161734</span>,</span><br><span class="line">       <span class="number">0.98559447</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="fancy-indexing"><a href="#fancy-indexing" class="headerlink" title="fancy indexing"></a>fancy indexing</h4><ul>
<li>인덱싱과 슬라이싱의 차이는 입력된 범위의 값을 가져오느냐 연속된 값들을 가져오느냐의 차이밖에 없다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">56</span>]: array = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">    ...:</span><br><span class="line">    ...: </span><br><span class="line">    ...: array[[<span class="number">0</span>, <span class="number">2</span>], :<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">56</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br></pre></td></tr></table></figure>



<h3 id="numpy-배열-변형하기-array-transformation"><a href="#numpy-배열-변형하기-array-transformation" class="headerlink" title="numpy 배열 변형하기(array transformation)"></a>numpy 배열 변형하기(array transformation)</h3><h4 id="Transpose"><a href="#Transpose" class="headerlink" title="Transpose"></a>Transpose</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = np.transpose(b) Permute array dimensions</span><br><span class="line">i.T Permute array dimensions</span><br></pre></td></tr></table></figure>
<h4 id="Changing-Array-Shape"><a href="#Changing-Array-Shape" class="headerlink" title="Changing Array Shape"></a>Changing Array Shape</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b.ravel() <span class="comment">#Flatten the array</span></span><br><span class="line">g.reshape(<span class="number">3</span>,-<span class="number">2</span>) <span class="comment">#Reshape, but don’t change data</span></span><br><span class="line">b.flatten() <span class="comment"># rabel() 과 같지만 배열의 copy를 생</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Adding-x2F-Removing-Elements"><a href="#Adding-x2F-Removing-Elements" class="headerlink" title="Adding&#x2F;Removing Elements"></a>Adding&#x2F;Removing Elements</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">h.resize((<span class="number">2</span>,<span class="number">6</span>)) Return a new array <span class="keyword">with</span> shape (<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">np.append(h,g) Append items to an array</span><br><span class="line">np.insert(a, <span class="number">1</span>, <span class="number">5</span>) Insert items <span class="keyword">in</span> an array</span><br><span class="line">np.delete(a,[<span class="number">1</span>]) Delete items <span class="keyword">from</span> an array</span><br></pre></td></tr></table></figure>

<h4 id="Combine-array"><a href="#Combine-array" class="headerlink" title="Combine array"></a>Combine array</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: arr_1 = np.arange(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: arr_2 = np.arange(<span class="number">6</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: np.concatenate((arr_1,arr_2),axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">13</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: np.vstack((arr_1,arr_2))</span><br><span class="line">Out[<span class="number">14</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: np.r_[arr_1,arr_2]</span><br><span class="line">Out[<span class="number">15</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: np.hstack((arr_1,arr_2))</span><br><span class="line">Out[<span class="number">16</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: np.c_[arr_1,arr_2]</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">7</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">9</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Split-array"><a href="#Split-array" class="headerlink" title="Split array"></a>Split array</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: np.hsplit(arr_1,<span class="number">2</span>)</span><br><span class="line">Out[<span class="number">19</span>]: [array([<span class="number">1</span>, <span class="number">2</span>]), array([<span class="number">3</span>, <span class="number">4</span>])]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: arr_3 = np.arange(<span class="number">1</span>,<span class="number">10</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 행 단위 split</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: np.vsplit(arr_3,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">25</span>]: [array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]), array([[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]), array([[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="numpy-method"><a href="#numpy-method" class="headerlink" title="numpy method"></a>numpy method</h3><h4 id="np-where"><a href="#np-where" class="headerlink" title="np.where"></a>np.where</h4><ul>
<li><code>np.where(조건,if true 값,else 값)</code> 방식으로 사용한다.</li>
<li>기본적으로 조건에 기반해 새로운 배열을 생성한다.</li>
<li><strong>logical statement를 vectorize한다.</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Out[<span class="number">63</span>]: df</span><br><span class="line">   A   B   C     D</span><br><span class="line"><span class="number">0</span>  <span class="number">9</span>  <span class="number">14</span>  <span class="number">10</span>  <span class="number">0.24</span></span><br><span class="line"><span class="number">1</span>  <span class="number">8</span>   <span class="number">2</span>  <span class="number">17</span>  <span class="number">0.56</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">18</span>  <span class="number">16</span>  <span class="number">0.12</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>   <span class="number">4</span>  <span class="number">16</span>  <span class="number">0.88</span></span><br><span class="line"><span class="number">4</span>  <span class="number">9</span>   <span class="number">8</span>  <span class="number">16</span>  <span class="number">0.61</span></span><br><span class="line"><span class="number">5</span>  <span class="number">7</span>   <span class="number">3</span>  <span class="number">17</span>  <span class="number">0.44</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">64</span>]: df[<span class="string">&quot;E&quot;</span>] = np.where((df[<span class="string">&quot;B&quot;</span>] &gt; <span class="number">10</span>) &amp; (df[<span class="string">&quot;C&quot;</span>] &gt; <span class="number">10</span>), <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    ...: df</span><br><span class="line">Out[<span class="number">64</span>]:</span><br><span class="line">   A   B   C     D  E</span><br><span class="line"><span class="number">0</span>  <span class="number">9</span>  <span class="number">14</span>  <span class="number">10</span>  <span class="number">0.24</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">8</span>   <span class="number">2</span>  <span class="number">17</span>  <span class="number">0.56</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">18</span>  <span class="number">16</span>  <span class="number">0.12</span>  <span class="number">1</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>   <span class="number">4</span>  <span class="number">16</span>  <span class="number">0.88</span>  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">9</span>   <span class="number">8</span>  <span class="number">16</span>  <span class="number">0.61</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">7</span>   <span class="number">3</span>  <span class="number">17</span>  <span class="number">0.44</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="np-select"><a href="#np-select" class="headerlink" title="np.select"></a>np.select</h4><ul>
<li><code>np.where</code>의 multiple condition 버전이다.</li>
<li>2개 이상의 조건을 한번에 처리해야 할경우 pandas를 사용하는 것 보다 <code>np.select</code>를 활용해 한번에 처리하는 것이 낫다.</li>
</ul>
<p><img src="https://i.imgur.com/Z3XHteT.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># np select 예시</span></span><br><span class="line">In [<span class="number">65</span>]: conditions = [</span><br><span class="line">    ...:   (df[<span class="string">&quot;B&quot;</span>] &gt;= <span class="number">10</span>) &amp; (df[<span class="string">&quot;A&quot;</span>] == <span class="number">0</span>),</span><br><span class="line">    ...:   (df[<span class="string">&quot;B&quot;</span>] &gt;= <span class="number">10</span>) &amp; (df[<span class="string">&quot;A&quot;</span>] == <span class="number">8</span>)</span><br><span class="line">    ...: ]</span><br><span class="line">    ...: values = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">    ...: df[<span class="string">&quot;F&quot;</span>] = np.select(conditions, values, default=<span class="number">0</span>)</span><br><span class="line">    ...: df</span><br><span class="line">    ...:</span><br><span class="line">Out[<span class="number">65</span>]:</span><br><span class="line">   A   B   C     D  E  F</span><br><span class="line"><span class="number">0</span>  <span class="number">9</span>  <span class="number">14</span>  <span class="number">10</span>  <span class="number">0.24</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">1</span>  <span class="number">8</span>   <span class="number">2</span>  <span class="number">17</span>  <span class="number">0.56</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>  <span class="number">3</span>  <span class="number">18</span>  <span class="number">16</span>  <span class="number">0.12</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>   <span class="number">4</span>  <span class="number">16</span>  <span class="number">0.88</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>  <span class="number">9</span>   <span class="number">8</span>  <span class="number">16</span>  <span class="number">0.61</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">5</span>  <span class="number">7</span>   <span class="number">3</span>  <span class="number">17</span>  <span class="number">0.44</span>  <span class="number">0</span>  <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="np-log"><a href="#np-log" class="headerlink" title="np.log"></a>np.log</h4><ul>
<li>자연로그를 리턴한다.<ul>
<li>np.log(np.e) 는 1을 리턴한다.</li>
</ul>
</li>
<li>데이터 정규화시 사용.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.log([<span class="number">1</span>, np.e, np.e**<span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line">array([  <span class="number">0.</span>,   <span class="number">1.</span>,   <span class="number">2.</span>, -Inf])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="np-sort-배열-정렬하기"><a href="#np-sort-배열-정렬하기" class="headerlink" title="np.sort(배열 정렬하기)"></a>np.sort(배열 정렬하기)</h4><ul>
<li><code>np.sort(M)</code> 로 배열을 정렬한다.<ul>
<li>M.sort() 는 배열 자체를 정렬한 결과를 리턴하지만 <code>np.sort(M)</code>은 배열의 복사본을 정렬해 리턴한다,</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">39</span>]: arr_1d = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    ...:</span><br><span class="line">    ...: arr_2d = np.random.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    ...:</span><br><span class="line">    ...: <span class="built_in">print</span>(arr_1d)</span><br><span class="line">    ...: <span class="built_in">print</span>(arr_2d)</span><br><span class="line">[<span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">0</span> <span class="number">3</span> <span class="number">9</span>]</span><br><span class="line">[[<span class="number">8</span> <span class="number">4</span> <span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: <span class="built_in">print</span>(np.sort(arr_1d))</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>np.sort(M)[::-1]</code> : 역순 정렬</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">41</span>]: <span class="built_in">print</span>(np.sort(arr_1d)[::-<span class="number">1</span>])</span><br><span class="line">[<span class="number">9</span> <span class="number">8</span> <span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>행과 열 기준으로 정렬이 가능하다.<ul>
<li><code>np.sort(x, axis=1)</code> : 열 기준</li>
<li><code>np.sort(x, axis=0)</code> : 행 기준</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">42</span>]: <span class="built_in">print</span>(np.sort(arr_2d, axis=<span class="number">0</span>))</span><br><span class="line">    ...: <span class="built_in">print</span>(np.sort(arr_2d, axis=<span class="number">1</span>))</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">8</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">8</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span>]]</span><br></pre></td></tr></table></figure>


<h4 id="np-pad"><a href="#np-pad" class="headerlink" title="np.pad"></a>np.pad</h4><ul>
<li>배열을 일정한 고정길이로 만들기 위해 특정한 값으로 채우는 함수.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Z = np.ones((<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">Z.pad(pad_width=<span class="number">1</span>, </span><br><span class="line">      mode=<span class="string">&#x27;constant&#x27;</span>, <span class="comment"># 특정한 값을 지정해서 패딩할 경우</span></span><br><span class="line">      constant_values=<span class="number">0</span>) <span class="comment"># 값 지정</span></span><br><span class="line"></span><br><span class="line">Z      </span><br><span class="line">[[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>2차원 배열 패딩</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">16</span>]: m = np.arange(<span class="number">1</span>,<span class="number">9</span>).reshape(<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: m</span><br><span class="line">Out[<span class="number">17</span>]:</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 행과 열 모두 2개씩 0으로 패딩 </span></span><br><span class="line">In [<span class="number">20</span>]: np.pad(m,((<span class="number">2</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">2</span>)),<span class="string">&#x27;constant&#x27;</span>,constant_values =<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">20</span>]:</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: np.pad(m,((<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)),<span class="string">&#x27;constant&#x27;</span>,constant_values =<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">21</span>]:</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h3 id="numpy-broadcasting"><a href="#numpy-broadcasting" class="headerlink" title="numpy broadcasting"></a>numpy broadcasting</h3><ul>
<li><p>numpy의 연산은 기본적으로 같은 크기의 배열간의 연산을 전제한다.</p>
</li>
<li><p>하지만 특정 조건을 만족했을 때 numpy는 자동적으로 크기가 다른 배열간의 연산을 수행하기도 하는데 이를 <code>broadcasting</code>이라 한다.</p>
</li>
<li><p><code>broadcasting</code> 연산이 성립되기 위한 다음의 3가지 규칙이 존재한다.</p>
<ul>
<li><strong>규칙 1: 두 배열의 차원 수가 다를 경우, 크기가 작은 배열의 모양은 맨 앞(왼쪽)에 패딩됨</strong></li>
<li><strong>규칙 2: 두 배열의 모양이 임의의 차원에서 일치하지 않으면 해당 차원에서 모양이 1인 배열은 다른 모양과 일치하도록 확장됨</strong></li>
<li><strong>규칙 3: 어떤 차원에서든 크기가 일치하지 않고 둘 다 1과 같지 않으면 오류가 발생.</strong></li>
</ul>
</li>
<li><p><strong>단순히 한쪽의 크기를 맞춰서 연산이 가능하게끔 만드는 것이라고 생각하면 이해하기 쉽다.</strong></p>
</li>
</ul>
<p><img src="https://jakevdp.github.io/PythonDataScienceHandbook/figures/02.05-broadcasting.png"></p>
<ul>
<li><code>a</code> 의 차원이 더 작기 때문에 규식 1,2 에 따라 연산시 <code>a</code> 가 padding 되고 확장됨.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: M = np.ones((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">   ...: a = np.arange(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">print</span>(M.shape)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: <span class="built_in">print</span>(a.shape)</span><br><span class="line">(<span class="number">3</span>,)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: M + a</span><br><span class="line">Out[<span class="number">8</span>]:</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: a.shape</span><br><span class="line">Out[<span class="number">9</span>]: (<span class="number">3</span>,)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>References</strong></p>
<ul>
<li><a href="https://numpy.org/doc/stable/index.html">Numpy 공식문서</a></li>
<li><a href="https://www.datacamp.com/community/blog/python-numpy-cheat-sheet">numpy array transfrormation</a></li>
<li><a href="https://www.geeksforgeeks.org/numpy-indexing/">numpy indexing</a></li>
<li><a href="https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html">numpy broadcasting</a></li>
<li><a href="https://sparrow.dev/numpy-pad/">numpy padding</a></li>
<li><a href="https://towardsdatascience.com/3-numpy-functions-to-facilitate-data-analysis-with-pandas-b1ad342a569">numpy select</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>[pandas]기본자료형을 DataFrame으로 변환하기</title>
    <url>/2022/06/15/Preprocessing-pandas-collection-to-df/</url>
    <content><![CDATA[<!--

- ML
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


<center>Kaggle Customer Score Dataset</center>

#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p>Python으로 데이터 분석을 하다보면 pandas를 찾게 되는 경우가 많다.<br>Python 기본 자료형을 pandas에서 제공하는 자료형으로 변환하는 데 익숙해지면 전처리작업을 보다 수월할게 할 수 있다.</p>
<p> <strong>여기서는 작업을 하면서 자주쓰게 되는 자료형 변환 방법들을 정리하였다</strong></p>
<hr>
<p>아래 데이터를 사용해서 연습해보자</p>
<table>
<thead>
<tr>
<th align="right">Age</th>
<th align="right">CustomerID</th>
<th align="left">Genre</th>
</tr>
</thead>
<tbody><tr>
<td align="right">19</td>
<td align="right">1</td>
<td align="left">Male</td>
</tr>
<tr>
<td align="right">21</td>
<td align="right">2</td>
<td align="left">Male</td>
</tr>
<tr>
<td align="right">20</td>
<td align="right">3</td>
<td align="left">Female</td>
</tr>
<tr>
<td align="right">23</td>
<td align="right">4</td>
<td align="left">Female</td>
</tr>
<tr>
<td align="right">31</td>
<td align="right">5</td>
<td align="left">Female</td>
</tr>
</tbody></table>
<h2 id="Collection-to-DataFrame"><a href="#Collection-to-DataFrame" class="headerlink" title="Collection to DataFrame"></a>Collection to DataFrame</h2><h3 id="Dictionary-to-DataFrame"><a href="#Dictionary-to-DataFrame" class="headerlink" title="Dictionary to DataFrame"></a>Dictionary to DataFrame</h3><p>기본적으로 하나의 row가 하나의 dictionary형태로 list에 들어간다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">data=&#123;<span class="string">&#x27;Age&#x27;</span>: &#123;<span class="number">0</span>: <span class="number">19</span>, <span class="number">1</span>: <span class="number">21</span>, <span class="number">2</span>: <span class="number">20</span>, <span class="number">3</span>: <span class="number">23</span>, <span class="number">4</span>: <span class="number">31</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;CustomerID&#x27;</span>: &#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">5</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;Genre&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;Male&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;Male&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Female&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Female&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;Female&#x27;</span>&#125;&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Tuple-to-DataFrame"><a href="#Tuple-to-DataFrame" class="headerlink" title="Tuple to DataFrame"></a>Tuple to DataFrame</h3><p>Tuple은 분석단계에서보다는 DataBase와 연결해서 CRUD할 일이 있을 경우 자주 사용된다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data=[(<span class="number">19</span>, <span class="number">1</span>, <span class="string">&#x27;Male&#x27;</span>),</span><br><span class="line"> (<span class="number">21</span>, <span class="number">2</span>, <span class="string">&#x27;Male&#x27;</span>),</span><br><span class="line"> (<span class="number">20</span>, <span class="number">3</span>, <span class="string">&#x27;Female&#x27;</span>),</span><br><span class="line"> (<span class="number">23</span>, <span class="number">4</span>, <span class="string">&#x27;Female&#x27;</span>),</span><br><span class="line"> (<span class="number">31</span>, <span class="number">5</span>, <span class="string">&#x27;Female&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;Age&#x27;</span>, <span class="string">&#x27;ID&#x27;</span>, <span class="string">&#x27;Gender&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="List-to-DataFrame"><a href="#List-to-DataFrame" class="headerlink" title="List to DataFrame"></a>List to DataFrame</h3><p>list의 경우 <code>list(zip(lst, lst2, lst3))</code> 로 tuple 형태로 데이터를 변환해준 뒤 DF를 만든다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">df = pd.DataFrame(list(zip(lst, lst2, lst3)),</span><br><span class="line">               columns=[&#x27;Age&#x27;, &#x27;ID&#x27;, &#x27;Gender&#x27;])</span><br><span class="line">df</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="DataFrame-to-Collection"><a href="#DataFrame-to-Collection" class="headerlink" title="DataFrame to Collection"></a>DataFrame to Collection</h2><p>반대로 DataFrame에서 Python 기본 자료형을 받아야와 할 경우도 있다.</p>
<p>이 경우는 pandas library에서 제공하는 함수들을 통해 쉽게 해결할 수 있다.</p>
<h3 id="Dataframe-to-Ditonary"><a href="#Dataframe-to-Ditonary" class="headerlink" title="Dataframe to Ditonary"></a>Dataframe to Ditonary</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">df.to_dict()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&#123;<span class="string">&#x27;Age&#x27;</span>: &#123;<span class="number">0</span>: <span class="number">19</span>, <span class="number">1</span>: <span class="number">21</span>, <span class="number">2</span>: <span class="number">20</span>, <span class="number">3</span>: <span class="number">23</span>, <span class="number">4</span>: <span class="number">31</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;CustomerID&#x27;</span>: &#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">1</span>: <span class="number">2</span>, <span class="number">2</span>: <span class="number">3</span>, <span class="number">3</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">5</span>&#125;,</span><br><span class="line"> <span class="string">&#x27;Genre&#x27;</span>: &#123;<span class="number">0</span>: <span class="string">&#x27;Male&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;Male&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;Female&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;Female&#x27;</span>, <span class="number">4</span>: <span class="string">&#x27;Female&#x27;</span>&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Dataframe-to-Tuple"><a href="#Dataframe-to-Tuple" class="headerlink" title="Dataframe to Tuple"></a>Dataframe to Tuple</h3><p><code>itertuple()</code>을 사용할 시 name을 default로 넣으면 컬럼명도 같이 반환된다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>(df.itertuples(index=<span class="literal">False</span>,name=<span class="literal">None</span>)) <span class="comment"># df to tuple</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;[(<span class="number">19</span>, <span class="number">1</span>, <span class="string">&#x27;Male&#x27;</span>),</span><br><span class="line"> (<span class="number">21</span>, <span class="number">2</span>, <span class="string">&#x27;Male&#x27;</span>),</span><br><span class="line"> (<span class="number">20</span>, <span class="number">3</span>, <span class="string">&#x27;Female&#x27;</span>),</span><br><span class="line"> (<span class="number">23</span>, <span class="number">4</span>, <span class="string">&#x27;Female&#x27;</span>),</span><br><span class="line"> (<span class="number">31</span>, <span class="number">5</span>, <span class="string">&#x27;Female&#x27;</span>)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DataFrame-to-List"><a href="#DataFrame-to-List" class="headerlink" title="DataFrame to List"></a>DataFrame to List</h3><p>컬럼을 list로 변환</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.columns.values.tolist()</span><br></pre></td></tr></table></figure>

<p>값을 list로 변환</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.values.tolist()</span><br><span class="line"></span><br><span class="line">&gt;&gt;[[<span class="number">19</span>, <span class="number">1</span>, <span class="string">&#x27;Male&#x27;</span>],</span><br><span class="line"> [<span class="number">21</span>, <span class="number">2</span>, <span class="string">&#x27;Male&#x27;</span>],</span><br><span class="line"> [<span class="number">20</span>, <span class="number">3</span>, <span class="string">&#x27;Female&#x27;</span>],</span><br><span class="line"> [<span class="number">23</span>, <span class="number">4</span>, <span class="string">&#x27;Female&#x27;</span>],</span><br><span class="line"> [<span class="number">31</span>, <span class="number">5</span>, <span class="string">&#x27;Female&#x27;</span>]]</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.geeksforgeeks.org/create-a-pandas-dataframe-from-lists/">https://www.geeksforgeeks.org/create-a-pandas-dataframe-from-lists/</a></li>
<li><a href="https://stackoverflow.com/questions/9758450/pandas-convert-dataframe-to-array-of-tuples">https://stackoverflow.com/questions/9758450/pandas-convert-dataframe-to-array-of-tuples</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>[pandas]pandas의 특정 열 제외한 모든 컬럼 출력하기</title>
    <url>/2022/06/15/Preprocessing-pandas-remove_col/</url>
    <content><![CDATA[<!--

- ML
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


## tricks
https://towardsdatascience.com/30-examples-to-master-pandas-f8a2da751fa4

#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>DataFrame의 특정 열 제외하기</strong></p>
<hr>
<h2 id="하나의-컬럼을-DF에서-제거할-결우"><a href="#하나의-컬럼을-DF에서-제거할-결우" class="headerlink" title="하나의 컬럼을 DF에서 제거할 결우"></a>하나의 컬럼을 DF에서 제거할 결우</h2><p>기본적으로 두 가지 방법이 있다.</p>
<p><strong>drop 활용</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.drop(column_name, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><strong>.loc 활용</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.loc[:, df.columns != col]</span><br></pre></td></tr></table></figure>
<p>drop이 익숙하다보니 좀 더 많이 사용하게 된다.</p>
<h2 id="여러-컬럼을-DF에서-제거할-경우"><a href="#여러-컬럼을-DF에서-제거할-경우" class="headerlink" title="여러 컬럼을 DF에서 제거할 경우"></a>여러 컬럼을 DF에서 제거할 경우</h2><p><strong>indexing 사용</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.columns[~df.columns.isin([<span class="string">&#x27;지울&#x27;</span>,<span class="string">&#x27;컬럼&#x27;</span>])]]</span><br></pre></td></tr></table></figure>


<p><strong>difference 사용</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df.columns.difference([<span class="string">&#x27;지울&#x27;</span>, <span class="string">&#x27;칼럼&#x27;</span>])]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>difference가 있는걸 모르고 계속 isin을 써왔다.<br>difference에도 익숙해져야 겠다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://datascience.stackexchange.com/questions/46434/dataframe-columns-difference-use">https://datascience.stackexchange.com/questions/46434/dataframe-columns-difference-use</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>[pandas]Pandas Groupby용법 간단히 정리</title>
    <url>/2022/06/15/Preprocessing-pandas_groupby/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>pandas에서 제공하는 groupby는 기본적으로 데이터 범주별 요약통계량을 계산하는 일을 한다. sql의 groupby나 R dplyr의 groupby와 유사하다고 생각하면 된다.<br>여기서는 전처리과정에서 자주쓰게 되는 groupby 용법을 살펴본다.</p>
<hr>
<h2 id="기본적인-용법들"><a href="#기본적인-용법들" class="headerlink" title="기본적인 용법들"></a>기본적인 용법들</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 데이터 불러오기</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">drinks = pd.read_csv(<span class="string">&#x27;http://bit.ly/drinksbycountry&#x27;</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>country</th>
      <th>beer_servings</th>
      <th>spirit_servings</th>
      <th>wine_servings</th>
      <th>total_litres_of_pure_alcohol</th>
      <th>continent</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Afghanistan</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>Asia</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Albania</td>
      <td>89</td>
      <td>132</td>
      <td>54</td>
      <td>4.9</td>
      <td>Europe</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Algeria</td>
      <td>25</td>
      <td>0</td>
      <td>14</td>
      <td>0.7</td>
      <td>Africa</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Andorra</td>
      <td>245</td>
      <td>138</td>
      <td>312</td>
      <td>12.4</td>
      <td>Europe</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Angola</td>
      <td>217</td>
      <td>57</td>
      <td>45</td>
      <td>5.9</td>
      <td>Africa</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 기초적인 용법 : 대륙별 beer_servings 평균</span></span><br><span class="line">drinks.groupby(<span class="string">&#x27;continent&#x27;</span>).beer_servings.mean()</span><br></pre></td></tr></table></figure>




<pre><code>continent
Africa            61.471698
Asia              37.045455
Europe           193.777778
North America    145.434783
Oceania           89.687500
South America    175.083333
Name: beer_servings, dtype: float64
</code></pre>
<p>.agg()와 같은 집계함수를 사용해 한 변수의 여러 요약통계량을 구하는 것이 가능하다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks[drinks.continent==<span class="string">&#x27;Asia&#x27;</span>].beer_servings.agg([<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>])</span><br></pre></td></tr></table></figure>




<pre><code>count     44.000000
mean      37.045455
max      247.000000
min        0.000000
Name: beer_servings, dtype: float64
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.groupby(<span class="string">&#x27;continent&#x27;</span>).beer_servings.agg([<span class="string">&#x27;count&#x27;</span>,<span class="string">&#x27;mean&#x27;</span>,<span class="string">&#x27;max&#x27;</span>,<span class="string">&#x27;min&#x27;</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>count</th>
      <th>mean</th>
      <th>max</th>
      <th>min</th>
    </tr>
    <tr>
      <th>continent</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Africa</th>
      <td>53</td>
      <td>61.471698</td>
      <td>376</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Asia</th>
      <td>44</td>
      <td>37.045455</td>
      <td>247</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Europe</th>
      <td>45</td>
      <td>193.777778</td>
      <td>361</td>
      <td>0</td>
    </tr>
    <tr>
      <th>North America</th>
      <td>23</td>
      <td>145.434783</td>
      <td>285</td>
      <td>1</td>
    </tr>
    <tr>
      <th>Oceania</th>
      <td>16</td>
      <td>89.687500</td>
      <td>306</td>
      <td>0</td>
    </tr>
    <tr>
      <th>South America</th>
      <td>12</td>
      <td>175.083333</td>
      <td>333</td>
      <td>93</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 분석할 칼럼을 지정해주지 않으면 모든 numeric의 평균을 그룹별로 반환한다.</span></span><br><span class="line">drinks.groupby(<span class="string">&#x27;continent&#x27;</span>).mean()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>beer_servings</th>
      <th>spirit_servings</th>
      <th>wine_servings</th>
      <th>total_litres_of_pure_alcohol</th>
    </tr>
    <tr>
      <th>continent</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Africa</th>
      <td>61.471698</td>
      <td>16.339623</td>
      <td>16.264151</td>
      <td>3.007547</td>
    </tr>
    <tr>
      <th>Asia</th>
      <td>37.045455</td>
      <td>60.840909</td>
      <td>9.068182</td>
      <td>2.170455</td>
    </tr>
    <tr>
      <th>Europe</th>
      <td>193.777778</td>
      <td>132.555556</td>
      <td>142.222222</td>
      <td>8.617778</td>
    </tr>
    <tr>
      <th>North America</th>
      <td>145.434783</td>
      <td>165.739130</td>
      <td>24.521739</td>
      <td>5.995652</td>
    </tr>
    <tr>
      <th>Oceania</th>
      <td>89.687500</td>
      <td>58.437500</td>
      <td>35.625000</td>
      <td>3.381250</td>
    </tr>
    <tr>
      <th>South America</th>
      <td>175.083333</td>
      <td>114.750000</td>
      <td>62.416667</td>
      <td>6.308333</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># m</span></span><br><span class="line">%matplotlib inline</span><br><span class="line">drinks.groupby(<span class="string">&#x27;continent&#x27;</span>).mean().plot(kind=<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure>


<p><img src="https://i.imgur.com/KvoD6CS.png">    </p>
<h2 id="응용하기"><a href="#응용하기" class="headerlink" title="응용하기"></a>응용하기</h2><ul>
<li>Groupby에서 특정 그룹에 접근하기</li>
<li>Groupby에서 특정 그룹에 접근 후 필터링 하기 (filter 사용)</li>
<li>pd.cut 을 사용한 파생변수 만들기</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 아시아 그룹만 </span></span><br><span class="line">drinks.groupby(<span class="string">&#x27;continent&#x27;</span>).get_group(<span class="string">&#x27;Asia&#x27;</span>).head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>country</th>
      <th>beer_servings</th>
      <th>spirit_servings</th>
      <th>wine_servings</th>
      <th>total_litres_of_pure_alcohol</th>
      <th>continent</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Afghanistan</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>Asia</td>
    </tr>
    <tr>
      <th>12</th>
      <td>Bahrain</td>
      <td>42</td>
      <td>63</td>
      <td>7</td>
      <td>2.0</td>
      <td>Asia</td>
    </tr>
    <tr>
      <th>13</th>
      <td>Bangladesh</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>Asia</td>
    </tr>
    <tr>
      <th>19</th>
      <td>Bhutan</td>
      <td>23</td>
      <td>0</td>
      <td>0</td>
      <td>0.4</td>
      <td>Asia</td>
    </tr>
    <tr>
      <th>24</th>
      <td>Brunei</td>
      <td>31</td>
      <td>2</td>
      <td>1</td>
      <td>0.6</td>
      <td>Asia</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 여러 그룹의 통계량을 조건걸어서 구할 경우</span></span><br><span class="line">drinks.groupby([<span class="string">&#x27;wine_servings&#x27;</span>, <span class="string">&#x27;continent&#x27;</span>]).get_group((<span class="number">0</span>, <span class="string">&#x27;Asia&#x27;</span>)).total_litres_of_pure_alcohol.<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>




<pre><code>6.2
</code></pre>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pd.cut을 활용한 연속형 변수의 구간화 변수생성</span></span><br><span class="line">drinks[<span class="string">&#x27;Range&#x27;</span>] = drinks.groupby(<span class="string">&#x27;country&#x27;</span>).beer_servings.apply(pd.cut, bins=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th &#123;
    vertical-align: top;
&#125;

.dataframe thead th &#123;
    text-align: right;
&#125;
</code></pre>
<p></style></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>country</th>
      <th>beer_servings</th>
      <th>spirit_servings</th>
      <th>wine_servings</th>
      <th>total_litres_of_pure_alcohol</th>
      <th>continent</th>
      <th>Range</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Afghanistan</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0.0</td>
      <td>Asia</td>
      <td>(-0.001, 0.0]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Albania</td>
      <td>89</td>
      <td>132</td>
      <td>54</td>
      <td>4.9</td>
      <td>Europe</td>
      <td>(88.911, 89.0]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Algeria</td>
      <td>25</td>
      <td>0</td>
      <td>14</td>
      <td>0.7</td>
      <td>Africa</td>
      <td>(24.975, 25.0]</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Andorra</td>
      <td>245</td>
      <td>138</td>
      <td>312</td>
      <td>12.4</td>
      <td>Europe</td>
      <td>(244.755, 245.0]</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Angola</td>
      <td>217</td>
      <td>57</td>
      <td>45</td>
      <td>5.9</td>
      <td>Africa</td>
      <td>(216.783, 217.0]</td>
    </tr>
  </tbody>
</table>
</div>



<p>TF를 반환하는 lamba 함수를 작성할 경우 any()나 all()을 써서 값을 반환해줄 필요가 있다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## filter를 사용한 조건식. 위의 결과와 같은 값을 리턴한다.</span></span><br><span class="line">drinks.groupby([<span class="string">&#x27;wine_servings&#x27;</span>,<span class="string">&#x27;continent&#x27;</span>]).<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : ((x.wine_servings == <span class="number">0</span>) &amp; (x.continent==<span class="string">&#x27;Asia&#x27;</span>) ).<span class="built_in">any</span>()).total_litres_of_pure_alcohol.<span class="built_in">sum</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<pre><code>6.2
</code></pre>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.youtube.com/watch?v=qy0fDqoMJx8">https://www.youtube.com/watch?v=qy0fDqoMJx8</a></li>
<li><a href="https://pandas.pydata.org/docs/reference/groupby.html">https://pandas.pydata.org/docs/reference/groupby.html</a></li>
</ul>
<h2 id="다음에-정리할-것"><a href="#다음에-정리할-것" class="headerlink" title="다음에 정리할 것"></a>다음에 정리할 것</h2><ul>
<li>any()와 all() 관련 함수</li>
<li>filter</li>
<li>assign</li>
<li>pd.cut과 np.digitize를 활용한 연속형 변수의 구간화</li>
<li>pandas query as dplyr filter</li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>[pandas]Pandas를 활용한 데이터분석 시작하기</title>
    <url>/2022/06/15/Preprocessing-pandas_overview/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><ul>
<li><strong>알아야 하는 것</strong><ul>
<li>pandas data structure</li>
<li>reading data</li>
<li>dealing with missing data</li>
<li>slicing &amp; indexing<ul>
<li>loc &amp; iloc</li>
</ul>
</li>
<li>map<ul>
<li>map</li>
<li>apply.map</li>
<li>apply</li>
</ul>
</li>
<li>groupby</li>
<li>pandas eda<ul>
<li>info()</li>
<li>head()</li>
<li>value_counts()</li>
<li>describe</li>
<li>dtypes()</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="pandas-자료구조"><a href="#pandas-자료구조" class="headerlink" title="pandas 자료구조"></a>pandas 자료구조</h2><h3 id="Sereies"><a href="#Sereies" class="headerlink" title="Sereies"></a>Sereies</h3><blockquote>
<p><strong>Series는 일련의 객체를 담을 수 있고 인덱스를 가지고 있는 1차원 배열의 자료구조이다.</strong>  </p>
</blockquote>
<ul>
<li>기본적으로 고정길이의 Ordered Dictionary라고 생각하면 편하다.(사전형을 대체하여 쓸수 있다)</li>
<li>index를 지정하지 않을 경우 기본색인인 정수에서 n-1까지의 숫자가 표시된다.</li>
<li>Series의 배열과 색인 객체는 value와 index속성을 통해 얻을 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Series 생성</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s</span><br><span class="line">Out[<span class="number">4</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">1</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="number">3</span>    <span class="number">4</span></span><br><span class="line">dtype: int64</span><br><span class="line"><span class="comment"># Series 객체반환</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: s.values</span><br><span class="line">Out[<span class="number">6</span>]: array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment"># 1차원 배열형태로 반환됨</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: s.index</span><br><span class="line">Out[<span class="number">7</span>]: RangeIndex(start=<span class="number">0</span>, stop=<span class="number">4</span>, step=<span class="number">1</span>) <span class="comment"># range(4) 반환</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Series 생성(index 지정)</span></span><br><span class="line"></span><br><span class="line">s2 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],index = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>사전형을 대체하여 Series 사용하기</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 조건 반환</span></span><br><span class="line"><span class="string">&#x27;b&#x27;</span> <span class="keyword">in</span> s2</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;e&#x27;</span> <span class="keyword">in</span> s2</span><br><span class="line"></span><br><span class="line"><span class="comment"># dictionary로 부터 Series 생성하기</span></span><br><span class="line">sdic = &#123;<span class="string">&quot;A&quot;</span>:<span class="number">10</span>,<span class="string">&quot;B&quot;</span>:<span class="number">20</span>,<span class="string">&quot;C&quot;</span>:<span class="number">40</span>&#125;</span><br><span class="line">s3 = pd.Series(sdic)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: s3</span><br><span class="line">Out[<span class="number">9</span>]: </span><br><span class="line">A    <span class="number">10</span></span><br><span class="line">B    <span class="number">20</span></span><br><span class="line">C    <span class="number">40</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></table></figure>
<p><strong>Series에서 누락된 데이터 찾기</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pd.isnull(s) <span class="comment"># null인 값 찾기</span></span><br><span class="line"></span><br><span class="line">pd.notnull(s) <span class="comment"># null 아닌 값 찾기</span></span><br><span class="line"></span><br><span class="line">s.isnull() <span class="comment"># 인스턴스 메서드로 null값 찾기</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Series의 name속성</strong></p>
<ul>
<li>Series 객체와 index 모두 name 속성을 가질 수 있다<ul>
<li>DF인덱싱, 슬라이싱에 쓸 수 있다.</li>
</ul>
</li>
<li>리스트 객체를 대입하여 Series의 index를 변경할 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name 속성 부여하기</span></span><br><span class="line">s.name  = <span class="string">&#x27;population&#x27;</span></span><br><span class="line">obj.index.name = <span class="string">&#x27;state&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># index 대입하기</span></span><br><span class="line">df.index = [<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;K&#x27;</span>,<span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h3><blockquote>
<p><strong>R의 데이터 프레임의 pandas버전이다.<br>로우와 칼럼에 대한 인덱스를 가지고 있다.</strong></p>
</blockquote>
<ul>
<li>단순히 인덱스와 모양이 같은 Series 객체들을 담고있는 Dictionary라고 생각하면 된다.</li>
</ul>
<p><strong>DF 생성하기</strong></p>
<ul>
<li>dictionary를 이용해 쉽게 DF를 만들 수 있다.</li>
<li>인스탄스 메서드 head()를 이용해 상위 5개 값을 출력할 수 있다.</li>
<li>dictionary에 없는 값을 넘길 경우 Nan으로 저장된다.<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 생성</span></span><br><span class="line">data = &#123;<span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line"> <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line"> <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</span><br><span class="line"></span><br><span class="line">df = DataFrame(data)</span><br><span class="line"></span><br><span class="line">df.head() <span class="comment"># 상위 5개 출력</span></span><br><span class="line"></span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">    state  year  pop</span><br><span class="line"><span class="number">0</span>    Ohio  <span class="number">2000</span>  <span class="number">1.5</span></span><br><span class="line"><span class="number">1</span>    Ohio  <span class="number">2001</span>  <span class="number">1.7</span></span><br><span class="line"><span class="number">2</span>    Ohio  <span class="number">2002</span>  <span class="number">3.6</span></span><br><span class="line"><span class="number">3</span>  Nevada  <span class="number">2001</span>  <span class="number">2.4</span></span><br><span class="line"><span class="number">4</span>  Nevada  <span class="number">2002</span>  <span class="number">2.9</span></span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(data,</span><br><span class="line">                     columns=[<span class="string">&#x27;year&#x27;</span>, <span class="string">&#x27;state&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;debt&#x27;</span>],</span><br><span class="line">                     index=[<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;four&#x27;</span>, <span class="string">&#x27;five&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<strong>loc속성과 iloc속성 활용 Series, 행열 접근하기</strong></li>
</ul>
<ol>
<li>행번호로 접근하기 (iloc)(index location)</li>
</ol>
<ul>
<li><strong>: 는 ‘전체’ 를 의미한다. (중요!)</strong></li>
<li>인덱싱 범위에 따라 반환되는 객체의 타입이 달라질 수 있다(DF,Series)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 행 접근</span></span><br><span class="line">df2.iloc[<span class="number">0</span>] <span class="comment"># 첫번째</span></span><br><span class="line">df2.iloc[<span class="number">2</span>] <span class="comment"># 세번째</span></span><br><span class="line">df2.iloc[-<span class="number">1</span>] <span class="comment"># 마지막 행</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 열 접근</span></span><br><span class="line">df2.iloc[:,<span class="number">0</span>] <span class="comment"># 첫번째 열</span></span><br><span class="line">df2.iloc[:,<span class="number">2</span>] <span class="comment"># 세번째 열</span></span><br><span class="line">df2.iloc[:,-<span class="number">1</span>] <span class="comment"># 마지막 열</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># indexing with iloc</span></span><br><span class="line">df2.iloc[<span class="number">0</span>:<span class="number">4</span>] <span class="comment"># 첫 4개행</span></span><br><span class="line">df2.iloc[:,<span class="number">0</span>:<span class="number">2</span>] <span class="comment"># 첫 2개 열</span></span><br><span class="line">df2.iloc[[<span class="number">0</span>,<span class="number">2</span>]:,[<span class="number">0</span>,<span class="number">2</span>]]  <span class="comment"># 1,3 행, 1,3 열</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li>label이나 조건으로 접근하기 (loc)(location)</li>
</ol>
<ul>
<li>범위지정시 loc는 포함이고 iloc나 기타 python은 포함되지 않음</li>
<li>iloc의 경우 기본적으로 인덱스 기반 슬라이싱이고 loc는 이름기반 슬라이싱이어서 범위 지정시 주의 필요<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 행접근</span></span><br><span class="line">df2.loc[:,<span class="string">&#x27;year&#x27;</span>]</span><br><span class="line"><span class="comment"># 열접근</span></span><br><span class="line">df2.loc[:,<span class="string">&#x27;year&#x27;</span>]</span><br><span class="line"><span class="comment"># 특정 값 접근</span></span><br><span class="line">df2.loc[<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;year&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 인덱스가 숫자일 경우</span></span><br><span class="line"></span><br><span class="line">df2.loc[<span class="number">2</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li>loc를 활용한 조건문</li>
</ol>
<ul>
<li>조건문을 사용해 배열이나 Series, DF를 반환할 수 있다</li>
<li>values를 사용해 배열을 추출할 수 있다</li>
<li><strong>loc가 반환하는 결과는 기본적으로 copy가 아니라 view이기 때문에 값을 대입하거나 수정 할 수 있다</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [randint(<span class="number">1</span>, <span class="number">9</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [randint(<span class="number">1</span>, <span class="number">9</span>)*<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>: [randint(<span class="number">1</span>, <span class="number">9</span>)*<span class="number">100</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 조건문으로 Boolen Series 반환하기</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;B&quot;</span>] &gt; <span class="number">50</span></span><br><span class="line"></span><br><span class="line">(df[<span class="string">&quot;B&quot;</span>] &gt; <span class="number">50</span>) &amp; (df[<span class="string">&quot;C&quot;</span>] == <span class="number">900</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loc에 바로 조건문을 넣을 경우</span></span><br><span class="line"></span><br><span class="line">df.loc[(df[<span class="string">&quot;B&quot;</span>] &gt; <span class="number">50</span>) &amp; (df[<span class="string">&quot;C&quot;</span>] == <span class="number">900</span>), <span class="string">&quot;A&quot;</span>] <span class="comment"># 행적용 조건문</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="데이터-전처리-방법들-index"><a href="#데이터-전처리-방법들-index" class="headerlink" title="데이터 전처리 방법들(index)"></a>데이터 전처리 방법들(index)</h2><h3 id="Cleaning"><a href="#Cleaning" class="headerlink" title="Cleaning"></a>Cleaning</h3><blockquote>
<p><strong>noise가 있을 경우 제거, inconsistency 수정</strong></p>
</blockquote>
<h3 id="Integration"><a href="#Integration" class="headerlink" title="Integration"></a>Integration</h3><blockquote>
<p><strong>데이터 나누기, 합치기(필요에 따라)</strong></p>
</blockquote>
<h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><blockquote>
<p><strong>데이터형태변환 , 보통 datatype을 맞춰주거나 정규화를 하는 것을 말한다.</strong></p>
</blockquote>
<h3 id="Redution"><a href="#Redution" class="headerlink" title="Redution"></a>Redution</h3><blockquote>
<p><strong>차원축소, 요인분석등을 사용해 분석 변수들을 줄이는 것</strong></p>
</blockquote>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://stackoverflow.com/questions/15315452/selecting-with-complex-criteria-from-pandas-dataframe">https://stackoverflow.com/questions/15315452/selecting-with-complex-criteria-from-pandas-dataframe</a></li>
<li><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.repeat.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.repeat.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>[Sampling]Class Imbalance 다루기</title>
    <url>/2022/06/15/Preprocessing-sampling-imbalance-data/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning

- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk

#참고

https://cinema4dr12.tistory.com/1016?category=515283
https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html

오버 샘플링 렉카
https://wyatt37.tistory.com/10
-->

<h1 id="Dealing-with-Class-Imbalance-클래스-불균형-다루기"><a href="#Dealing-with-Class-Imbalance-클래스-불균형-다루기" class="headerlink" title="Dealing with Class Imbalance(클래스 불균형 다루기)"></a>Dealing with Class Imbalance(클래스 불균형 다루기)</h1><hr>
<!--
오버 샘플링 렉카
https://wyatt37.tistory.com/10

-->

<p><strong>여기서 해결하는 문제</strong></p>
<ul>
<li>Biased predictions</li>
<li>Misleading accuracy</li>
</ul>
<p><strong>보통 고려하는 해결방법</strong></p>
<ul>
<li>데이터 합성(Synthesisis of new minority class instances)</li>
<li>Over-sampling </li>
<li>Under-sampling </li>
<li>class weight 조정하기(상향&#x2F;하향가중치 적용)</li>
<li>cost function 조정</li>
</ul>
<h2 id="Random-Under-Sampling"><a href="#Random-Under-Sampling" class="headerlink" title="Random Under-Sampling"></a>Random Under-Sampling</h2><hr>
<ul>
<li><p><strong>Advantages</strong></p>
<ul>
<li>It can help improve run time and storage problems by reducing the number of training data samples when the training data set is huge.</li>
</ul>
</li>
<li><p><strong>Disadvantages</strong></p>
<ul>
<li>It can discard potentially useful information which could be important for building rule classifiers.</li>
<li>The sample chosen by random under-sampling may be a biased sample. And it will not be an accurate representation of the population. Thereby, resulting in inaccurate results with the actual test data set.</li>
</ul>
</li>
</ul>
<h3 id="Tomeck-Links"><a href="#Tomeck-Links" class="headerlink" title="Tomeck Links"></a>Tomeck Links</h3><p>Tomek Links란 두 샘플 사이에 다른 관측치가 없는 경우를 말한다.</p>
<p><img src="https://blog.dominodatalab.com/hubfs/Imported_Blog_Media/machine-learning-challenges-for-automated-prompting-in-smart-homes-23-638-2.jpg"></p>
<p>Tomek Links 방법은 Tomeck links 중에 major에 속하는 데이터포인트를 제거하는 undersampling 기법의 일종이다. 이 경우 데이터 불균형을 해결하면서 클래스 간 거리가 확보 되지만 여전히 정보 자체를 잃어버린다는 단점은 남는다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> imblearn.under_sampling <span class="keyword">import</span> TomekLinks</span><br><span class="line"></span><br><span class="line">tomek = TomekLinks(random_state = <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">X_tm, y_tm = tomek.fit_sample(X, y)</span><br></pre></td></tr></table></figure>

<h2 id="Random-Over-Sampling"><a href="#Random-Over-Sampling" class="headerlink" title="Random Over-Sampling"></a>Random Over-Sampling</h2><hr>
<p>minor class의 데이터를 반복적으로 replace하는 것</p>
<p>단순히 부트스트래핑을 통한 업샘플링의 변형이다.</p>
<ul>
<li><strong>Advantages</strong><ul>
<li>no information loss</li>
</ul>
</li>
<li><strong>Disadvantages</strong><ul>
<li>prone to overfitting due to copying same information</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_samp, y_samp = RandomOverSampler(random_state=<span class="number">0</span>).fit_sample(X_imb, y_imb)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">classification_result2(X_imb, y_imb)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">model_samp = classification_result2(X_samp, y_samp)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>부트스트래핑을 직접 구현할 경우</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bootstrap</span>(<span class="params">X, n = <span class="literal">None</span>, iterations = <span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="literal">None</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(X)</span><br><span class="line">        X_resampled = np.random.choice(X, size = (iterations, n), replace = <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> X_resampled</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SMOTE-Synthetic-Minority-Oversample-Technique"><a href="#SMOTE-Synthetic-Minority-Oversample-Technique" class="headerlink" title="SMOTE(Synthetic Minority Oversample Technique)"></a>SMOTE(Synthetic Minority Oversample Technique)</h3><p>임의의 마이너 클래스 데이터 포인트와 근접한 마이너 클래스 데이터 포인트 사이에 새로운 데이터 포인트를 생성하는 것</p>
<p><strong>반드시 training set에 대해서만 SMOTE 시행. 이는 data leakage 문제와 관련이 있다.</strong></p>
<p>$$syntetic &#x3D; x_{minor} + u * (x_{nn}-x_{minor})$$</p>
<p>synthetic 합성 값은 minor class의 데이터 포인트와 근접한 minor class의 데이터포인트의 차이에 uniform distribution을 곱한 뒤 minor class의 데이터포인트를 더해준 값이다.</p>
<!--
- Process
  + Identify the feature vectore and its nearest neighbor
  + take the the difference between the two
  + multiply the difference with a random number between 0 and 1
  + identify a new point on the line segment by adding the randomg number to feature vector
  + repeat the process of identified feature vectors

- 절차
-->

<ul>
<li>numpy로 SMOTE 구현하기</li>
</ul>
<p>알고리즘을 구현하는 것 자체는 어렵지 않지만 실제로 작업을 할때는 <code>imblearn</code> 모듈에서 제공하는 SMOTE함수를 사용하는 것이 훨씬 낫다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># SMOTE</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">euclidean_dist</span>(<span class="params">x1,x2</span>):</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(<span class="built_in">sum</span>((x1-x2)**<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_neighbors</span>(<span class="params">X, x, k</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  minor 클레스 데이터에 대해서 k개의 nearest neighbor를 구한다</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    X_len = <span class="built_in">len</span>(X)</span><br><span class="line">    euclidean_dist = [euclidean_dist(X[i],x) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X_len)]</span><br><span class="line">    euclidean_dist = np.sort(euclidean_dist)</span><br><span class="line">    neighbors = euclidean_dist[:k]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> neighbors</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">SMOTE</span>(<span class="params">X,k</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  smote algorithm 적용한 합성 데이터 생성</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">    X_len = <span class="built_in">len</span>(X)</span><br><span class="line">    synthetic = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,X_len):</span><br><span class="line">        w = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> w == <span class="number">0</span>:</span><br><span class="line">            w = np.random.uniform(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">        add = get_neighbors(X,X[i],k)</span><br><span class="line">        rand_idx = random.randint(<span class="number">0</span>,k-<span class="number">1</span>)</span><br><span class="line">        add = add[rand_idx]</span><br><span class="line">        </span><br><span class="line">        diff = X[i] - add</span><br><span class="line">        </span><br><span class="line">        synthetic.append(X[i] + w*diff)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> np.array(synthetic)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>imblearn을 활용한 target resampling</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> imblearn.over_sampling <span class="keyword">import</span> SMOTE</span><br><span class="line"></span><br><span class="line">rs = SMOTE(random_state=<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">X_new, y_new = rs.fit_sample(X, y)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Borderline-SMOTE"><a href="#Borderline-SMOTE" class="headerlink" title="Borderline-SMOTE"></a>Borderline-SMOTE</h3><p>: major와 minor를 구분하는 경계선에 있는 Borderline에 속하는 데이터데 대해 SMOTE을 적용하는 것</p>
<p>Minor class data X와 근접한 K개의 데이터포인트의 클래스의 수에 따라 SMOTE 적용 여부를 결정</p>
<ul>
<li><p>0 &lt;&#x3D; K’ &lt;&#x3D; K&#x2F;2 : Safe</p>
</li>
<li><p>K &#x3D; K’ : Noise</p>
</li>
<li><p>K&#x2F;2 &lt; K’ &lt; K : Danger : 이 경우에 SMOTE을 적용한다.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Borderline-SMOTE</span></span><br><span class="line"></span><br><span class="line">bsmote = BorderlineSMOTE(random_state = <span class="number">1234</span>, k_neighbors=<span class="number">3</span>, m_neighbors=<span class="number">10</span>)</span><br><span class="line">X, y_new = bsmote.fit_resample(X, y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Original_y %s&#x27;</span> % Counter(y))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;BorderlineSMOTE_y %s&#x27;</span> % Counter(y_new))</span><br></pre></td></tr></table></figure>

<h3 id="ADASYN"><a href="#ADASYN" class="headerlink" title="ADASYN"></a>ADASYN</h3><p>: Adaptive Synthetic Sampling</p>
<ul>
<li>가중치를 적용해 SMOTE을 다르게 진행</li>
<li>인접한 major class의 비율에 따라 SMOTE을 다르게 적용하는 것</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_samp, y_samp = ADASYN(random_state=<span class="number">0</span>).fit_sample(X_imb, y_imb)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="모델링과-평가-단계에서-Class-Imbalance-다루기"><a href="#모델링과-평가-단계에서-Class-Imbalance-다루기" class="headerlink" title="모델링과 평가 단계에서 Class Imbalance 다루기"></a>모델링과 평가 단계에서 Class Imbalance 다루기</h2><hr>
<p>샘플링 단계가 아니라 모델링과 평가단계에서 Class Imbalance 문제를 처리한다.</p>
<h3 id="Change-the-performance-metric"><a href="#Change-the-performance-metric" class="headerlink" title="Change the performance metric"></a>Change the performance metric</h3><p>class weight에 영향을 덜 받게끔 평가지표 자체를 바꿀 수 있다.</p>
<p>다른 방법보다 품이 덜 들어서 의외로 괜찮은 방법이다.</p>
<ul>
<li><p><strong>Confusion Matrix</strong>: a table showing correct predictions and types of incorrect predictions.</p>
</li>
<li><p><strong>Precision</strong>: the number of true positives divided by all positive predictions. Precision is also called Positive Predictive Value. It is a measure of a classifier’s exactness. Low precision indicates a high number of false positives.</p>
</li>
<li><p><strong>Recall</strong>: the number of true positives divided by the number of positive values in the test data. The recall is also called Sensitivity or the True Positive Rate. It is a measure of a classifier’s completeness. Low recall indicates a high number of false negatives.</p>
</li>
<li><p><strong>F1</strong>: Score: the weighted average of precision and recall.</p>
</li>
<li><p><strong>Area Under ROC Curve (AUROC)</strong>: AUROC represents the likelihood of your model distinguishing observations from two classes.<br>In other words, if you randomly select one observation from each class, what’s the probability that your model will be able to “rank” them correctly?</p>
</li>
</ul>
<h3 id="Penalize-Algorithms-class-weight"><a href="#Penalize-Algorithms-class-weight" class="headerlink" title="Penalize Algorithms(class_weight)"></a>Penalize Algorithms(class_weight)</h3><ul>
<li>Cost-Sensitive Training</li>
<li>minority class로의 오분류에 대한 패널티를 크게 만듦</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># load library</span></span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line"><span class="comment"># class weight </span></span><br><span class="line">svc_model = SVC(class_weight=<span class="string">&#x27;balanced&#x27;</span>, probability=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">svc_model.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line">svc_predict = svc_model.predict(x_test)<span class="comment"># check performance</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ROCAUC score:&#x27;</span>,roc_auc_score(y_test, svc_predict))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuracy score:&#x27;</span>,accuracy_score(y_test, svc_predict))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;F1 score:&#x27;</span>,f1_score(y_test, svc_predict))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>sklearn를 활용한 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Classweight  계산 </span></span><br><span class="line"><span class="keyword">from</span> sklearn.utils.class_weight <span class="keyword">import</span> compute_class_weight</span><br><span class="line">classes = np.unique(y_train)</span><br><span class="line">weights = compute_class_weight(class_weight=<span class="string">&#x27;balanced&#x27;</span>, classes=classes, y=y_train)</span><br><span class="line">class_weights = <span class="built_in">dict</span>(<span class="built_in">zip</span>(classes, weights)) <span class="comment"># 모델의 인수로 들어간다.</span></span><br></pre></td></tr></table></figure>

<ul>
<li>R 을 활용한 구현</li>
</ul>
<p>대출연체가 minor이기에 연제에 대한 가중치를 1&#x2F;p로 적용.<br>p는 연체의 확률값</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wt 가중치 벡터 만들기</span></span><br><span class="line">wt <span class="operator">&lt;-</span> ifelse<span class="punctuation">(</span>loan_all_data<span class="operator">$</span>outcome <span class="operator">==</span> <span class="string">&#x27;default&#x27;</span><span class="punctuation">,</span></span><br><span class="line">             <span class="number">1</span><span class="operator">/</span>mean<span class="punctuation">(</span>loan_all_data<span class="operator">$</span>outcome <span class="operator">==</span> <span class="string">&#x27;default&#x27;</span><span class="punctuation">)</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">clf <span class="operator">&lt;-</span> glm<span class="punctuation">(</span>outcome <span class="operator">~</span> payment_inc_ratio<span class="operator">+</span>purpose_<span class="operator">+</span>home_<span class="operator">+</span>emp_len<span class="punctuation">,</span></span><br><span class="line">           data<span class="operator">=</span> loan_all_data<span class="punctuation">,</span></span><br><span class="line">           weight <span class="operator">=</span>wt<span class="punctuation">,</span> family<span class="operator">=</span><span class="string">&quot;binomial&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Novelty-Detection-단일클래스-분류기법"><a href="#Novelty-Detection-단일클래스-분류기법" class="headerlink" title="Novelty Detection(단일클래스 분류기법)"></a>Novelty Detection(단일클래스 분류기법)</h3><ul>
<li>단일클래스 분류기법</li>
<li>Minor를 무시하고 Major class 에 속하는 데이터를 결정하는 일종의 바운더리를 생성하고 그 바운더리에 들어가냐 들어가지 않냐의 boolen으로 클래스를 결정한다.</li>
<li>outlier 를 판별하는 알고리즘</li>
</ul>
<h2 id="Reference-amp-annotation"><a href="#Reference-amp-annotation" class="headerlink" title="Reference &amp; annotation"></a><strong>Reference &amp; annotation</strong></h2><ul>
<li><a href="https://towardsdatascience.com/methods-for-dealing-with-imbalanced-data-5b761be45a18">https://towardsdatascience.com/methods-for-dealing-with-imbalanced-data-5b761be45a18</a></li>
<li><strong>Class weight를 적용하는 방식이 minor를 oversampling하거나 major를 undersampling하는 방법을 대체할 수 있다.(Practical Statistics for Data Scientist)</strong></li>
<li><a href="https://www.analyticsvidhya.com/blog/2020/07/10-techniques-to-deal-with-class-imbalance-in-machine-learning/">https://www.analyticsvidhya.com/blog/2020/07/10-techniques-to-deal-with-class-imbalance-in-machine-learning/</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>Sampling</tag>
      </tags>
  </entry>
  <entry>
    <title>[pandas]pandas 함수와 기초용법들</title>
    <url>/2022/06/15/Preprocessing-pandas_tricks/</url>
    <content><![CDATA[<h2 id="pandas-tricks"><a href="#pandas-tricks" class="headerlink" title="pandas tricks"></a><strong>pandas tricks</strong></h2><blockquote>
<p>pandas관련 자주 사용할만한 코드 정리</p>
</blockquote>
<h3 id="pandas-version확인"><a href="#pandas-version확인" class="headerlink" title="pandas version확인"></a>pandas version확인</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.__version__ <span class="comment"># pandas version확인</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.show_versions() <span class="comment">#의존성 패키지 확인</span></span><br></pre></td></tr></table></figure>

<h3 id="DF-생성하기"><a href="#DF-생성하기" class="headerlink" title="DF 생성하기"></a>DF 생성하기</h3><blockquote>
<p>여러 방법이 있지만 보통 dictionary를 사용한다.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;col one&#x27;</span>:[<span class="number">100</span>, <span class="number">200</span>], <span class="string">&#x27;col two&#x27;</span>:[<span class="number">300</span>, <span class="number">400</span>]&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 난수생성을 통핸 DF생성</span></span><br><span class="line">pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure>

<h3 id="열이름-변경하기"><a href="#열이름-변경하기" class="headerlink" title="열이름 변경하기"></a>열이름 변경하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dictionary 형태로 변경하기</span></span><br><span class="line">df = df.rename(&#123;<span class="string">&#x27;col one&#x27;</span> : <span class="string">&#x27;col_one&#x27;</span>,<span class="string">&#x27;col two&#x27;</span>: <span class="string">&#x27;col_two&#x27;</span>&#125;, axis = <span class="string">&#x27;columns&#x27;</span> ) <span class="comment"># 적용할 axis지정 rename</span></span><br><span class="line"></span><br><span class="line">df.add_prefix(<span class="string">&#x27;X_&#x27;</span>) <span class="comment">#컬럼에 접두어 X 추가</span></span><br><span class="line">df.add_suffix(<span class="string">&#x27;_Y&#x27;</span>) <span class="comment">#컬럼에 접미어 Y 추가</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># list를 매핑해 변경하기</span></span><br><span class="line">df.columns = [<span class="string">&#x27;col_one&#x27;</span>, <span class="string">&#x27;col_two&#x27;</span>]</span><br></pre></td></tr></table></figure>


<h3 id="행순서-뒤집기"><a href="#행순서-뒤집기" class="headerlink" title="행순서 뒤집기"></a>행순서 뒤집기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.loc[::-<span class="number">1</span>].head()</span><br></pre></td></tr></table></figure>

<h3 id="reverse-column-order"><a href="#reverse-column-order" class="headerlink" title="reverse column order"></a>reverse column order</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">drinks.loc[:, ::-<span class="number">1</span>].head() <span class="comment"># [start:end:(step)]에 대한 이해 필요</span></span><br><span class="line"><span class="comment"># start, end가 비어있고 step이 -1이기에 순서가 역순으로 바뀜</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="datatype-기준으로-컬럼-선택하기"><a href="#datatype-기준으로-컬럼-선택하기" class="headerlink" title="datatype 기준으로 컬럼 선택하기"></a>datatype 기준으로 컬럼 선택하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.dtypes <span class="comment"># 모든 열의 dtype 확인</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drinks.select_dtypes(include=<span class="string">&#x27;number&#x27;</span>).head() <span class="comment"># dtype이 numeric인 데이터 추출</span></span><br><span class="line"></span><br><span class="line">drinks.select_dtypes(include=[<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;category&#x27;</span>, <span class="string">&#x27;datetime&#x27;</span>]).head()</span><br></pre></td></tr></table></figure>
<h3 id="문자열-numeric으로-변환하기"><a href="#문자열-numeric으로-변환하기" class="headerlink" title="문자열 numeric으로 변환하기"></a>문자열 numeric으로 변환하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;col_one&#x27;</span>:[<span class="string">&#x27;1.1&#x27;</span>, <span class="string">&#x27;2.2&#x27;</span>, <span class="string">&#x27;3.3&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;col_two&#x27;</span>:[<span class="string">&#x27;4.4&#x27;</span>, <span class="string">&#x27;5.5&#x27;</span>, <span class="string">&#x27;6.6&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;col_three&#x27;</span>:[<span class="string">&#x27;7.7&#x27;</span>, <span class="string">&#x27;8.8&#x27;</span>, <span class="string">&#x27;-&#x27;</span>]&#125;)</span><br><span class="line">df</span><br><span class="line"></span><br><span class="line"><span class="comment"># astype()을 활용한 변환</span></span><br><span class="line">df.astype(&#123;<span class="string">&#x27;col_one&#x27;</span>:<span class="string">&#x27;float&#x27;</span>, <span class="string">&#x27;col_two&#x27;</span>:<span class="string">&#x27;float&#x27;</span>&#125;).dtypes</span><br><span class="line"></span><br><span class="line"><span class="comment"># to_numeric을 활용한 변환</span></span><br><span class="line">pd.to_numeric(df.col_three, errors=<span class="string">&#x27;coerce&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># df 전체에 적용(numeric 변환 후 fillna)</span></span><br><span class="line">df = df.apply(pd.to_numeric, errors=<span class="string">&#x27;coerce&#x27;</span>).fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># , 이 포함된 숫자형태의 문자열의 경우 replace사용</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">toInt</span>(<span class="params">string</span>):</span><br><span class="line">    string = <span class="built_in">int</span>(string.replace(<span class="string">&#x27;,&#x27;</span>,<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">    returen string</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="DF-사이즈-줄이기"><a href="#DF-사이즈-줄이기" class="headerlink" title="DF 사이즈 줄이기"></a>DF 사이즈 줄이기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 메모리 사용정도 확인</span></span><br><span class="line">drinks.info(memory_usage=<span class="string">&#x27;deep&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 컬럼지정을 활용한 데이터 줄이기</span></span><br><span class="line">dtypes = &#123;<span class="string">&#x27;continent&#x27;</span>:<span class="string">&#x27;category&#x27;</span>&#125;</span><br><span class="line">smaller_drinks = pd.read_csv(<span class="string">&#x27;http://bit.ly/drinksbycountry&#x27;</span>, usecols=cols, dtype=dtypes)</span><br><span class="line">smaller_drinks.info(memory_usage=<span class="string">&#x27;deep&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Build-a-DataFrame-from-mulfiple-files-row-wise"><a href="#Build-a-DataFrame-from-mulfiple-files-row-wise" class="headerlink" title="Build a DataFrame from mulfiple files (row-wise)"></a>Build a DataFrame from mulfiple files (row-wise)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> glob <span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line"><span class="comment"># 정규식,와일드카드 관련문서 참고</span></span><br><span class="line"><span class="comment"># stocks로 시작하는 data폴더 내 모든 csv 파일 </span></span><br><span class="line">stock_files = <span class="built_in">sorted</span>(glob(<span class="string">&#x27;data/stocks*.csv&#x27;</span>))</span><br><span class="line">stock_files</span><br><span class="line"></span><br><span class="line">[<span class="string">&#x27;data/stocks1.csv&#x27;</span>, <span class="string">&#x27;data/stocks2.csv&#x27;</span>, <span class="string">&#x27;data/stocks3.csv&#x27;</span>] <span class="comment"># 리스트 형태로 반환</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 파일합치기</span></span><br><span class="line">pd.concat((pd.read_csv(file) <span class="keyword">for</span> file <span class="keyword">in</span> stock_files), ignore_index=<span class="literal">True</span>) <span class="comment"># ignore index는 각 파일의 index를 무시하고 초기화하는 옵션이다.</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Build-a-DataFrame-from-mulfiple-files-column-wise"><a href="#Build-a-DataFrame-from-mulfiple-files-column-wise" class="headerlink" title="Build a DataFrame from mulfiple files (column-wise)"></a>Build a DataFrame from mulfiple files (column-wise)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 축옵션만 넣어주면 된다</span></span><br><span class="line">pd.concat((pd.read_csv(file) <span class="keyword">for</span> file <span class="keyword">in</span> drink_files), axis=<span class="string">&#x27;columns&#x27;</span>).head()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="클립보드에서-df불러오기"><a href="#클립보드에서-df불러오기" class="headerlink" title="클립보드에서 df불러오기"></a>클립보드에서 df불러오기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_clipboard()</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<h3 id="DF-subsetting-하기"><a href="#DF-subsetting-하기" class="headerlink" title="DF subsetting 하기"></a>DF subsetting 하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># frac으로 원db의 75% 할당</span></span><br><span class="line">movies_1 = movies.sample(frac=<span class="number">0.75</span>, random_state=<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 나머지</span></span><br><span class="line">movies_2 = movies.drop(movies_1.index)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="isin을-활용한-DF필터링"><a href="#isin을-활용한-DF필터링" class="headerlink" title="isin을 활용한 DF필터링"></a>isin을 활용한 DF필터링</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inin을 사용해 특정열에 대해 값에 대한조건을 넣어줄 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 포함하고 뽑기</span></span><br><span class="line">movies[movies.genre.isin([<span class="string">&#x27;Action&#x27;</span>,<span class="string">&#x27;Drama&#x27;</span>,<span class="string">&#x27;Western&#x27;</span>])].head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 제외하고 뽑기</span></span><br><span class="line">movies[~movies.genre.isin([<span class="string">&#x27;Action&#x27;</span>, <span class="string">&#x27;Drama&#x27;</span>, <span class="string">&#x27;Western&#x27;</span>])].head()</span><br></pre></td></tr></table></figure>

<h3 id="value-counts-를-관측값-구하기"><a href="#value-counts-를-관측값-구하기" class="headerlink" title="value_counts()를 관측값 구하기"></a>value_counts()를 관측값 구하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 우선 카테고리(장르)별 관측값를 구한다</span></span><br><span class="line">counts = movies.genre.value_counts()</span><br><span class="line">counts</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># count에서 상위3개를 구한다.</span></span><br><span class="line">counts.nlargest(<span class="number">3</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="결측값-처리하기"><a href="#결측값-처리하기" class="headerlink" title="결측값 처리하기"></a>결측값 처리하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 결측값 조건걸기</span></span><br><span class="line">ufo = dropna(thresh = <span class="built_in">len</span>(ufo)*<span class="number">0.9</span>, axis = <span class="string">&#x27;columns&#x27;</span>) <span class="comment"># 90% 이상 값이 있는 컬럼만 유지</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 열별로 결측값의 수 세기</span></span><br><span class="line">ufo.isna().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># NA가 하나라도 있는 열 삭제</span></span><br><span class="line">ufo.dropna(axis=<span class="string">&#x27;columns&#x27;</span>).head()</span><br></pre></td></tr></table></figure>
<h3 id="split를-활용한-문자열-나누기"><a href="#split를-활용한-문자열-나누기" class="headerlink" title=".split를 활용한 문자열 나누기"></a>.split를 활용한 문자열 나누기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;name&#x27;</span>:[<span class="string">&#x27;John Arthur Doe&#x27;</span>, <span class="string">&#x27;Jane Ann Smith&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;location&#x27;</span>:[<span class="string">&#x27;Los Angeles, CA&#x27;</span>, <span class="string">&#x27;Washington, DC&#x27;</span>]&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;middle&#x27;</span>, <span class="string">&#x27;last&#x27;</span>]] = df.name.<span class="built_in">str</span>.split(<span class="string">&#x27; &#x27;</span>, expand=<span class="literal">True</span>)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/image/output.png"></p>
<h3 id="리스트를-DF로-변환하기"><a href="#리스트를-DF로-변환하기" class="headerlink" title="리스트를 DF로 변환하기"></a>리스트를 DF로 변환하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;col_one&#x27;</span>:[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="string">&#x27;col_two&#x27;</span>:[[<span class="number">10</span>, <span class="number">40</span>], [<span class="number">20</span>, <span class="number">50</span>], [<span class="number">30</span>, <span class="number">60</span>]]&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>
<p><img src="/image/output2.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_new = df.col_two.apply(pd.Series) <span class="comment"># apply를 활용한 df 생성</span></span><br><span class="line">df_new</span><br></pre></td></tr></table></figure>
<h3 id="Aggregate-by-multiple-funtions"><a href="#Aggregate-by-multiple-funtions" class="headerlink" title="Aggregate by multiple funtions"></a>Aggregate by multiple funtions</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aggregate를 활용한 요약통계량 산출하기</span></span><br><span class="line">orders.groupby(<span class="string">&#x27;order_id&#x27;</span>).item_price.agg([<span class="string">&#x27;sum&#x27;</span>, <span class="string">&#x27;count&#x27;</span>]).head()</span><br></pre></td></tr></table></figure>

<h3 id="Combine-the-output-of-an-aggregation-by-multiple-funtions"><a href="#Combine-the-output-of-an-aggregation-by-multiple-funtions" class="headerlink" title="Combine the output of an aggregation by multiple funtions"></a>Combine the output of an aggregation by multiple funtions</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># transform()은 입력된 개체와 동일하게 인덱스된 객체를 반환하며 다중연산에 쓰인다.</span></span><br><span class="line">total_price = orders.groupby(<span class="string">&#x27;order_id&#x27;</span>).item_price.transform(<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># transform() 관련레퍼런스</span></span><br><span class="line"><span class="comment"># https://kongdols-room.tistory.com/169 </span></span><br></pre></td></tr></table></figure>
<h3 id="loc를-활용한-행열-슬라이싱"><a href="#loc를-활용한-행열-슬라이싱" class="headerlink" title=".loc를 활용한 행열 슬라이싱"></a>.loc를 활용한 행열 슬라이싱</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">titanic.describe().loc[<span class="string">&#x27;min&#x27;</span>:<span class="string">&#x27;max&#x27;</span>]</span><br><span class="line"></span><br><span class="line">titanic.describe().loc[<span class="string">&#x27;min&#x27;</span>:<span class="string">&#x27;max&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>:<span class="string">&#x27;Parch&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="계층적-index를-가지는-Series-DF로-변환하기"><a href="#계층적-index를-가지는-Series-DF로-변환하기" class="headerlink" title="계층적 index를 가지는 Series DF로 변환하기"></a>계층적 index를 가지는 Series DF로 변환하기</h3><ul>
<li>부모자식 노드처럼 계층이 있는 인덱스를 가지는 DF를 만들 수있다</li>
<li>잘 쓰진 않는 것 같다<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 계층적</span></span><br><span class="line"><span class="comment"># https://nittaku.tistory.com/122</span></span><br><span class="line"></span><br><span class="line">titanic.groupby([<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>]).Survived.mean()</span><br><span class="line"></span><br><span class="line"><span class="comment"># changing multiple Series into a DF</span></span><br><span class="line">titanic.groupby([<span class="string">&#x27;Sex&#x27;</span>, <span class="string">&#x27;Pclass&#x27;</span>]).Survived.mean().unstack()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="피벗테이블-만들기"><a href="#피벗테이블-만들기" class="headerlink" title="피벗테이블 만들기"></a>피벗테이블 만들기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">titanic.pivot_table(index=<span class="string">&#x27;Sex&#x27;</span>, columns=<span class="string">&#x27;Pclass&#x27;</span>, values=<span class="string">&#x27;Survived&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>)</span><br><span class="line"><span class="comment"># pivot_table에서 aggfunc 파라미터를 &#x27;count&#x27; 으로 바꿀 경우 단순 crosstable을 반환한다</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># margins = True option으로 행열합을 DF에 추가한다</span></span><br><span class="line">titanic.pivot_table(index=<span class="string">&#x27;Sex&#x27;</span>, columns=<span class="string">&#x27;Pclass&#x27;</span>, values=<span class="string">&#x27;Survived&#x27;</span>, aggfunc=<span class="string">&#x27;mean&#x27;</span>,</span><br><span class="line">                    margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="bin과-labels를-활용해-수치형-변수-범주형-변수로-바꾸기"><a href="#bin과-labels를-활용해-수치형-변수-범주형-변수로-바꾸기" class="headerlink" title="bin과 labels를 활용해 수치형 변수 범주형 변수로 바꾸기"></a>bin과 labels를 활용해 수치형 변수 범주형 변수로 바꾸기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use bin with the labels</span></span><br><span class="line">pd.cut(titanic.Age, bins=[<span class="number">0</span>, <span class="number">18</span>, <span class="number">25</span>, <span class="number">99</span>], labels=[<span class="string">&#x27;child&#x27;</span>, <span class="string">&#x27;young adult&#x27;</span>, <span class="string">&#x27;adult&#x27;</span>]).head(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h3 id="DF-표시형식-바꾸기"><a href="#DF-표시형식-바꾸기" class="headerlink" title="DF 표시형식 바꾸기"></a>DF 표시형식 바꾸기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set_option을 통해 표시형식 바꾸기</span></span><br><span class="line">pd.set_option(<span class="string">&#x27;display.float_format&#x27;</span>, <span class="string">&#x27;&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>)</span><br></pre></td></tr></table></figure>
<h3 id="DF-꾸미기-Style-a-DataFrame"><a href="#DF-꾸미기-Style-a-DataFrame" class="headerlink" title="DF 꾸미기 (Style a DataFrame)"></a>DF 꾸미기 (Style a DataFrame)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format_dict = &#123;<span class="string">&#x27;Date&#x27;</span>:<span class="string">&#x27;&#123;:%m/%d/%y&#125;&#x27;</span>, <span class="string">&#x27;Close&#x27;</span>:<span class="string">&#x27;$&#123;:.2f&#125;&#x27;</span>, <span class="string">&#x27;Volume&#x27;</span>:<span class="string">&#x27;&#123;:,&#125;&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">df.style.<span class="built_in">format</span>(format_dict) <span class="comment"># 스타일 바꾸기</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="ProfileReport를-통해-DF-구조-통계량-한번에-확인하기"><a href="#ProfileReport를-통해-DF-구조-통계량-한번에-확인하기" class="headerlink" title="ProfileReport를 통해 DF 구조, 통계량 한번에 확인하기"></a>ProfileReport를 통해 DF 구조, 통계량 한번에 확인하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i</span><br><span class="line">mport pandas_profiling</span><br><span class="line">pandas_profiliing.PrifileReport(titanic)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="glob을-사용해-여러-csv파일을-하나의-df로-합치기"><a href="#glob을-사용해-여러-csv파일을-하나의-df로-합치기" class="headerlink" title="glob을 사용해 여러 csv파일을 하나의 df로 합치기"></a>glob을 사용해 여러 csv파일을 하나의 df로 합치기</h3><ul>
<li><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"></span><br><span class="line">path = <span class="string">r&#x27;C:\DRO\DCL_rawdata_files&#x27;</span> <span class="comment"># use your path</span></span><br><span class="line">all_files = glob.glob(path + <span class="string">&quot;/*.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line">li = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> all_files:</span><br><span class="line">    df = pd.read_csv(filename, index_col=<span class="literal">None</span>, header=<span class="number">0</span>)</span><br><span class="line">    li.append(df)</span><br><span class="line"></span><br><span class="line">frame = pd.concat(li, axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DF에-컬럼-추가하기"><a href="#DF에-컬럼-추가하기" class="headerlink" title="DF에 컬럼 추가하기"></a>DF에 컬럼 추가하기</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dic = &#123;<span class="string">&#x27;Name&#x27;</span>: [<span class="string">&#x27;Jai&#x27;</span>, <span class="string">&#x27;Princi&#x27;</span>, <span class="string">&#x27;Gaurav&#x27;</span>, <span class="string">&#x27;Anuj&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;Height&#x27;</span>: [<span class="number">5.1</span>, <span class="number">6.2</span>, <span class="number">5.1</span>, <span class="number">5.2</span>],</span><br><span class="line">        <span class="string">&#x27;Qualification&#x27;</span>: [<span class="string">&#x27;Msc&#x27;</span>, <span class="string">&#x27;MA&#x27;</span>, <span class="string">&#x27;Msc&#x27;</span>, <span class="string">&#x27;Msc&#x27;</span>]&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Convert the dictionary into DataFrame</span></span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Declare a list that is to be converted into a column</span></span><br><span class="line">address = [<span class="string">&#x27;Delhi&#x27;</span>, <span class="string">&#x27;Bangalore&#x27;</span>, <span class="string">&#x27;Chennai&#x27;</span>, <span class="string">&#x27;Patna&#x27;</span>]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Using &#x27;Address&#x27; as the column name</span></span><br><span class="line"><span class="comment"># and equating it to the list</span></span><br><span class="line">df[<span class="string">&#x27;Address&#x27;</span>] = address</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="apply-등을-활용한-파생변수-생성하기"><a href="#apply-등을-활용한-파생변수-생성하기" class="headerlink" title="apply 등을 활용한 파생변수 생성하기"></a>apply 등을 활용한 파생변수 생성하기</h3><p>-DF전체에 적용하거나 DF일부에 적용할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lambda를-활용한-함수-적용"><a href="#lambda를-활용한-함수-적용" class="headerlink" title="lambda를 활용한 함수 적용"></a>lambda를 활용한 함수 적용</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p><a href="http://www.leejungmin.org/post/2018/04/21/pandas_apply_and_map/">http://www.leejungmin.org/post/2018/04/21/pandas_apply_and_map/</a></p>
<p><a href="https://wikidocs.net/46758">https://wikidocs.net/46758</a></p>
<p><a href="https://data-make.tistory.com/123">https://data-make.tistory.com/123</a></p>
<h2 id="3-References"><a href="#3-References" class="headerlink" title="3. References"></a>3. References</h2><ul>
<li><a href="https://www.geeksforgeeks.org/adding-new-column-to-existing-dataframe-in-pandas/">https://www.geeksforgeeks.org/adding-new-column-to-existing-dataframe-in-pandas/</a></li>
<li><a href="https://www.youtube.com/watch?v=RlIiVeig3hc">https://www.youtube.com/watch?v=RlIiVeig3hc</a></li>
<li><a href="https://kongdols-room.tistory.com/169">https://kongdols-room.tistory.com/169</a> </li>
<li><a href="https://www.delftstack.com/ko/howto/python-pandas/how-to-create-dataframe-column-based-on-given-condition-in-pandas/">https://www.delftstack.com/ko/howto/python-pandas/how-to-create-dataframe-column-based-on-given-condition-in-pandas/</a></li>
</ul>
]]></content>
      <categories>
        <category>Preprocessing</category>
      </categories>
      <tags>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]Iterator,Generator,yield에 대한 정리</title>
    <url>/2022/06/15/Programming-Python-Generator/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>Iterator,Generator,yield에 대한 정리</strong></p>
<hr>
<h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul>
<li><strong>Iterators are objects that allow you to traverse through all the elements of a collection and return one element at a time.</strong></li>
<li>iterator는 iterable로 생성되는 값을 순서대로 꺼낼 수 있는 객체이다,</li>
<li>iter(collections) : returns unmodified iterator</li>
<li>iter(<function>, to_exclusive) : A sequence of return values until ‘to_exclusive’</li>
<li>next(<iter>,default) :Raises StopIteration or returns ‘default’ on end.</li>
<li><list> &#x3D; list(<iter>) : Return a list of iterator’s remaining elements</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">temp = (<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>)</span><br><span class="line">myit = <span class="built_in">iter</span>(temp)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(myit))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">30</span>]: iv = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: io = <span class="built_in">iter</span>(iv)</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ...:     <span class="keyword">try</span>:</span><br><span class="line">    ...:</span><br><span class="line">    ...:         item = <span class="built_in">next</span>(io)</span><br><span class="line">    ...:         <span class="built_in">print</span>(item)</span><br><span class="line">    ...:     <span class="keyword">except</span> StopIteration:</span><br><span class="line">    ...:         <span class="keyword">break</span></span><br><span class="line">    ...:</span><br><span class="line">    ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="itertools"><a href="#itertools" class="headerlink" title="itertools"></a>itertools</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> count, repeat, cycle, chain, islice</span><br></pre></td></tr></table></figure>

<ul>
<li><code>count</code> :  count(시작, [step]) 의 함수로 시작 숫자부터 step만큼(없으면 1) 씩 무한히 증가하는 generator 반환</li>
<li><code>islice</code> : islice(iterable객체, [시작], 정지[,step])의 함수로, iterable한 객체를 특정 범위로 슬라이싱하고 iterator로 반환.</li>
<li><code>chain</code> : chain(<strong>iterable</strong>)은 iterable한 객체들을 인수로 받아 하나의 iterator로 반환</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># chain</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">e1 = [<span class="string">&#x27;Happiness&#x27;</span>,<span class="string">&#x27;Caring&#x27;</span>,<span class="string">&#x27;Energy&#x27;</span>]</span><br><span class="line">e2 = [<span class="string">&#x27;Fear&#x27;</span>,<span class="string">&#x27;Hurt&#x27;</span>,<span class="string">&#x27;Tired&#x27;</span>]</span><br><span class="line">emotions = chain(e1, e2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">next</span>(emotions) &gt;&gt;&gt; <span class="string">&#x27;Happiness&#x27;</span></span><br><span class="line"><span class="built_in">next</span>(emotions) &gt;&gt;&gt; <span class="string">&#x27;Caring&#x27;</span></span><br><span class="line"><span class="built_in">next</span>(emotions) &gt;&gt;&gt; <span class="string">&#x27;Energy&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.geeksforgeeks.org/python-itertools/">itertools</a></li>
<li><a href="https://realpython.com/python-itertools/">https://realpython.com/python-itertools/</a></li>
<li><a href="https://hamait.tistory.com/803">https://hamait.tistory.com/803</a></li>
</ul>
<p><strong>itertools.product를 활용한 이중 반복문 변형</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 기존 반복문</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> i_ex:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> j_ex:</span><br><span class="line">        <span class="built_in">print</span>(i,j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># itertools활용</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(i_ex, j_ex):</span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li><p>Any function that contains a yield statement returns a generator.</p>
</li>
<li><p>Generators and iterators are interchangeable.</p>
</li>
<li><p><strong>Generators are iterators, a kind of iterable you can only iterate over once. Generators do not store all the values in memory, they generate the values on the fly</strong></p>
</li>
<li><p>Lazy-evaluation : 값을 미리 생성하여 메모리에 저장하고 있는게 아니며, 요청이 있을 때마다  함수를 실행하고 값을 공급(yield)해 줌</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: my_gen = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">type</span>(my_gen)</span><br><span class="line">Out[<span class="number">2</span>]: generator</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> my_gen:</span><br><span class="line">   ...:     <span class="built_in">print</span>(i)</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>It is just the same except you used () instead of []. BUT, you cannot perform for i in generator a second time since <strong>generators can only be used once</strong>: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one</p>
<h4 id="yield-form"><a href="#yield-form" class="headerlink" title="yield form"></a>yield form</h4><ul>
<li><code>yield</code>는 <code>return</code>과 유사하지만 generator를 반환한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: <span class="keyword">def</span> <span class="title function_">gen_count</span>(<span class="params">start,step</span>):</span><br><span class="line">   ...:     <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   ...:         <span class="keyword">yield</span> start</span><br><span class="line">   ...:         start += step</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: counter = gen_count(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="built_in">next</span>(counter)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">10</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: <span class="built_in">next</span>(counter)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">12</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="built_in">next</span>(counter)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">14</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: <span class="built_in">next</span>(counter)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">16</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>yield from a</code>를 통해 <code>iterable</code>의 전체 요소들을 반환할 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">three_generator</span>():</span><br><span class="line"><span class="meta">... </span>    a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">yield</span> <span class="keyword">from</span> a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>gen = three_generator()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>(gen)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do">핵심 stackoverflow ref</a></li>
<li>Python Comprehensive Cheat Sheet</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]Graph와 Graph Representation의 이해</title>
    <url>/2022/06/15/Programming-Python-Graph-basic/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<h2 id="그래프"><a href="#그래프" class="headerlink" title="그래프"></a>그래프</h2><h3 id="Graph-Concept"><a href="#Graph-Concept" class="headerlink" title="Graph Concept"></a>Graph Concept</h3><hr>
<p><strong><em>Concept</em></strong></p>
<p>(용어정리)</p>
<ul>
<li><strong>그래프</strong> : node(점)와 edge(간선)으로 이루어진 자료구조 . 추상자료형에 해당한다.</li>
<li><strong>Directed Graph</strong> : edge가 방향성이 있을 경우. 기본적으로 엣지가 순서가 있는 쌍으로 표현된다. <ul>
<li>leaf : Directed Graph는 순서가 있으므로 마지막 노드가 있다. leaf는 마지막 노드를 뜻한다.</li>
</ul>
</li>
<li><strong>Undirected Graph</strong> : edge가 방향성이 없을 경우. <ul>
<li>관계의 목적이 <strong>상호교환</strong> 일 경우 <code>Undirected Graph</code>가 가장 적합하다.</li>
<li>항상 동일한 노드에 재방문 가능하기 때문에 순환 그래프에 속한다.</li>
<li>adjacency(인접) : 간선이 연결된 것</li>
<li>neighbor : 간선이 연결된 노드들을 이웃(neighbor) 이라고 한다.</li>
</ul>
</li>
<li><strong>Cyclic  Graph</strong> :그래프에 루프가 있을 경우<ul>
<li>loop : 방문한 노드에 재방문 가능할 경우</li>
</ul>
</li>
<li><strong>Weighted Graph</strong> : edge에 값(가중치)가 있을 경우. 최단거리 문제에 사용<ul>
<li>그래프에서 경로의 총 가중치가 높을 경우 비용이 늘어난다.</li>
</ul>
</li>
<li><strong>Directed Acyclic Graph</strong> : 그래프가 순환되지 않고 단방향일 경우. 선형정렬 가능</li>
<li>Adjacency List : 배열로 표현된 그래프 자료구조(연결리스트)</li>
<li>Adjacency Matrix : 2차원 배열로 표현된 그래프 자료구조</li>
</ul>
<hr>
<h3 id="Graph-Representation"><a href="#Graph-Representation" class="headerlink" title="Graph Representation"></a>Graph Representation</h3><ul>
<li>기본적으로 인접리스트와 인접행렬 두 가지 방법을 사용한다.</li>
</ul>
<h4 id="인접리스트-adjacency-list"><a href="#인접리스트-adjacency-list" class="headerlink" title="인접리스트(adjacency list)"></a>인접리스트(adjacency list)</h4><p><img src="https://cdncontribute.geeksforgeeks.org/wp-content/uploads/listadjacency.png"></p>
<ul>
<li>인접리스트는 그래프를 배열로 나타내는 방식이다.</li>
<li>인접리스트에서 그래프는 <code>전체 노드 목록</code>을 저장한다,<ul>
<li>배열의 크기는 노드의 수와 같다.</li>
<li>배열의 i 번째 엔트리는 i번째 노드와 인접노드의 값을 리스트로 저장한다.</li>
<li>Weighted Graph 일 경우 리스트에 값이 아닌 값과 가중치의 페어들이 저장된다.</li>
</ul>
</li>
</ul>
<p><img src="https://i.imgur.com/GiStmNh.jpg"></p>
<ul>
<li>Dictionarys로 인접리스트 구현하기<ul>
<li>vertices는 <strong>O(1)상수시간에 각 edge(간선)에 접근</strong>할 수 있다.</li>
<li>edge가 set에 포함되어 있기 때문에 O(1) 상수 시간에 edge가 있는지 확인할 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 위 그림에 대해 딕셔너리를 사용한 인접리스트 예시</span></span><br><span class="line"><span class="comment"># 노드가 키가 되고, 인접노드가 값이 되는 딕셔너리이다.</span></span><br><span class="line"><span class="comment"># 가장자리 노드들은 set으로 구현되어 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.vertices = &#123;</span><br><span class="line">                            <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>&#125;,   <span class="comment"># 여기서 &#123;&quot;B&quot;&#125;가 set의 형태이다.</span></span><br><span class="line">                            <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>&#125;, <span class="comment"># &#123;&quot;B&quot; : &#123;&#125;&#125;의 형태는 딕셔너리</span></span><br><span class="line">                            <span class="string">&quot;C&quot;</span>: &#123;<span class="string">&quot;E&quot;</span>&#125;,     <span class="comment"># 즉, 딕셔너리 안에 set이 있는 것이다.</span></span><br><span class="line">                            <span class="string">&quot;D&quot;</span>: &#123;<span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>&#125;,</span><br><span class="line">                            <span class="string">&quot;E&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">                            <span class="string">&quot;F&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>&#125;,</span><br><span class="line">                            <span class="string">&quot;G&quot;</span>: &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;F&quot;</span>&#125;</span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>List로 인접리스트 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 이웃노드를 반복적으로 접근해 탐색</span></span><br><span class="line"><span class="comment"># 시간복잡도(N)</span></span><br><span class="line"></span><br><span class="line">a,b,c,d,e,f = <span class="built_in">range</span>(<span class="number">6</span>) <span class="comment"># 6개노드</span></span><br><span class="line"></span><br><span class="line">N = [[b,c,d,f],[a,d,f],[a,b,c],[a,e],[b,c,d,e]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>class로 인접리스트 구현</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 기본적으로 연결리스트처럼 초기화 클래스가 필요하다.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">adjnode</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,data</span>):</span><br><span class="line">    self.node = data</span><br><span class="line">    self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,vertices</span>):</span><br><span class="line">    self.V = vertices</span><br><span class="line">    self.gragh = [<span class="literal">None</span>] * self.V</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">add_edge</span>(<span class="params">self,src,dest</span>):</span><br><span class="line">    <span class="comment"># 시작지점(src)에 노드 추가</span></span><br><span class="line">    <span class="comment"># 기본적으로 Undirected Graph를 만든다.</span></span><br><span class="line">    node = adjnode(dest)</span><br><span class="line">    <span class="comment"># 아래 코드로 두 노드를 연결시킨다.</span></span><br><span class="line">    node.<span class="built_in">next</span> = self.graph[src]</span><br><span class="line">    self.graph[src] = node</span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">print_graph</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.V):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">f&quot;노드 <span class="subst">&#123;i&#125;</span>의 인접리스트 \n&quot;</span>)</span><br><span class="line">      temp = self.graph[i]</span><br><span class="line">      <span class="keyword">while</span> temp:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;-&gt; <span class="subst">&#123;temp.node&#125;</span>&quot;</span>,end=<span class="string">&quot;&quot;</span> )</span><br><span class="line">        temp = temp.<span class="built_in">next</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">graph = Graph(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">graph.add_edge(<span class="number">0</span>,<span class="number">1</span>) <span class="comment"># </span></span><br><span class="line">graph.add_edge(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">graph.add_edge(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">graph.add_edge(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">graph.add_edge(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">graph.add_edge(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">graph.add_edge(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">graph.add_edge(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">노드 0의 인접리스트 </span><br><span class="line"></span><br><span class="line">-&gt; 4-&gt; 1</span><br><span class="line"></span><br><span class="line">노드 1의 인접리스트 </span><br><span class="line"></span><br><span class="line">-&gt; 4-&gt; 3-&gt; 2</span><br><span class="line"></span><br><span class="line">노드 2의 인접리스트 </span><br><span class="line"></span><br><span class="line">-&gt; 3</span><br><span class="line"></span><br><span class="line">노드 3의 인접리스트 </span><br><span class="line"></span><br><span class="line">-&gt; 4-&gt; 1</span><br><span class="line"></span><br><span class="line">노드 4의 인접리스트 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="인접행렬-adjacency-matrix"><a href="#인접행렬-adjacency-matrix" class="headerlink" title="인접행렬(adjacency matrix)"></a>인접행렬(adjacency matrix)</h4><ul>
<li><p>N * N 크기의 2차원 배열로 나타낸다.</p>
<ul>
<li>N 은 노드의 개수이다.</li>
</ul>
</li>
<li><p>인접행렬은 2차원 배열을 활용해 그래프를 표현한 것이다.</p>
<ul>
<li><code>adj[i][j] : 노드 i에서 노드 j로 가는 간선이 있으면 1, 아니면 0</code></li>
</ul>
</li>
<li><p>파이썬에서는 중첩리스트로 구현한다.</p>
</li>
<li><p>Undirected Graph의 인접행렬은 항상 대칭이다.</p>
</li>
<li><p>인접행령의 가중치를 추가할 경우 1과 0 값을 다른 숫자로 바꾼다.</p>
</li>
<li><p>인접행렬로 나타낸 그래프 구조들</p>
<img src="https://www.researchgate.net/publication/347300725/figure/fig1/AS:969208926044162@1608088823984/Different-types-of-graphs-and-their-corresponding-adjacency-matrix-representations-The.ppm" alt="700"/></li>
</ul>
<p><img src="https://i.imgur.com/GiStmNh.jpg" alt="https://i.imgur.com/GiStmNh.jpg"></p>
<ul>
<li>위 그래프를 인접행렬로 만들 경우 우선 아래와 같은 그림을 만들 수 있다.</li>
</ul>
<p><img src="https://github.com/Maiven/data-science/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF.png?raw=true" alt="https://github.com/Maiven/data-science/blob/main/%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%E1%84%92%E1%85%A2%E1%86%BC%E1%84%85%E1%85%A7%E1%86%AF.png?raw=true"></p>
<ul>
<li><p>List로 구현한 인접행렬</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 리스트로 구현한 인접행렬</span></span><br><span class="line"><span class="comment"># 아래 코드처럼 위의 간선 가중치는 1이다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>위에서 행렬은 리스트 안에 리스트가 있는 2차원 배열로 표현된다.</p>
<ul>
<li>구현을 통해 기본 제공되는 행렬 간에 **edge weights(간선 가중치)**를 알 수 있다.</li>
<li><strong>0은 관계가 없음</strong>을 나타내지만 다른 값은 <strong>edge label 또는 edge weight</strong>를 나타낸다.</li>
<li>인접행렬의 단점은 <strong>노드 값과 해당 인덱스 사이에 연관성이 없다</strong>는 것이다.</li>
</ul>
</li>
<li><p>실제로 인접리스트와 인접행렬을 모두 구현하면 Vertex(정점) 및 Edge(간선) 클래스를 포함하여 더 많은 정보를 파악할 수 있다.</p>
</li>
</ul>
<h4 id="Weighted-Graph-구현하기"><a href="#Weighted-Graph-구현하기" class="headerlink" title="Weighted Graph 구현하기"></a>Weighted Graph 구현하기</h4><ul>
<li>리스트로 그래프 가중치를 표현하는 것 보다 행렬로 구현하는 것이 쉽다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 인접리스트 구현</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.vertices = &#123;</span><br><span class="line">                            <span class="string">&quot;A&quot;</span>: &#123;<span class="string">&quot;B&quot;</span>: <span class="number">1</span>&#125;,  <span class="comment"># 가중치 부여</span></span><br><span class="line">                            <span class="string">&quot;B&quot;</span>: &#123;<span class="string">&quot;C&quot;</span>: <span class="number">3</span>, <span class="string">&quot;D&quot;</span>: <span class="number">2</span>&#125;,  <span class="comment"># 가중치 부여</span></span><br><span class="line">                            <span class="string">&quot;C&quot;</span>: &#123;&#125;,</span><br><span class="line">                            <span class="string">&quot;D&quot;</span>: &#123;&#125;,</span><br><span class="line">                            <span class="string">&quot;E&quot;</span>: &#123;<span class="string">&quot;D&quot;</span>: <span class="number">1</span>&#125;   <span class="comment"># 가중치 부여</span></span><br><span class="line">                        &#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 인접행렬 구현</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.edges = [[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>]]</span><br></pre></td></tr></table></figure>


<h3 id="그래프에서의-복잡도-계산"><a href="#그래프에서의-복잡도-계산" class="headerlink" title="그래프에서의 복잡도 계산"></a>그래프에서의 복잡도 계산</h3><ul>
<li>인접행렬은 특징은 <strong>구현이 쉽다</strong>는 것이다.<ul>
<li>때문에 인접행렬의 가장 큰 단점은 <strong>특정노드에 방문한 노드들을 알기 위해서는 모든 노드를 확인</strong>해야 한다는 것이다. (시간복잡도 O(N))</li>
<li>이러한 단점을 위해 인접리스트로 표현방식이 생겼다.</li>
</ul>
</li>
<li>인접리스트는 실제 연결된 관계만을 저장해주기 때문에 실행시간에 영향을 적게 준다.<ul>
<li>인접리스트의 단점은 <strong>특정 노드간의 연결관계를 확인하기 위해서는 반복문이 활용되어야 하며 따라서 O(N) 이상의 시간복잡도</strong> 가 발생한다는 것이다.</li>
</ul>
</li>
</ul>
<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://youtu.be/ofykE5elSfI">Graph Concept</a></li>
<li><a href="https://ratsgo.github.io/data%20structure&algorithm/2017/11/18/graph/">Graph Data Structure</a></li>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph Representaion</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>[Algorithm]Hash Table과 Hash에 대한 이해</title>
    <url>/2022/06/15/Programming-Python-hash-table/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->


<h3 id="Hash-table"><a href="#Hash-table" class="headerlink" title="Hash table"></a>Hash table</h3><hr>
<p><strong><em>Concept</em></strong></p>
<ul>
<li>hash function : 데이터의 효율적 관리를 목적으로 임의의 길의의 데이터를 고정된 길이의 데이터로 매핑하는 함수.<ul>
<li>key : 매핑 전 원래 데이터의 값</li>
<li>hashing value : 매핑 후 데이터의 값</li>
</ul>
</li>
<li>hash table : 해시함수를 이용해 키를 해시값으로 매핑하고 이 해시값을 index로 해서 데이터의 값을 키와 함께 빠르게 저장 및 검색할 수 있는 <strong>테이블 형태의 자료구조</strong></li>
<li>hashing : 매핑하는 과정 자체를 뜻한다.해싱은 기본적으로 다 흩뜨려놓고, 키와 매칭되는 값을 검색하는 과정이다.</li>
<li>hash collision(해시충돌) : 서로 다른 두개의 키에 대해 동일한 해시값을 내는 것</li>
<li>Load Factor : 해시테이블에 저장된 항목 수(테이블에 입력된 키 갯수)를 슬롯 수 (해시테이블 전체 인덱스 갯수)로 나눈 값</li>
</ul>
<hr>
<p>:hash table은 기본적으로 <strong>키를 활용하여 값에 직접 접근이 가능한 구조</strong> 이다.</p>
<ul>
<li><p>key : value system을 활용해 자료를 정리함</p>
<ul>
<li>-&gt; 데이터 양에 영향을 덜 받으며 성능이 빠르다.</li>
</ul>
</li>
<li><p>해싱의 목적은 기본적으로 <strong>검색</strong>이다. -&gt; 해시 테이블은 검색알고리즘의 역할도 한다.</p>
</li>
<li><p>Python Dictionary는 내부적으로 해시테이블 구조로 구현되어 있다.</p>
<ul>
<li>hash table은 검색을 위한 역할도 하고 딕셔너리를 위한 자료구조의 역할도 한다.</li>
</ul>
</li>
<li><p><strong>hash table 사용이유</strong></p>
<ul>
<li>기본적으로 적은 리소르로 많은 데이터를 효율적으로 관리할 수 있다<ul>
<li>하드디스크나 클라우드에 존재하는 데이터(키) 들을 유한한 개수의 해시값으로 매핑함으로써 작은 크기의 캐쉬메모리로도 프로세스를 관리할 수 있게 된다.</li>
<li><strong>index에 해시값을 사용함으로서 모든 데이터를 살피지 않아도 검색과 삽입&#x2F;삭제를 빠르게 수행할 수 있습니다.</strong></li>
<li>해시함수는 언제나 동일한 해시값을 리턴하고 해당 index만 알면 해시테이블 크기에 상관 없이 데이터에 빠르게 접근할 수 있다.<ul>
<li>index는 계산이 간단한 함수로 작동하기 때무에 매우 효율적이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>hash table in python</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># case 1 - 딕셔너리로 활용되는 hash table</span></span><br><span class="line"></span><br><span class="line">test_code = &#123;<span class="number">2.5</span>: <span class="string">&#x27;A&#x27;</span> ,<span class="string">&#x27;2.0&#x27;</span>: <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;1.0&#x27;</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(test_code[<span class="number">2.5</span>]) </span><br><span class="line"><span class="built_in">print</span>(test_code[<span class="string">&#x27;1.0&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(test_code[<span class="string">&#x27;2.0&#x27;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># case 2 - 리스트와 튜플을 활욯한 hash table</span></span><br><span class="line"><span class="comment"># 데이터는 튜플로 저장</span></span><br><span class="line"></span><br><span class="line">test_code = [(<span class="number">2.5</span>, <span class="string">&#x27;A&#x27;</span>), (<span class="string">&#x27;2.0&#x27;</span>, <span class="string">&#x27;B&#x27;</span>), (<span class="string">&#x27;1.0&#x27;</span>, <span class="string">&#x27;C&#x27;</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">item_list, key, value</span>):</span><br><span class="line">    item_list.append((key, value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">item_list, key</span>):</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> item_list:    </span><br><span class="line">        <span class="keyword">if</span> item[<span class="number">0</span>] == key:</span><br><span class="line">            <span class="keyword">return</span> item[<span class="number">1</span>]      </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;not matching&#x27;</span>)       </span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(search(test_code, <span class="string">&#x27;2.0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(search(test_code, <span class="number">2.5</span>))</span><br><span class="line">search(test_code, <span class="number">2.5</span>)    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>딕셔너리를 활용한  hash table의 이해</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 테이블에 값 할당</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line"><span class="built_in">dict</span>[<span class="string">&#x27;c&#x27;</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dict</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># hash table에 반복문 적용</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="built_in">dict</span>.keys():</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">dict</span>[key])</span><br><span class="line"></span><br><span class="line"><span class="comment"># &#123;키, 쌍&#125; 출력</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">f&quot;key : <span class="subst">&#123;k&#125;</span> , value : <span class="subst">&#123;v&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="hash-function"><a href="#hash-function" class="headerlink" title="hash function"></a>hash function</h4><ul>
<li>해시함수는 보통 문자열 입력값에 정수형 출력값을 반환한다.</li>
<li>정수형에서 문자열로 변환하기 위해 해시함수는 문자열에 해당하는 개별 단어들을 활용한</li>
<li>삽입, 검색, 삭제 무엇을 하든지 해시함수는 키를 통해 저장된 값에 연관된 인덱스를 반환한다.(키와 인덱스가 매칭되어야 한다.)<ul>
<li>-&gt; 만약 해시테이블이 하나의 요소를 갖고 잇다면, 해시테이블 인덱스 갯수에 관계 겂이 프로그래밍 수행시간이 비슷하다</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 굳이 리스트로 hash를 구현할 경우</span></span><br><span class="line"><span class="comment"># 파이썬의 hash table 은 Dictionary이다.</span></span><br><span class="line"><span class="comment"># Dictionary method로 삽입, 삭제, 검색을 수행할 수 있다.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hash_func</span>(<span class="params"><span class="built_in">str</span>,list_size</span>):</span><br><span class="line">    bytes_repr = <span class="built_in">str</span>.encode()</span><br><span class="line"></span><br><span class="line">    <span class="comment">#print(f&quot;str : &#123;str&#125;&quot;)</span></span><br><span class="line">    <span class="comment">#print(f&quot;str_encode : &#123;str.encode()&#125;&quot;)</span></span><br><span class="line">    <span class="comment">#print(f&quot;byte_repr : &#123;bytes_repr&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes_repr:</span><br><span class="line">        <span class="built_in">sum</span> += byte</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span> % list_size</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = [<span class="literal">None</span>] * <span class="number">5</span> <span class="comment"># 리스트 초기화: 중요 테크닉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list[hash_func(<span class="string">&quot;aqua&quot;</span>,<span class="built_in">len</span>(my_list))] = <span class="string">&quot;#00FFFF&quot;</span> <span class="comment"># 삽입</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#print(my_list[hash_func(&quot;aqua&quot;,len(my_list))]) # 리스트 값 출력</span></span><br><span class="line"><span class="built_in">print</span>(my_list[hash_func(<span class="string">&quot;aqua&quot;</span>,<span class="built_in">len</span>(my_list))])</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br><span class="line"><span class="comment"># print(hash_func(&quot;aqua&quot;,len(my_list)))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Python Hash table 구현하기</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python hash table 구현</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">hash_table</span>:</span><br><span class="line">    <span class="comment"># 키에 따른 값 초기화</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.table = [<span class="literal">None</span>] * <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 기능3) name에 따라 특정값을 반환해주는 해시함수</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_function</span>(<span class="params">self, name</span>):</span><br><span class="line">        table_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        encoded = name.encode() <span class="comment"># 문자열을 </span></span><br><span class="line">        <span class="keyword">for</span> byte <span class="keyword">in</span> encoded:</span><br><span class="line">            table_sum += byte</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> table_sum % <span class="built_in">len</span>(self.table) <span class="comment"># 반환된 정수 값이 리스틔 인덱스(키) 가 된다</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># name에 따라 num이 매칭되게끔 삽입</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_insert</span>(<span class="params">self, name, num</span>):</span><br><span class="line">        hash_key = self.hash_function(name) <span class="comment">#</span></span><br><span class="line">        self.table[hash_key] = num <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># name에 따라 매칭되는 num 검색</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hash_search</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> self.table[self.hash_function(name)]</span><br><span class="line"></span><br><span class="line">ht = hash_table()</span><br><span class="line"></span><br><span class="line">ht.hash_insert(<span class="string">&#x27;Kim&#x27;</span>, <span class="number">1234</span>)</span><br><span class="line">ht.hash_insert(<span class="string">&#x27;Johne&#x27;</span>, <span class="number">5678</span>)</span><br><span class="line">ht.hash_insert(<span class="string">&#x27;Smith&#x27;</span>, <span class="number">1526</span>)</span><br><span class="line">ht.hash_insert(<span class="string">&#x27;Michael&#x27;</span>, <span class="number">3748</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(ht.hash_search(<span class="string">&#x27;Johne&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="hash-충돌"><a href="#hash-충돌" class="headerlink" title="hash 충돌"></a>hash 충돌</h4><ul>
<li><p>해시함수가 서로 다른 두 개의 키에 대해 동일한 해시값을 내는 것을 해시 충돌이라고 한다.</p>
</li>
<li><p>해시충돌은 보통 해쉬값의 개수보다 많은 키값을 해쉬값으로 변환하는 일대다 대응 때문에 발생한다.</p>
<ul>
<li>키가 들어갈 자리(버킷)이 없는 경우에 발생한다.</li>
</ul>
</li>
<li><p>아래 그림의 경우 Sandra와 Jonn의 키가 같아 버킷 152에서 충돌이 발생한다.</p>
</li>
</ul>
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Hash_table_5_0_1_1_1_1_1_LL.svg/675px-Hash_table_5_0_1_1_1_1_1_LL.svg.png" alt="700"/>


<h4 id="hash-충돌-방지-chaining-활용"><a href="#hash-충돌-방지-chaining-활용" class="headerlink" title="hash 충돌 방지 - chaining 활용"></a>hash 충돌 방지 - chaining 활용</h4><ul>
<li>chaining은 충돌이 발생한 위 그림처럼 해시테이블에서 동일한 해시 값에 대해 충돌이 일어나면, 해당 위치에 있던 버킷에 키값을 뒤이어 연결하는 것이다.</li>
<li>이때 데이터는 <strong>해시값이 같은 노드를 연결하는</strong> 연결리스트의 형태를 가진다.<ul>
<li>따라서 특정 해시값에 대해 충돌이 발생하여도, 체이닝을 통해 값을 찾을 수 있다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># python hashtable chaining 구현</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain_hash_table = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chain_hash_func</span>():</span><br><span class="line">  <span class="keyword">return</span> key % <span class="built_in">len</span>(chain_hash_table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 키 값 쌍을 해시테이블에 삽입</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">chain_insert_func</span>(<span class="params">chain_hash_table, key, value</span>):</span><br><span class="line">  hash_key = chain_hash_func(key)</span><br><span class="line">  chain_hash_table[hash_key].extend(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chain_insert_func(chain_hash_table,<span class="number">20</span>,<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(chain_hash_table)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="hash-충돌-방지-open-addressing"><a href="#hash-충돌-방지-open-addressing" class="headerlink" title="hash 충돌 방지 - open addressing"></a>hash 충돌 방지 - open addressing</h4><ul>
<li><p>하나의 버켓에 하나의 entry만 들어갈 수 있는 형태이다.(저장공간이 정해져있다.)</p>
</li>
<li><p>기본적인 로직은 비어있는 배열 슬롯이 발견될 때까지 배열의 위치를 검색하는 것이다.</p>
</li>
<li><p>Chaining은 연결문제를 해결하여 충돌을 해결하고 Open Addressing은 내부적으로 공간이 정해진 배열을 활용하여 빈공간을 찾는 식으로 충돌을 해결한다.</p>
</li>
<li><p>close hashing이라고도 불린다.</p>
</li>
<li><p>파이썬 자료형으로 구현된 hash table이 Dictionary이다.</p>
</li>
<li><p>Dictioanary는 내부적으로 open addressing 방식을 활용한다.</p>
</li>
<li><p><strong>로드 팩터</strong> : (Number of items in hash table) &#x2F; (Total Number of Slots)</p>
<ul>
<li>해시테이블에 저장된 항목 수(테이블에 입력된 키 갯수)를 슬롯 수 (해시테이블 전체 인덱스 갯수)로 나눈 값</li>
<li>open addressing을 사용하면 최대 로드 팩터는 1정도 나온다.</li>
<li>체이닝을 사용할 경우 로드 팩터는 open addressing보다 좋은 성능을 보인다.</li>
<li>로드 팩터를 낮추면 해시에 대한 성능이 올라간다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 파이썬으로 구현한 open addressing</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">open_address</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, table_size</span>):</span><br><span class="line">        self.size = table_size</span><br><span class="line">        self.hash_table = [<span class="number">0</span> <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(self.size)]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKey</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.key = <span class="built_in">ord</span>(data[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.key</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hashFunction</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="keyword">return</span> key % self.size</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getAddress</span>(<span class="params">self, key</span>):</span><br><span class="line">        myKey = self.getKey(key)</span><br><span class="line">        hash_address = self.hashFunction(myKey)</span><br><span class="line">        <span class="keyword">return</span> hash_address</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self, key, value</span>):</span><br><span class="line">        hash_address = self.getAddress(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.hash_table[hash_address] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(hash_address, <span class="built_in">len</span>(self.hash_table)):</span><br><span class="line">                <span class="keyword">if</span> self.hash_table[a] == <span class="number">0</span>:</span><br><span class="line">                    self.hash_table[a] = [key, value]</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> self.hash_table[a][<span class="number">0</span>] == key:</span><br><span class="line">                    self.hash_table[a] = [key, value]</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.hash_table[hash_address] = [key, value]</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">self, key</span>):</span><br><span class="line">        hash_address = self.getAddress(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(hash_address, <span class="built_in">len</span>(self.hash_table)):</span><br><span class="line">            <span class="keyword">if</span> self.hash_table[a][<span class="number">0</span>] == key:</span><br><span class="line">                <span class="keyword">return</span> self.hash_table[a][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">self, key</span>):</span><br><span class="line">        hash_address = self.getAddress(key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(hash_address, <span class="built_in">len</span>(self.hash_table)):</span><br><span class="line">            <span class="keyword">if</span> self.hash_table[a] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> self.hash_table[a][<span class="number">0</span>] == key:</span><br><span class="line">                self.hash_table[a] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">#Test Code</span></span><br><span class="line"><span class="comment">#h_table = CloseHash(8)</span></span><br><span class="line"></span><br><span class="line">h_table = open_address(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">data1 = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">data2 = <span class="string">&#x27;ad&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">ord</span>(data1[<span class="number">0</span>]), <span class="built_in">ord</span>(data2[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">h_table.save(<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;3333&#x27;</span>)</span><br><span class="line">h_table.save(<span class="string">&#x27;ad&#x27;</span>, <span class="string">&#x27;9999&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(h_table.hash_table)</span><br><span class="line"></span><br><span class="line">h_table.read(<span class="string">&#x27;ad&#x27;</span>)</span><br><span class="line"></span><br><span class="line">h_table.delete(<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(h_table.hash_table)</span><br><span class="line"></span><br><span class="line">h_table.delete(<span class="string">&#x27;ad&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(h_table.hash_table)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Hash_table">hash table wikipedia</a></li>
<li><a href="https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/">참조 블로그</a></li>
<li><a href="http://wiki.hash.kr/index.php/%ED%95%B4%EC%8B%9C_%ED%85%8C%EC%9D%B4%EB%B8%94">hashnet hash</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithm</tag>
        <tag>Data Structure</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]자주쓰는 High Order 함수 정리(lambda,map,filter,apply..)</title>
    <url>/2022/06/15/Programming-Python-lambda-highorder/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p>for loop과 조건문 만으로도 동일한 결과를 낼 수 있지만 <strong>가독성, 속도, 재사용성</strong> 때문애 고차함수를 사용해 프로그래밍을 하는 경우가 많다.<br>특히 lambda는 데이터 전처리시 자주 사용한다.</p>
<hr>
<h3 id="High-order-function"><a href="#High-order-function" class="headerlink" title="High order function"></a>High order function</h3><p>Higher-order Function(고차 함수)</p>
<p><strong>함수의 매개변수의 인수로 전달이 될수 있고 함수로 결과를 반환할 수 있는 함수를 말한다.</strong></p>
<p>(First-class Function이 성립되는 3조건 중 2개만 만족한다.)</p>
<p>대표적인 함수로는 map, filter, reduce, lambda 등이 있다.</p>
<h4 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h4><ul>
<li><code>lambda 인자 : 표현식</code> 형태로 사용한다.</li>
<li>lambda 함수 자체가 파이썬에서 정의된 함수처럼 기능한다고 생각하면 편하다.</li>
<li>간단한 기능의 함수가 컨테이너의 요소로 들어가거나 다른 함수(high order function)의 인자로 함수를 넘길때 주로 사용한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lambda 예시</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: double = <span class="keyword">lambda</span> x : x+x</span><br><span class="line">   ...: <span class="built_in">print</span>(double(<span class="number">2</span>))</span><br><span class="line">   ...:</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>단일 값에 lambda 적용하기</p>
</li>
<li><p>lambda 자체를 변수에 바인딩하여 사용 가능하다.</p>
<ul>
<li><code>PEP8</code>에 어긋나기 때문에 별로 권장하지 않는다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: temp = <span class="keyword">lambda</span> x,y : x*y</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: temp(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: temp(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">500</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>lamda로 필터링한 파생변수 만들기</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Conditional Lambda statement</span></span><br><span class="line">df[<span class="string">&#x27;Gender&#x27;</span>] = df[<span class="string">&#x27;Status&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="string">&#x27;Male&#x27;</span> <span class="keyword">if</span> x==<span class="string">&#x27;father&#x27;</span> <span class="keyword">or</span> x==<span class="string">&#x27;son&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;Female&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul>
<li><code>filter(조건함수,iterable</code>)</li>
<li>특정 조건에 따라 필터된 요소들로 <code>iterator</code> 객체를 만들어 반환한다.<ul>
<li><code>map</code>과 마찬가지로 list형태로 만들어 결과를 볼 수 있다.</li>
</ul>
</li>
<li>조건에 따라 iterable에서 일부를 뽑을 때 사용한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lamdas in filter</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: even = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x : x%<span class="number">2</span> == <span class="number">0</span> ,<span class="built_in">range</span>(<span class="number">10</span>)))</span><br><span class="line">   ...: <span class="built_in">print</span>(even)</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># lamdas in filter2 </span></span><br><span class="line">sequences = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">filtered_result = <span class="built_in">filter</span> (<span class="keyword">lambda</span> x: x &gt; <span class="number">4</span>, sequences) </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(filtered_result))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li>보통은 filter 대신 <code>list comprehension</code> 같은 보다 pythonic한 방법을 사용해 iterable에서 일부를 필터링 한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># list comprehension을 활용한 filter</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: even = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>) <span class="keyword">if</span> x %<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">   ...: <span class="built_in">print</span>(even)</span><br><span class="line">   ...:</span><br><span class="line">[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>dataframe</code>에서 파생변수를 만들때 쓰기 좋다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x&gt;<span class="number">18</span>, df[<span class="string">&#x27;age&#x27;</span>]))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><ul>
<li><code>map(func,list)</code> 형태로 사욯한다.</li>
<li><code>iterable</code>의 각 원소에 대해 함수를 적용시킨다.</li>
<li>map함수 자체는 <code>map</code> 타입으로 결과를 리턴하기에 함수가 적용된 결과를 리스트로 받으려면 내장함수 <code>list()</code>를 사용해야 한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+x, <span class="built_in">range</span>(<span class="number">5</span>))</span><br><span class="line">Out[<span class="number">2</span>]: &lt;<span class="built_in">map</span> at <span class="number">0x2446499e640</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x+x,<span class="built_in">range</span>(<span class="number">5</span>)))</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>map with lambda</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">4</span>]: sequences = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">   ...: filtered_result = <span class="built_in">map</span> (<span class="keyword">lambda</span> x: x*x, sequences)</span><br><span class="line">   ...: <span class="built_in">print</span>(<span class="built_in">list</span>(filtered_result))</span><br><span class="line">   ...:</span><br><span class="line">[<span class="number">100</span>, <span class="number">4</span>, <span class="number">64</span>, <span class="number">49</span>, <span class="number">25</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">121</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>dataframe</code>의 <code>series</code> 객체에 적용해 파생변수를 생성힐때 유용하다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#Double the age </span></span><br><span class="line">df[<span class="string">&#x27;double_age&#x27;</span>] = df[<span class="string">&#x27;age&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><ul>
<li><code>reduce(func,sequence)</code> 형태로 사용한다.</li>
<li>iterable의 요소들을 함수에 누적해서 적용 후 반환한다.</li>
<li><strong><code>iterable</code>의 순회가 끝날때까지 재귀적으로 함수를 적용한다고 생각하면 이해가 쉽다.</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]:  <span class="keyword">def</span> <span class="title function_">my_add</span>(<span class="params">a, b</span>):</span><br><span class="line">   ...:      result = a + b</span><br><span class="line">   ...:      <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span> + <span class="subst">&#123;b&#125;</span> = <span class="subst">&#123;result&#125;</span>&quot;</span>)</span><br><span class="line">   ...:      <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">0</span>,<span class="number">11</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: reduce(my_add,numbers)</span><br><span class="line"><span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line"><span class="number">3</span> + <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">6</span> + <span class="number">4</span> = <span class="number">10</span></span><br><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">15</span> + <span class="number">6</span> = <span class="number">21</span></span><br><span class="line"><span class="number">21</span> + <span class="number">7</span> = <span class="number">28</span></span><br><span class="line"><span class="number">28</span> + <span class="number">8</span> = <span class="number">36</span></span><br><span class="line"><span class="number">36</span> + <span class="number">9</span> = <span class="number">45</span></span><br><span class="line"><span class="number">45</span> + <span class="number">10</span> = <span class="number">55</span></span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">55</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>초기값(함수를 적용하기 시직할 지점)을 추가 인자로 넣어줄 수 있다.</p>
</li>
<li><p><strong>reduce에 lambda 적용</strong></p>
<ul>
<li>코드 가독성을 해치기 때문에 그다지 권장되지 않는다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: numbers = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: reduce(<span class="keyword">lambda</span> x,y :x*y,numbers)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">120</span></span><br></pre></td></tr></table></figure>


<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><ul>
<li>pandas의 dataframe의 행이나 열 단위로 함수를 적용하는 함수이다. <code>map</code> 과 유사하지만 df의 메소드로 보다 쉽게 쓸 수 있다.</li>
<li><code>df.apply(func, axis = 0 or 1 )</code> 형태로 사용한다<ul>
<li>axis &#x3D; 0 . 열단위로 함수 적용. default 옵션</li>
<li>axis &#x3D; 1 . 행단위로 함수적용</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: df</span><br><span class="line">Out[<span class="number">3</span>]:</span><br><span class="line">    A   B</span><br><span class="line"><span class="number">0</span>  <span class="number">16</span>  <span class="number">81</span></span><br><span class="line"><span class="number">1</span>  <span class="number">16</span>  <span class="number">81</span></span><br><span class="line"><span class="number">2</span>  <span class="number">16</span>  <span class="number">81</span></span><br><span class="line"><span class="number">3</span>  <span class="number">16</span>  <span class="number">81</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 열단위 함수적용</span></span><br><span class="line">In [<span class="number">6</span>]: df.apply(np.<span class="built_in">sum</span>,axis=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">6</span>]:</span><br><span class="line">A     <span class="number">64</span></span><br><span class="line">B    <span class="number">324</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br><span class="line"><span class="comment"># 행단위 함수적용</span></span><br><span class="line">In [<span class="number">7</span>]: df.apply(np.<span class="built_in">sum</span>,axis=<span class="number">1</span>)</span><br><span class="line">Out[<span class="number">7</span>]:</span><br><span class="line"><span class="number">0</span>    <span class="number">97</span></span><br><span class="line"><span class="number">1</span>    <span class="number">97</span></span><br><span class="line"><span class="number">2</span>    <span class="number">97</span></span><br><span class="line"><span class="number">3</span>    <span class="number">97</span></span><br><span class="line">dtype: int64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>lambda with apply 예시</strong><ul>
<li>df의 파생변수 생성에 유용하다.</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">df[<span class="string">&#x27;age&#x27;</span>] = df[<span class="string">&#x27;Birthyear&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">2021</span>-x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="applymap"><a href="#applymap" class="headerlink" title="applymap"></a>applymap</h4><ul>
<li><code>df.applymap(func)</code> 형태로 사용항다.</li>
<li><strong>df의 모든 요소에 인자로 주어진 함수를 적용한다.</strong></li>
<li>na_action&#x3D;’ignore’ 옵션을 적용할 경우 null값에 대해서는 함수를 적용하지 않는다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: <span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">   ...:</span><br><span class="line">   ...: df = pd.DataFrame(&#123;</span><br><span class="line">   ...:     <span class="string">&#x27;Col 1&#x27;</span>: [<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>],</span><br><span class="line">   ...:     <span class="string">&#x27;Col 2&#x27;</span>: [<span class="number">23</span>,<span class="number">35</span>,<span class="number">65</span>,<span class="number">45</span>],</span><br><span class="line">   ...:     <span class="string">&#x27;Col 3&#x27;</span>: [<span class="number">85</span>,<span class="number">87</span>,<span class="number">90</span>,<span class="number">89</span>],</span><br><span class="line">   ...:</span><br><span class="line">   ...: &#125;,index=[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>])</span><br><span class="line">   ...:</span><br><span class="line">   ...: <span class="built_in">print</span>(<span class="string">&quot;Initial DF:&quot;</span>)</span><br><span class="line">   ...: <span class="built_in">print</span>(df,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">   ...:</span><br><span class="line">   ...: scaled_df=df.applymap(<span class="keyword">lambda</span> a: a*<span class="number">10</span>)</span><br><span class="line">   ...:</span><br><span class="line">   ...: <span class="built_in">print</span>(<span class="string">&quot;Scaled DF:&quot;</span>)</span><br><span class="line">   ...: <span class="built_in">print</span>(scaled_df,<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">Initial DF:</span><br><span class="line">   Col <span class="number">1</span>  Col <span class="number">2</span>  Col <span class="number">3</span></span><br><span class="line">A     <span class="number">30</span>     <span class="number">23</span>     <span class="number">85</span></span><br><span class="line">B     <span class="number">40</span>     <span class="number">35</span>     <span class="number">87</span></span><br><span class="line">C     <span class="number">50</span>     <span class="number">65</span>     <span class="number">90</span></span><br><span class="line">D     <span class="number">60</span>     <span class="number">45</span>     <span class="number">89</span></span><br><span class="line"></span><br><span class="line">Scaled DF:</span><br><span class="line">   Col <span class="number">1</span>  Col <span class="number">2</span>  Col <span class="number">3</span></span><br><span class="line">A    <span class="number">300</span>    <span class="number">230</span>    <span class="number">850</span></span><br><span class="line">B    <span class="number">400</span>    <span class="number">350</span>    <span class="number">870</span></span><br><span class="line">C    <span class="number">500</span>    <span class="number">650</span>    <span class="number">900</span></span><br><span class="line">D    <span class="number">600</span>    <span class="number">450</span>    <span class="number">890</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul>
<li><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.applymap.html#pandas.DataFrame.applymap">pandas 공식문서</a></li>
<li><a href="https://towardsdatascience.com/lambda-functions-with-practical-examples-in-python-45934f3653a8">lambda</a></li>
<li><a href="https://realpython.com/python-reduce-function/">reduce</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python] asterisk를 활용한 unpacking</title>
    <url>/2022/06/15/Programming-Python-unpacking/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling

ience-interview-questions.html
-->

<p><strong>asterisk를 활용한 Unpacking을 간단히 정리</strong></p>
<p>Python에서 <code>*</code>(asterisk)를 쓰는 방법은 크게 3가지이다.</p>
<ul>
<li><p><strong>function call 할때 인자를 unpacking 하기</strong> </p>
<ul>
<li><code>*</code> 연산자는 리스트 또는 튜플과 같은 iterable을 unpack한다</li>
<li><code>**</code> 연산자는 dictionary를 펑션에 필요한 인수로 unpack한다.</li>
</ul>
</li>
<li><p><strong>Variadic Parameters(가변인자) 사용하기</strong></p>
<ul>
<li>positional arguments 나 keyword arguments(dictionary 형태)를 여러개 받고 싶을 때 사용한다</li>
</ul>
</li>
<li><p><strong>곱셈, 거듭제곱의 연산자로 사용</strong></p>
</li>
</ul>
<p>여기서는 일단 iterable에 unpacking을 적용하는 것 중심으로 작성한다.</p>
<hr>
<h2 id="unpacking-parameters"><a href="#unpacking-parameters" class="headerlink" title="unpacking parameters"></a>unpacking parameters</h2><ul>
<li>5개의 positional argument를 받는 함수가 있을 때 unpacking을 활용해 보다 간소화해서 실행할 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">num_sum</span>(<span class="params">num1,num2,num3,num4,num5</span>):</span><br><span class="line">    <span class="keyword">return</span> num1 + num2 + num3 + num4 + num5</span><br><span class="line"></span><br><span class="line">num_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">num_sum(*num_list) <span class="comment"># 1+2+3+4+5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="iterable의-데이터를-unpacking하기"><a href="#iterable의-데이터를-unpacking하기" class="headerlink" title="iterable의 데이터를 unpacking하기"></a>iterable의 데이터를 unpacking하기</h2><ul>
<li><p>list unpacking</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(*test) <span class="comment"># 1 2 3 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>tuple unpacking</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = (<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(*test) <span class="comment"># 5 6 7 8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>unpacking 을 활용해 iterable을 여러 부분으로 나눌 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># unpacking의 좌변은 iterable의 형태를 가져야 한다,</span></span><br><span class="line"></span><br><span class="line">*a, = num</span><br><span class="line"><span class="comment"># a = [2, 3, 4, 5, 6 ,7]</span></span><br><span class="line"></span><br><span class="line">*a, b = num</span><br><span class="line"><span class="comment"># a = [2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># b = 7</span></span><br><span class="line"></span><br><span class="line">a, *b, = num</span><br><span class="line"><span class="comment"># a = 2</span></span><br><span class="line"><span class="comment"># b = [3, 4, 5, 6, 7]</span></span><br><span class="line"></span><br><span class="line">a, *b, c = num</span><br><span class="line"><span class="comment"># a = 2</span></span><br><span class="line"><span class="comment"># b = [3, 4, 5, 6]</span></span><br><span class="line"><span class="comment"># c = 7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>dictionary unpacking 예시</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dct = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">3</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">5</span>,<span class="string">&#x27;d&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"></span><br><span class="line">res = [*<span class="built_in">map</span>(dct.get,lst)] <span class="comment"># unpacking</span></span><br><span class="line"></span><br><span class="line">res2 = <span class="built_in">map</span>(dct.get,lst)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 각 인자를 unpacking해서 출력</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res2:</span><br><span class="line">      <span class="built_in">print</span>(i) <span class="comment"># 3, 3, 5 ,3 </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="multiple-list를-합치기"><a href="#multiple-list를-합치기" class="headerlink" title="multiple list를 합치기"></a>multiple list를 합치기</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">num_list = [1,2,3,4,5]</span><br><span class="line">num_list2 = [6,7,8,9,10]</span><br><span class="line"></span><br><span class="line">new_list = [*num_list, *num_list_2]</span><br><span class="line"># [1,2,3,4,5,6,7,8,9,10]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/">https://treyhunner.com/2018/10/asterisks-in-python-what-they-are-and-how-to-use-them/</a></li>
<li><a href="https://mingrammer.com/understanding-the-asterisk-of-python/">https://mingrammer.com/understanding-the-asterisk-of-python/</a></li>
<li><a href="https://towardsdatascience.com/unpacking-operators-in-python-306ae44cd480">https://towardsdatascience.com/unpacking-operators-in-python-306ae44cd480</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]for-loop관련 함수들</title>
    <url>/2022/06/15/Programming-Python-zip-enumerate/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->


<ul>
<li>대부분의 문제는 반복문과 제어문을 잘 쓰면 어떻게든 해결이 된다.</li>
<li>for loop에 자주쓰이는 유용한 내장함수로 zip과 enumerate가 있다.</li>
<li>itertools를 활욯해 반복문의 코드 가독성을 높일 수 있다.</li>
</ul>
<hr>
<h2 id="for-loop"><a href="#for-loop" class="headerlink" title="for-loop"></a>for-loop</h2><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><ul>
<li>같은 크기의 여러 <code>iterable</code>를 한 쌍으로 묶은 뒤 tuple의 형태로 접근할 수 있는 <code>iterator</code>를 반환한다.</li>
<li>2개 이상의 인자를 넘겨서 병렬처리가 가능하다(가변인자를 받는다.)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">name = [<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">zip</span>(num, name):</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>zip으로 쉽게 dictionary를 만들 수 있다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">food = [<span class="string">&#x27;beef&#x27;</span>, <span class="string">&#x27;chicken&#x27;</span>]</span><br><span class="line">count = [<span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">stock = <span class="built_in">dict</span>(<span class="built_in">zip</span>(food, count))</span><br><span class="line"></span><br><span class="line"><span class="comment"># dictionary comprehension을 사욯할 경우</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stock2 = &#123;k:v*<span class="number">2</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">zip</span>(food, count)&#125; <span class="comment"># stock이 2배 늘어남</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stock)</span><br><span class="line"><span class="built_in">print</span>(stock2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><code>*</code> 연산자를 사용해 unzip이 가능하다</li>
<li><code>*</code> 은 iterable의 각 요소를 분리하는 역할을 한다.<ul>
<li><ul>
<li>(a, b, c, d) 는 a,b,c,d 각각을 분리한 것과 같다.</li>
</ul>
</li>
</ul>
</li>
<li>zip(* zipped) 는 배열의 각 요소들을 분리한 다음 페어로 다시 묶은 것이다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b,c,d=<span class="built_in">zip</span>(*a) <span class="comment"># 배열을 페어링</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: b</span><br><span class="line">Out[<span class="number">12</span>]: (<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: c</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: d</span><br><span class="line">Out[<span class="number">14</span>]: (<span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h4><ul>
<li><strong>Get the element and index from a list</strong></li>
<li><code>iterable</code>에 사용한다. <code>iterable</code>의 인덱스와 원소를 튜플형태로 반환한다.</li>
<li><code>zip</code>과 다른 것은 배열을 묶는게 아니라 배열의 인덱스를 원소와 함께 묶은 <code>iterator</code>를 반환한다는 것.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">enumerate</span>(lst):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line">(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>zip()과 enumerate() 활용</strong></p>
<ul>
<li>인덱스와 배열을 묶은 값을 모두 반환해야 할경우 zip과 enumerate를 같이 사용한다.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Chris&#x27;</span>]</span><br><span class="line">ages = [<span class="number">18</span>, <span class="number">20</span>, <span class="number">24</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, (name, age) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(names, ages)):</span><br><span class="line">    <span class="built_in">print</span>(i, name, age)</span><br><span class="line"><span class="comment"># 0 Alice 18</span></span><br><span class="line"><span class="comment"># 1 Bob 20</span></span><br><span class="line"><span class="comment"># 2 Chris 14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="itertools를-활용한-반복문-응용"><a href="#itertools를-활용한-반복문-응용" class="headerlink" title="itertools를 활용한 반복문 응용"></a>itertools를 활용한 반복문 응용</h3><p><strong>itertools.product를 활용한 이중 반복문 변형</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 기존 반복문</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> i_ex:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> j_ex:</span><br><span class="line">        <span class="built_in">print</span>(i,j)</span><br><span class="line"></span><br><span class="line"><span class="comment"># itertools활용</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> itertools.product(i_ex, j_ex):</span><br><span class="line">    <span class="built_in">print</span>(i, j)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>References &amp; annotation</strong></p>
<ul>
<li><a href="https://stackoverflow.com/questions/5917522/unzipping-and-the-operator">unzipping 연산자</a></li>
<li><a href="https://www.geeksforgeeks.org/python-itertools/">itertools</a></li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>[Python]Regex 정리</title>
    <url>/2022/06/15/Programming-python-regex/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Data Extraction & Wrangling


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>굵은 글씨로 뭔가 쓴다.</strong></p>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2>]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>[R]특별한 R 연산자들(Binary Operators)</title>
    <url>/2021/03/02/R-Programming-operators/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>R로 분석을 하다보면 자연스럽게 손에 익게 되는 몇가지 연산자들이 있습니다. 이 포스팅에서는 R에서 사용되는 특별한 연산자들과 특정 연산자를 단축키로 Rstudio에 추가하는 법을 다룹니다.</p>
<hr>
<h2 id="연산자들"><a href="#연산자들" class="headerlink" title="연산자들"></a>연산자들</h2><h3 id="in-matching-연산자"><a href="#in-matching-연산자" class="headerlink" title="%in% (matching 연산자)"></a>%in% (matching 연산자)</h3><p><strong>특정 vector 내에 원하는 요소가 있는지 확인하고 이를 반환할 때 사용합니다.</strong><br>x%in%y 일 경우 x 기준으로 y와 매칭되는 값에 대한 논리값을 반환합니다.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">a <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">b <span class="operator">&lt;-</span> seq<span class="punctuation">(</span><span class="number">3</span><span class="punctuation">,</span> <span class="number">12</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> b <span class="operator">%in%</span> a  </span><br><span class="line"> <span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span></span><br><span class="line"><span class="operator">&gt;</span> a <span class="operator">%in%</span> b</span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span> <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure>


<h3 id="gt-pipe"><a href="#gt-pipe" class="headerlink" title="%&gt;% (pipe)"></a>%&gt;% (pipe)</h3><p>tidyverse에 포함되어 있어 아마도 가장 유명할 연산자인 pipe operator입니다. </p>
<p>자주 쓰이기 때문에 Rstudio에 ctrl+shift+m으로 단축키가 지정되어 있습니다.</p>
<p><strong>기능은 함수들을 연결해 직관적으로 전달하는 것입니다.</strong><br>f(g(x)) 와 같은 합성함수를 R 코드 상에서 직관적으로 구현한 것이라고 이해하면 될 것 같습니다.</p>
<p>이 연산자는 특히 데이터 분석에 유용한데 파이프 연산자를 사용하면 코드 가독성을 저해하는 분석 과정상에서의 중간 객체를 만들 필요가 없어지기 때문입니다. </p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iris <span class="operator">%&gt;%</span> <span class="comment"># df에 연속적으로 함수를 전달함</span></span><br><span class="line">  subset<span class="punctuation">(</span>Sepal.Length <span class="operator">&gt;</span> <span class="number">3</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  aggregate<span class="punctuation">(</span>. <span class="operator">~</span> Species<span class="punctuation">,</span> .<span class="punctuation">,</span> mean<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="lt-unpacking"><a href="#lt-unpacking" class="headerlink" title="%&lt;-%  (unpacking)"></a>%&lt;-%  (unpacking)</h3><p>생각보다 자주 사용하게 되는 unpacking 연산자 입니다.<br><strong>기능은 list나 vector를 분해해서 이름을 할당하는 것입니다.</strong><br>list object인 선형회귀 모형의 특정 요소들을 불러와 이름을 할당해 독립적인 객체로 만들 수 있습니다.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>zeallot<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">m<span class="operator">&lt;-</span> lm<span class="punctuation">(</span>hp <span class="operator">~</span> gear<span class="punctuation">,</span> data <span class="operator">=</span> mtcars<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">c</span><span class="punctuation">(</span>mcall<span class="punctuation">,</span>...<span class="punctuation">,</span>mdf<span class="punctuation">,</span>mstat<span class="punctuation">)</span> <span class="operator">%&lt;-%</span> summary<span class="punctuation">(</span>m<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">mcall <span class="comment"># 모델식</span></span><br><span class="line">lm<span class="punctuation">(</span>formula <span class="operator">=</span> hp <span class="operator">~</span> gear<span class="punctuation">,</span> data <span class="operator">=</span> mtcars<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> mdf <span class="comment"># 자유도</span></span><br><span class="line">     value      numdf      dendf </span><br><span class="line"> <span class="number">0.4816578</span>  <span class="number">1.0000000</span> <span class="number">30.0000000</span> </span><br><span class="line"><span class="operator">&gt;</span> mstat <span class="comment"># 통계량</span></span><br><span class="line">            <span class="punctuation">(</span>Intercept<span class="punctuation">)</span>        gear</span><br><span class="line"><span class="punctuation">(</span>Intercept<span class="punctuation">)</span>   <span class="number">0.8370370</span> <span class="operator">-</span><span class="number">0.21851852</span></span><br><span class="line">gear         <span class="operator">-</span><span class="number">0.2185185</span>  <span class="number">0.05925926</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="x-행렬곱-벡터의-내적"><a href="#x-행렬곱-벡터의-내적" class="headerlink" title="%x% (행렬곱-벡터의 내적)"></a>%x% (행렬곱-벡터의 내적)</h3><p><strong>%x%는 벡터의 내적을 반환합니다.</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="built_in">c</span> <span class="operator">&lt;-</span> matrix<span class="punctuation">(</span><span class="number">1</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">,</span>nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="operator">&gt;</span> <span class="built_in">c</span> <span class="operator">%*%</span> <span class="built_in">c</span></span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">7</span>   <span class="number">15</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>   <span class="number">10</span>   <span class="number">22</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="o-행렬곱-벡터의-외적"><a href="#o-행렬곱-벡터의-외적" class="headerlink" title="%o% (행렬곱-벡터의 외적)"></a>%o% (행렬곱-벡터의 외적)</h3><p><strong>%o%는 벡터의 외적을 반환합니다.</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> d <span class="operator">&lt;-</span> 1<span class="operator">:</span><span class="number">3</span></span><br><span class="line"><span class="operator">&gt;</span> d <span class="operator">%o%</span> d</span><br><span class="line">     <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">1</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">2</span><span class="punctuation">]</span> <span class="punctuation">[</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">1</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">1</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">2</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span></span><br><span class="line"><span class="punctuation">[</span><span class="number">3</span><span class="punctuation">,</span><span class="punctuation">]</span>    <span class="number">3</span>    <span class="number">6</span>    <span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="값-할당하기"><a href="#값-할당하기" class="headerlink" title="%$% (값 할당하기)"></a>%$% (값 할당하기)</h3><p><strong>magrittr</strong> 패키지의 %$% 연산자는 데이터 프레임이 중심이 되는 분석을 할때 사용하는 단순하지만 유용한 연산자입니다.<br><strong>기능은 데이터 프레임에서 단순히 특정 변수를 추출하는 것입니다.</strong></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">library<span class="punctuation">(</span>magrittr<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">mtcars <span class="operator">%$%</span></span><br><span class="line">  cor<span class="punctuation">(</span>disp<span class="punctuation">,</span> mpg<span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="특정-단축키를-addin으로-Rstudio에-추가하기"><a href="#특정-단축키를-addin으로-Rstudio에-추가하기" class="headerlink" title="특정 단축키를 addin으로 Rstudio에 추가하기"></a>특정 단축키를 addin으로 Rstudio에 추가하기</h2><p>특별한 연산자들은 유용하지만 %&gt;%와 같이 Rstudio에서 미리 단축키로 지정해놓지 않은 연산자들을 매번 타이핑해서 사용하는 것은 귀찮은 일입니다.<br>따라서 자주 사용하는 연산자의 경우 Rstudio addin을 사용해 %in% 처럼 단축키를 만들어 주는 것을 고려해볼 수 있습니다.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"> <span class="comment"># 사용자 정의 단축키를 추가하는 Rstudio addin 설치</span></span><br><span class="line"></span><br><span class="line">devtools<span class="operator">::</span>install_github<span class="punctuation">(</span><span class="string">&quot;rstudio/addinexamples&quot;</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;source&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://www.datamentor.io/r-programming/infix-operator/">https://www.datamentor.io/r-programming/infix-operator/</a></li>
<li><a href="https://github.com/r-lib/zeallot">https://github.com/r-lib/zeallot</a></li>
<li><a href="https://rfriend.tistory.com/35">https://rfriend.tistory.com/35</a></li>
<li><a href="https://stackoverflow.com/questions/25179457/r-what-are-operators-like-in-called-and-how-can-i-learn-about-them">https://stackoverflow.com/questions/25179457/r-what-are-operators-like-in-called-and-how-can-i-learn-about-them</a> # Binary operator에 대한 자세한 설명이 나와있습니다.</li>
</ul>
]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>[GLM]선형모델과 비선형 모델의 차이</title>
    <url>/2022/06/16/Statistics-GLM-1/</url>
    <content><![CDATA[<!--

추가 렉카 및 업데이트
https://velog.io/@ithingv/%EC%84%A0%ED%98%95%EB%AA%A8%ED%98%95%EA%B3%BC-%EB%B9%84%EC%84%A0%ED%98%95%EB%AA%A8%ED%98%95-%ED%8C%90%EB%B3%84-Linear-model-nonlinear-model

https://velog.io/@ithingv/%EB%8B%A4%EC%A4%91%EC%84%A0%ED%98%95%ED%9A%8C%EA%B7%80-Multiple-Linear-Regression-Analysis

-->

<p>모델링과 관련하여 선형 및 비선형적인 일반적인 정의에서 중요한 측면은 예측 변수에 대한 선형성이 아니라 매개 변수에 대한 선형성이다. 비선형 모형은 기본적으로 모수가 선형적이지 않기 때문에 비선형적이다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://stats.stackexchange.com/questions/71437/distinction-between-linear-and-nonlinear-model">https://stats.stackexchange.com/questions/71437/distinction-between-linear-and-nonlinear-model</a></li>
<li><a href="https://brunch.co.kr/@gimmesilver/18">https://brunch.co.kr/@gimmesilver/18</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>GLM</tag>
      </tags>
  </entry>
  <entry>
    <title>[Math]미적분 기초개념</title>
    <url>/2022/06/15/Statistics-Math-derivatives/</url>
    <content><![CDATA[<blockquote>
<p>미분의 정의, Data Science에서 미분이 필요한 이유, 미분 공식들에 대해 알아보자.</p>
</blockquote>
<h2 id="미분"><a href="#미분" class="headerlink" title="미분"></a>미분</h2><ul>
<li>함수의 input인 x에 대해서 나오는 결과값이 변화하는 정도를(0에 근사하는 부분을 탐색) 계산하는 것</li>
<li>실제로 계산하는 것은 x의 변화량인 delta_x가 한없이 0에 가까워 질 때의 기울기이다.</li>
<li><strong>Data Science에서 미분이 필요한 이유는 기본적으로 모델의 오차함수가 최소화되는 지점(오차함수의 변화율이 0이 되는 지점)을 찾을 때 미분이 활용되기 때문이다.(최적화 문제)</strong></li>
</ul>
<h2 id="미분-공식"><a href="#미분-공식" class="headerlink" title="미분 공식"></a>미분 공식</h2><p>numerical method만큼은 확실히 이해하고 넘어가자.</p>
<h3 id="numerical-method"><a href="#numerical-method" class="headerlink" title="numerical  method"></a>numerical  method</h3><p>실제로 0으로 나눌 수는 없기 때문에 Delta_x를 0에 근사한 값인 1e-5로 나눠준다.이를 numerical method라 한다.</p>
<h4 id="미분-기본공식"><a href="#미분-기본공식" class="headerlink" title="미분 기본공식"></a>미분 기본공식</h4><p>$$ f’(x) &#x3D; {f(x + \Delta x) - f(x) \over \Delta x}, \Delta x \rightarrow 0~ $$</p>
<h3 id="power-rule"><a href="#power-rule" class="headerlink" title="power rule"></a><strong>power rule</strong></h3><p>멱함수의 도함수를 구하는 그나마 익숙한 미분규칙</p>
<p>$ \frac{d} { {dx} }x^n&#x3D;nx^{n-1} $ </p>
<h4 id="chain-rule"><a href="#chain-rule" class="headerlink" title="chain rule"></a><strong>chain rule</strong></h4><p>합성함수에 대한 미분규칙. 바깥함수의 도함수에 안쪽함수를 인자로 넣어주고 안쪽함수의 도함수를 곱해주면 된다.</p>
<p>$$ \frac{dy} {dx} &#x3D; \frac{dy} {du} \times \frac{du} {dx} $$</p>
<p>좀 더 이해하기 쉽게 나타내면 아래와 같다.</p>
<p>$$F(x) &#x3D; f(g(x))$$</p>
<p>$$F’(x) \rightarrow f’((g(x)) \cdot g’(x)$$</p>
<h4 id="Exponential"><a href="#Exponential" class="headerlink" title="Exponential"></a><strong>Exponential</strong></h4><p>지수함수에 대한 미분규칙. 지수함수의 경우 도함수도 지수함수이다.</p>
<p>$$ f(x) &#x3D; e^x \rightarrow f’(x) &#x3D; e^x $$</p>
<h4 id="Logarithmic"><a href="#Logarithmic" class="headerlink" title="Logarithmic"></a><strong>Logarithmic</strong></h4><p>자연로그에 대한 미분규칙.Logistic Regression이나 Section sigmoid 함수를 미분하는데 도움을 준다.</p>
<p>$$f(x) &#x3D; lnx \rightarrow f’(x) &#x3D; { {1} \over {x} } $$</p>
<h4 id="product-rule"><a href="#product-rule" class="headerlink" title="product rule"></a><strong>product rule</strong></h4><p>두 함수의 곱으로 이루어진 함수에 대한 미분규칙.</p>
<p>$$\frac{d}{ {dx} }\left( {f\left( x \right)g\left( x \right)} \right) &#x3D; f\left( x \right)\frac{d} { {dx} }g\left( x \right) + \frac{d}{ {dx} }f\left( x \right)g\left( x \right)$$</p>
<h4 id="quotinent-rule"><a href="#quotinent-rule" class="headerlink" title="quotinent rule"></a><strong>quotinent rule</strong></h4><p>분수형태로 생긴 합성함수에 대한 미분규칙. 시그모이드 함수의 도함수를 구할 때 사용된다.</p>
<p>$$\frac{d}{ {dx} }\left( {\frac{ {f\left( x \right)} } { {g\left( x \right)} } } \right) &#x3D; \frac{ {\frac{d} { {dx} }f\left( x \right)g\left( x \right) - f\left( x \right)\frac{d}{ {dx} }g\left( x \right)} } { {g^2 \left( x \right)} }$$</p>
<h3 id="편미분-Partial-Derivtives"><a href="#편미분-Partial-Derivtives" class="headerlink" title="편미분(Partial Derivtives)"></a><strong>편미분(Partial Derivtives)</strong></h3><ul>
<li>편미분은 다변수 함수의 특정 변수를 제외한 나머지 변수를 상수로 간주하여 미분하는 것이다.</li>
<li>최적화 관점에서 보면 파라미터가 2개 이상인 Error 함수에 대해 <strong>우선 1개의 파라미터에 대해서만 미분을 한다</strong>는 것이다.</li>
<li>편미분은 ${\partial y} \over {\partial x}$ 와 같이 나타내며 이 경우 x에 대해 편미분한다 하며 x를 제외한 나머지 변수는 상수취급하고 미분한다.</li>
<li><strong>선형회귀에서 오차함수의 최소값을 유도할때 사용된다</strong>.</li>
<li>ex) x에 대해 편미분할 경우</li>
</ul>
<p>$$ f(x,y) &#x3D; x^2 + 2xy + y^2$$</p>
<p>$${ {\partial f(x,y)} \over {\partial x} } &#x3D; { {\partial {(x^2 + 2xy + y^2)} } \over {\partial x}} &#x3D; 2x + 2y$$</p>
<h2 id="sympy를-활욯한-미분계산"><a href="#sympy를-활욯한-미분계산" class="headerlink" title="sympy를 활욯한 미분계산"></a>sympy를 활욯한 미분계산</h2><p>실무에서 이런식으로 따로 미분을 할 일은 없지만 구현한다는 것에 의의를 두자.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#import sympy</span></span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Symbol정의하기</span></span><br><span class="line">x = Symbol(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 함수 정의하기</span></span><br><span class="line">f = x**<span class="number">4</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#도함수 계산하기</span></span><br><span class="line">derivative_f = f.diff(x)</span><br><span class="line"> </span><br><span class="line">derivative_f</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.askpython.com/python/examples/derivatives-in-python-sympy#:~:text=Derivatives%20of%20Multivariable%20Functions%20using%20sympy&amp;text=Such%20derivatives%20are%20generally%20referred,all%20other%20variables%20held%20constant">https://www.askpython.com/python/examples/derivatives-in-python-sympy#:~:text=Derivatives%20of%20Multivariable%20Functions%20using%20sympy&amp;text=Such%20derivatives%20are%20generally%20referred,all%20other%20variables%20held%20constant</a>.</li>
<li><a href="https://youtu.be/H-ybCx8gt-8">https://youtu.be/H-ybCx8gt-8</a></li>
<li><a href="https://ko.wikipedia.org/wiki/%ED%8E%B8%EB%AF%B8%EB%B6%84">https://ko.wikipedia.org/wiki/%ED%8E%B8%EB%AF%B8%EB%B6%84</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
  </entry>
  <entry>
    <title>[Probability]numpy와 scipy로 다항분포 간단하게 구현하기</title>
    <url>/2022/06/15/Statistics-Prob-multinomial-dist/</url>
    <content><![CDATA[<!--

진짜 ref
https://www.statology.org/multinomial-distribution-in-python/

https://boxnwhis.kr/2015/06/04/multinomial_dist_for_gachas.html

다항로지스틱 머신러닝
https://machinelearningmastery.com/multinomial-logistic-regression-with-python/

확륳함수로부터 나오는 확률들의 패턴을 확률분포라 한다

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->


<h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ul>
<li><p>다항분포는 이항분포의 보다 일반화된 버전이다.(다항 분포에서 차원이 2인 경우 이항 분포가 된다.)</p>
</li>
<li><p><strong>다항 분포는 여러 개의 값을 가질 수 있는 독립 확률변수들에 대한 확률분포로, 여러 번의 독립적 시행에서 각각의 값이 특정 횟수가 나타날 확률을 정의한다.</strong><br>다항분포의 가장 쉬운 예시 중 하나는 주사위를 N 번 던저 각 면이 나오는 횟수 집합의 분포를 구하는 것이다.</p>
</li>
<li><p><strong>특정 확률변수 X가 다음의 조건을 충족할 경우 다항분포를 따른다.</strong></p>
<ul>
<li>k개의 class(발생가능한 결과, 카테고리 등)</li>
<li>각 trial은 독립적이다.</li>
<li>독립적인 각각의 trial에서 i번째 class가 나타날 확률읜 $p_{i}$로 고정한다.</li>
</ul>
</li>
</ul>
<h4 id="다항분포-공식"><a href="#다항분포-공식" class="headerlink" title="다항분포 공식"></a>다항분포 공식</h4><ul>
<li><p>다항분포의 PMF는 다음과 같이 정의된다. 식이 복잡해보이는 것은 단순히 나올 수 있는 결과의 조합이 복잡하기 때문이다.<br>$$f(x)&#x3D;\frac{n !}{x_{1} ! \cdots x_{k} !} p_{1}^{x_{1}} \cdots p_{k}^{x_{k}}$$</p>
</li>
<li><p>다항분포의 기댓값 :<br>$$E{X_{i}}&#x3D;np_{i}$$</p>
</li>
<li><p>다항분포의 분산 :<br>$\operatorname{Var}\left(X_{i}\right)&#x3D;n p_{i}\left(1-p_{i}\right)$</p>
</li>
</ul>
<h4 id="구현"><a href="#구현" class="headerlink" title="구현"></a>구현</h4><ul>
<li>numpy를 활용한 시뮬레이션</li>
</ul>
<p>두번째 인수에 tuple 형태로 각 class의 확률이 들어간다.<br>두번째 인수의 확률의 합은 반드시 1이여야 한다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 주사위 10번 던지는 시뮬레이션</span></span><br><span class="line">np.random.multinomial(<span class="number">10</span>, [<span class="number">1</span>/<span class="number">6.</span>]*<span class="number">6</span>, size=<span class="number">1</span>)</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]]) <span class="comment"># random</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>scipy 예제</li>
</ul>
<p>주머니에 6개의 노란 구슬,2개의 빨간 구슬, 2개의 파란구슬이 있을 때<br>복원추출로 4개의 구슬을 뽑을 경우 모든 구슬이 빨간 색일 확률은 무엇인가?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> multinomial</span><br><span class="line"></span><br><span class="line">multinomial.pmf(x=[<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>],n=<span class="number">4</span>,p = [<span class="number">.6</span>,<span class="number">.2</span>,<span class="number">.2</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="number">0.1295999999999999</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://youtu.be/nMsCHfrt3Cw">https://youtu.be/nMsCHfrt3Cw</a></li>
<li><a href="https://www.statisticshowto.com/multinomial-distribution/">https://www.statisticshowto.com/multinomial-distribution/</a></li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title>[Probability]Python을 활용한 카이스퀘어 검정 구현</title>
    <url>/2022/06/15/Statistics-Prob-chi-square-dist/</url>
    <content><![CDATA[<h3 id="카이스퀘어-분포"><a href="#카이스퀘어-분포" class="headerlink" title="카이스퀘어 분포"></a>카이스퀘어 분포</h3><h4 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h4><ul>
<li>감마분포의 특수한 형태이다.</li>
<li>표준정규분포로부터 얻은 랜덤 변수들을 제곱해서 더한 것이다.</li>
<li>자유도 수 만큼 표준정규분포에서 변수를 뽑고 그 값들을 제곱해서 더한다.</li>
<li><strong>데이터의 분산이 퍼저있는 정도를 분포로 보여준다는 것이 핵심이다.</strong><ul>
<li>모분산을 추정할 수 있다 -&gt; goodness of fit</li>
<li>두 분포의 차이를 확인할 수 있다 -&gt; Chi-square test of independence</li>
</ul>
</li>
</ul>
<h4 id="공식"><a href="#공식" class="headerlink" title="공식"></a>공식</h4><ul>
<li>k개의 정규분포를 따르는 확률변수 X_1 ,…, X_k를 정의하면 아래와 같이 자유도 k의 카이스퀘어 분포를 나타낼 수 있다.</li>
</ul>
<p>$$Q &#x3D; \sum_{i&#x3D;1}^{k} X_i^2$$</p>
<ul>
<li>독립성 검정(independence test)과 적합성 검정(goodness of fit)을 위하 사용하는 피어슨 카이스퀘어 통계량<ul>
<li>$\frac{(O_i - E_i)^2}{E_i}$는 정규분포를 따르고 데이터가 충분히 많다면 이를 합한 피어슨 카이스퀘어 통계량은 카이스퀘어 분포를 따른다.</li>
</ul>
</li>
</ul>
<p>$$\sum_i \frac{(O_i - E_i)^2}{E_i}$$</p>
<h4 id="적합성-검정-goodness-of-fit-구현"><a href="#적합성-검정-goodness-of-fit-구현" class="headerlink" title="적합성 검정(goodness of fit) 구현"></a>적합성 검정(goodness of fit) 구현</h4><p>적합성 검정은 기본적으로 샘플 데이터가 특정 분포를 따르는지(정규분포) 확인할 때 사용한다.<br>이 검정이 중요한 이유는 회귀분석 모델링에서 요구하는 오차의 정규성 가정을 확인하는데 쓸 수 있기 때문이다.</p>
<p><strong>관측한 데이터(샘플)의 분포가 기대되는 어떤 분포(보통 정규분포)를 따르는지 확인한다는 것이 핵심이고 로직 자체는 아래의 독립성 검정과 유사하다.</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.stats <span class="keyword">as</span> stats</span><br><span class="line"></span><br><span class="line">obs = [<span class="number">20</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>, <span class="number">50</span>]</span><br><span class="line">exp = [<span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Goodness of Fit Test</span></span><br><span class="line"><span class="comment"># f_exp 인자로 로 기대되는 데이터 value를 넣을 수 있다. </span></span><br><span class="line">stats.chisquare(f_obs=obs,f_exp=exp)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;Power_divergenceResult(statistic=<span class="number">33.333333333333336</span>, pvalue=<span class="number">1.020735571764047e-06</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="독립성-검정-Chi-square-test-of-independence"><a href="#독립성-검정-Chi-square-test-of-independence" class="headerlink" title="독립성 검정(Chi-square test of independence)"></a>독립성 검정(Chi-square test of independence)</h4><ul>
<li><strong>두 범주형 변수 사이의 관계를 파악한다.</strong></li>
<li>독립성 검정을 시행하려면 교차표의 각 셀의 기대빈도가 5 이상이여 한다는 조건이 붙는다.</li>
<li>각 셀의 기대빈도가 5 이상일 경우 $\chi^2$ 는 근사적으로 기대빈도가 n-1인 카이스퀘어 분포를 따른다.</li>
<li>보통 범주형 독립변수와 범주형 종속변수의 관계가 있는지 확인할 때 사용한다.</li>
</ul>
<p>귀무가설은 두 범주형 변수가 독립적이라는 것이다.<br>귀무가설이 성립하려면 교차표의 각 셀의 관측빈도와 기대빈도의 차이는 0에 가까워야 한다.<br>두 범주형 변수의 빈도의 범주간 차이가 기댓값에서 유의미하게 벗어나는지 검정한다.</p>
<p>카이스퀘어 통계량이 유의수준을 넘어서면 귀무가설을 기각한다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2_contingency</span><br><span class="line"></span><br><span class="line"><span class="comment"># 교차표 자체는 pandas에서 제공하는 crostab함수를 통해 df로 만들 수도 있다.</span></span><br><span class="line">table = [[<span class="number">20</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>], [<span class="number">20</span>, <span class="number">42</span> ,<span class="number">15</span>,  <span class="number">30</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 카이 , p-value, 자유도, 기대빈도</span></span><br><span class="line">stat, p, dof, expected = chi2_contingency(table)</span><br><span class="line"><span class="comment"># 유의수준 설정</span></span><br><span class="line">alpha = <span class="number">0.05</span></span><br><span class="line"><span class="comment"># 가설수용/기각</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;significance=%.3f, p=%.3f&#x27;</span> % (alpha, p))</span><br><span class="line"><span class="keyword">if</span> p &lt;= alpha:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Variables are associated (reject H0)&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Variables are not associated(fail to reject H0)&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://youtu.be/2QeDRsxSF9M">https://youtu.be/2QeDRsxSF9M</a></li>
<li><a href="https://towardsdatascience.com/chi-squared-test-for-feature-selection-with-implementation-in-python-65b4ae7696db">https://towardsdatascience.com/chi-squared-test-for-feature-selection-with-implementation-in-python-65b4ae7696db</a></li>
<li>기대빈도가 5미만일 경우 피셔의 적합검정을 고려한다.</li>
<li>제대로 쓰려면 헬퍼함수를 따로 만들긴 해야할 것 같다.</li>
</ul>
]]></content>
      <categories>
        <category>Statistics</category>
      </categories>
      <tags>
        <tag>Probability</tag>
      </tags>
  </entry>
  <entry>
    <title>[R]make: gfortran: No such file or directory 해결하기</title>
    <url>/2022/06/15/TS-R-lib-1/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing



#신경망이란 무엇인가?


https://www.youtube.com/watch?v=aircAruvnKk



#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p>시계열 분석을 할 일이 있어서 Rstudio server에다가 <code>forecast</code> package를 설치하려 하는데 dependancy package를 설치하는 도중</p>
<p>아래와 같은 오류가 떴다.</p>
<p><code>make: gfortran: No such file or directory</code></p>
<p>그리고 라이브러리 설치가 안된다..</p>
<p>찾아보니까 package가 소스 형태라 컴파일러가 필요한데 그 중 포트란 컴파일러가 서버에 설치되지 않아서 생긴 문제였다.</p>
<p>터미널에다 아래 명령어를 쳐서 해결하였다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pacman -S gcc-fortran</span><br></pre></td></tr></table></figure>


<p>우분투 사용자의 경우 아래와 같이 컴파일러를 설치해주면 된다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install gfortran</span><br></pre></td></tr></table></figure>

<p>윈도우 사용자의 경우 <a href="https://fortran-lang.org/learn/os_setup/install_gfortran">링크</a> 에서 설치법을 확인할 수 있다.</p>
<h2 id="References-amp-annotation"><a href="#References-amp-annotation" class="headerlink" title="References &amp; annotation"></a><strong>References &amp; annotation</strong></h2><ul>
<li><a href="https://www.r-bloggers.com/2021/03/gfortran-support-for-r-on-macos-2/">https://www.r-bloggers.com/2021/03/gfortran-support-for-r-on-macos-2/</a></li>
<li><a href="https://fortran-lang.org/learn/os_setup/install_gfortran">https://fortran-lang.org/learn/os_setup/install_gfortran</a></li>
</ul>
]]></content>
      <categories>
        <category>Troubleshooting</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>[SQL]ERROR 3948 (42000): Loading local data is disabled; this must be enabled on both the client and server sides 해결하기</title>
    <url>/2022/06/15/TS-SQL-ts-1/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing



#신경망이란 무엇인가?


https://www.youtube.com/watch?v=aircAruvnKk



#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->


<p>안쓰던 노트북을 서버로 만들어서 작업중 다음 에러가 발생했다.</p>
<p>ERROR 3948 (42000): Loading local data is disabled; this must be enabled on both the client and server sides  </p>
<p>찾아보니 SQL 서버의 변수값을 변경해 해결할 수 있었다.</p>
<p>아래 명령을 통해 local_infile 상태가 ON 인지 OFF인지 확인 한다.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;local_infile&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>값이 OFF일 경우 아래 명령 실행</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://stackoverflow.com/questions/59993844/error-loading-local-data-is-disabled-this-must-be-enabled-on-both-the-client">https://stackoverflow.com/questions/59993844/error-loading-local-data-is-disabled-this-must-be-enabled-on-both-the-client</a></li>
</ul>
]]></content>
      <categories>
        <category>Troubleshooting</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>[Linux]zsh: corrupt history file 해결</title>
    <url>/2022/06/15/TS-linux-ts-1/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning



- Statistics , Math
- Data Engineering
- Programming
- EDA & Visualization
- Preprocessing


#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~                          </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">mv</span> .zsh_history .zsh_history.1217</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ strings .zsh_history.1217 .zsh_history</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">fc</span> -R .zsh_history</span><br></pre></td></tr></table></figure>


<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://www.whatwant.com/entry/zsh-corrupt-history-file">https://www.whatwant.com/entry/zsh-corrupt-history-file</a></li>
</ul>
]]></content>
      <categories>
        <category>Troubleshooting</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>[Unsorted]머신러닝과 통계학의 차이</title>
    <url>/2022/06/15/thoughts-1/</url>
    <content><![CDATA[<!--


-->

<p>개인적으로 생각했을 때 머신러닝과 통계적 검정의 차이는 인과추론에 있어서의 엄격성의 여부이다.</p>
<p>이는 실험설계의 엄격함의 정도와 다룰 수 있는 feature의 수 사이의 tradeoff라고도 볼 수 있다.</p>
<p>사실 머신러닝과 딥러닝은 그렇게까지 큰 차이가 있는것이 아니고 분석하고자 하는 데이터의 차원이 다른 것 뿐이다.</p>
<p>통계적 검정의 목적은 기본적으로 가설검정이지만 머신러닝의 목적은 패턴인식이다. </p>
<p>이 차이는 상호보완적으로 문제해결에 각기 다르게 도움을 준다.</p>
<p>중요한건 문제에 따라 어떤 방법론이 적합할지를 파악하는 것이다.</p>
<p>자원은 항상 한정적이기 때문에(특히 시간이) 학습시간이 너무 오래걸리는 모델을 붙잡고 있는 것보다는 다른 방식으로 인사이트를 얻을 수 있는 방법이 있는지를 사전에 고민해 보는 편이 좋다.</p>
<p>개인연구를 할때는 삽질이 곧 배움으로 이어지지만 실무에서는 삽질의 대가가 너무 크게 다가온다.</p>
]]></content>
      <categories>
        <category>Unsorted</category>
      </categories>
      <tags>
        <tag>Unsorted</tag>
      </tags>
  </entry>
  <entry>
    <title>[Tools]Anaconda 시작시 기본설정</title>
    <url>/2021/07/08/tools-conda-install/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Anaconda를 자주 설치하고 지우기 때문에 Anaconda를 설치하면 하는 루틴들을 정리해두려고 합니다.</p>
<h2 id="주피터-시작경로-설정"><a href="#주피터-시작경로-설정" class="headerlink" title="주피터 시작경로 설정"></a>주피터 시작경로 설정</h2><ol>
<li><p>powershell에서 해당 명령어 실행</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">jupyter notebook <span class="literal">--generate-config</span></span><br></pre></td></tr></table></figure></li>
<li><p>‘C:\Users\유저명.jupyter\jupyter_notebook_config.py’ 경로로 이동</p>
</li>
<li><p>#c.NotebookApp.notebook_dir&#x3D; ‘’  를 주석처리하고 원하는 경로 입력 </p>
</li>
<li><p>시작메뉴 주피터 속성 에서  <strong>%USERPROFILE%&#x2F;</strong> 과 <strong>%HOMEPATH%</strong> 삭제</p>
</li>
</ol>
<h2 id="Jupyterlab-바로가기-설청"><a href="#Jupyterlab-바로가기-설청" class="headerlink" title="Jupyterlab 바로가기 설청"></a>Jupyterlab 바로가기 설청</h2><ol>
<li>conda 설치경로\Script에 들어가서 activate.bat 파일을 연다.</li>
<li>activate.bat 파일을 다른 이름으로 저장한다(activate_jupyter).</li>
<li>다른이름으로 저장한 파일의 맨 아래에 다음 두 줄을 추가한다.<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;작업경로&gt;</span><br><span class="line">jupyter lab</span><br></pre></td></tr></table></figure></li>
<li>새로만든 파일의 바로가기를 만든다.</li>
<li>바로가기 아이콘을 jupyter lab 아이콘으로 변경한다.</li>
<li>시작메뉴에 바로가기를 추가한다.</li>
</ol>
<h2 id="Jupyterlab-theme-설치"><a href="#Jupyterlab-theme-설치" class="headerlink" title="Jupyterlab theme 설치"></a>Jupyterlab theme 설치</h2><h2 id="가상환경-생성-및-Jupyter-등록"><a href="#가상환경-생성-및-Jupyter-등록" class="headerlink" title="가상환경 생성 및 Jupyter 등록"></a>가상환경 생성 및 Jupyter 등록</h2><p>가상환경 자체는 단순히 자신이 필요한 python환경을 구축하기 위해 폴더 안에 필요한 패키지만을 모아 놓은 것이다. 보통 프로젝트 단위로 작업을 할때 패키지 의존성(dependancy)으로 인한 오류들을 줄이기 위해 사용한다. <code>vertualenv</code>로도 가상환경을 설치할 수 있지만 <code>conda</code>를 사용한다면 conda명령어를 통해 쉽게 가상환경을 설치하고 삭제할 수 있다.<br><img src="/conda_venv.png" alt="png"></p>
<h3 id="conda-가상환경-명령어"><a href="#conda-가상환경-명령어" class="headerlink" title="conda 가상환경 명령어"></a>conda 가상환경 명령어</h3><ol>
<li>가상환경 만들기 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create –n 가상환경이름 python=버전 </span><br></pre></td></tr></table></figure></li>
<li>가상환경 활성화  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate 가상환경이름</span><br></pre></td></tr></table></figure></li>
<li>가상환경 비활성화  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate 가상환경이름</span><br></pre></td></tr></table></figure></li>
<li>가상환경에 패키지 설치 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install 패키지이름 </span><br></pre></td></tr></table></figure></li>
<li>가상환경 정보 확인 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda info --enves </span><br></pre></td></tr></table></figure></li>
<li>가상환경 복사<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create –n 복사된 가상환경 --<span class="built_in">clone</span> 복사될 가상환경 </span><br></pre></td></tr></table></figure></li>
<li>가상환경 설치패키지 확인<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 가상환경 활성화 시킨 후 시행</span></span><br><span class="line">conda list</span><br></pre></td></tr></table></figure></li>
<li>가상환경 삭제<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">env</span> remove -n 가상환경이름 </span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="주피터-커널-등록"><a href="#주피터-커널-등록" class="headerlink" title="주피터 커널 등록"></a>주피터 커널 등록</h3><ol>
<li>ipykernel 설치<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install ipykernel</span><br></pre></td></tr></table></figure></li>
<li>가상환경 주피터 등록<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --user --name 가상환경 이름 --display-name 커널 이름</span><br></pre></td></tr></table></figure></li>
<li>가상환경 주피터 커널 삭제<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter kernelspec uninstall 가상환경이름</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://ooyoung.tistory.com/7">https://ooyoung.tistory.com/7</a></li>
<li><a href="https://django-easy-tutorial.blogspot.com/2015/08/python-virtual-environment-setup-in-ubuntu.html">https://django-easy-tutorial.blogspot.com/2015/08/python-virtual-environment-setup-in-ubuntu.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>[Tools]Docker 기본개념(작성중)</title>
    <url>/2022/06/15/tools-docker-basic/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><h2 id="Docker개념"><a href="#Docker개념" class="headerlink" title="Docker개념"></a>Docker개념</h2><ul>
<li>도커 이미지는 다른 이미지 위에 쌓는게 가능하다.</li>
<li>VM은 독립적으로 운영되고 독립적인 자원을 사용하기 때문에 그 경우에 효율적일 수 있다.</li>
<li>도커의 Layer는 설계도이다.</li>
<li>이미지는 기본적으로 아직 실행되지 않은 컨테이너이다.</li>
</ul>
<p>Docker Container는 가상환경과 다르다.</p>
<p>가상환경은 python version만 폴더안에 있는걸 쓰는 것이고 Docker Container는 아예 독립된 환경이다.</p>
<h2 id="Doker-명령어들"><a href="#Doker-명령어들" class="headerlink" title="Doker 명령어들"></a>Doker 명령어들</h2><p>도커 빌드하기</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /path/to/Dockerfile</span><br><span class="line">$ sudo docker build .</span><br></pre></td></tr></table></figure>

<p>현재 실행되고 있는 도커 프로세스들확인</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker ps</span><br></pre></td></tr></table></figure>

<p>View all processes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker ps -a</span><br></pre></td></tr></table></figure>

<p>Run an image in a new container daemonized</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -d &lt;image_name&gt;</span><br></pre></td></tr></table></figure>

<p>Run an image in interactive mode with the command <code>/bin/bash</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t &lt;image_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>Run an image in interactive mode with the command <code>/bin/bash</code> and link the ports.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t --link &lt;docker_container_name&gt;:&lt;docker_container_alias&gt; &lt;image_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>Run an image with an ENTRYPOINT command in interactive mode with the command <code>/bin/bash</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run --entrypoint /bin/bash -i -t &lt;image_name&gt;</span><br></pre></td></tr></table></figure>

<p>Run an image in interactive mode with the command <code>/bin/bash</code> mounting the host director <code>/var/app/current</code> to the container directory <code>/usr/src/app</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t -v /var/app/current:/usr/src/app/ &lt;image_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>Run an image in interactive mode with the command <code>/bin/bash</code> setting the environments variables <code>FOO</code> and <code>BAR</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run -i -t -e FOO=foo -e BAR=bar &lt;image_name&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://gist.github.com/dwilkie/f8d6526edc5f1a8aca385df5113567e4">https://gist.github.com/dwilkie/f8d6526edc5f1a8aca385df5113567e4</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>[Git]간단한 Git 명령어 및 용법 정리</title>
    <url>/2021/07/17/tools-git-basic/</url>
    <content><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>Git은 버전관리와 협업을 위한 툴입니다. 추후 참고할 수 있도록 간단히 내용을 정리하겠습니다.</p>
<hr>
<h2 id="Git-동작원리"><a href="#Git-동작원리" class="headerlink" title="Git 동작원리"></a>Git 동작원리</h2><h3 id="Git의-영역들"><a href="#Git의-영역들" class="headerlink" title="Git의 영역들"></a>Git의 영역들</h3><ul>
<li><strong>Project 영역(working tree)</strong> : 현재 프로젝트에 있는 파일들 전체입니다.</li>
<li><strong>Stagind 영역(staging area)</strong> : Project 영역에서 변경된 사항들을 기록하는 index 입니다.</li>
<li><strong>Repository</strong> : 깃이 버전 관리를 하기 위해 필요한 데이터들을 저장하는 곳입니다.깃을 초기화해 버전관리를 한 시점부터 현 시점까지의 파일들이 저장되어 있습니다.<ul>
<li>local  : 사용자의 Local 머신에 저장된 레포지토리입니다.</li>
<li>remote : Github, Gitlab 등의 웹 저장소에 레포지토리 입니다.</li>
</ul>
</li>
</ul>
<h3 id="Git에서-수행하는-작업들"><a href="#Git에서-수행하는-작업들" class="headerlink" title="Git에서 수행하는 작업들"></a>Git에서 수행하는 작업들</h3><p>Git은 기본적으로 Project영역에서 수정작업을 한 뒤 index에 <code>staging</code>하고 이를 로컬저장소에 <code>commit</code>하고 원격저장소에 <code>push</code> 하는 절차를 거칩니다.</p>
<ul>
<li><strong>특정 프로젝트의 업데이트 내용 기록(버전관리)</strong><ul>
<li>git add</li>
<li>git status</li>
<li>git log</li>
<li>git commit</li>
</ul>
</li>
<li><strong>같은 파일을 여러 작업자가 수정 및 관리(협업)</strong><ul>
<li>git branch</li>
<li>git checkout</li>
<li>git remote add 저장소</li>
<li>git fetch</li>
<li>git merge</li>
<li>git pull</li>
<li>git push</li>
</ul>
</li>
</ul>
<p><img src="/git-simple.png" alt="ohno"><br><strong>&lt;그림 1 git 동작원리&gt;</strong></p>
<h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>간단한 연습용 프로젝트를 통해 Git을 이해해봅시다.<br>일단 적당히 디렉토리를 만들고 git을 초기화 합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_project</span><br><span class="line"><span class="built_in">cd</span> new_project</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>적당한 파이썬 파일 하나를 디렉토리에 추가해 줍니다.<br><code>vim</code> 이나 <code>sublimetext</code> ,<code>vscode</code> 등의 편집기를 활용해 파일들을 수정할 수 있습니다.<br>여기서는 bash shell에서 간단한 명령을 추가했습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> this.py</span><br><span class="line"><span class="comment"># 파일 편집을 위한 적당한 명령 추가</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;import this&quot;</span> &gt;&gt; this.py</span><br></pre></td></tr></table></figure>
<p><code>git status</code> 를  통해  확인해보면 <code>commit</code> 할 파일이 없다고 나옵니다.<br>이는 파일이 아직 Staging 영역의 index에 올라가지 않아서 그렇습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        this.py</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>방금 생성한 파일을 git이 추적하도록 git add를 해줍니다.<br>만약 폴더 내 여러 파일을 편집한 상황에서 모든 변경사항을 반영하고 싶다면 <code>git add .</code>를 해주면 됩니다. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add this.py</span><br></pre></td></tr></table></figure>
<p>이제 폴더 내 변경사항이 index에 staging되었으니까 local 저장소에 <code>commit</code>을 해줄 수 있습니다.<br><code>commit -m</code> 을 통해 어떤 부분이 변경되었는지 간단히 메시지를 적어줄 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;this.py 파일 추가&quot;</span></span><br></pre></td></tr></table></figure>
<p>여기까지가 <code>working directory</code> -&gt; <code>local repository</code>의 작업흐름입니다.</p>
<h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p><code>remote repostory</code> 는 데이터가 웹 서버에 저장된다는 것을 제외하면 로컬의 그것과 다를게 없습니다. </p>
<p>서버에 저장소를 만들어 둠으로서 보다 여러 사람들이 저장소에 접근하고 수정할 수 있게끔 해서 소스코드 관리를 보다 편리하게 할 수있습니다.</p>
<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=http://cfile8.uf.tistory.com/image/27532A36575F3888290EC8"><br><strong>&lt;그림2 remote repository&gt;</strong></p>
<p><code>git remote add </code> 를 통해 로컬을 외부저장소와 연결할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin <span class="string">&#x27;외부저장소 링크&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git push</code>  를 통해 로컬저장소의 내용을 서버의 외부저장소로 전송할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><code>git fetch</code>  를 통해 외부저장소의 변경사항을 로컬로 가져올 수 있습니다.<br>이 변경사항을 로컬의 작업내역들과 비교할 수 있고 만약 누군가가 생성한 신규 커밋들이 로컬에서 작업한 부분과 중복되는 부분이 있다면 이를 알 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch <span class="string">&#x27;외부저장소명&#x27;</span> <span class="string">&#x27;브랜치명&#x27;</span></span><br></pre></td></tr></table></figure>

<p><code>git merge</code>  를 통해 외부저장소의 내용과 로컬의 내용을 동기화합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<p><code>git pull</code>  를 통해 <code>git fetch</code>와 <code>merge</code>를 한번에 시행할 수 있습니다.<br><code>git fetch</code>를 통해 외부저장소의 변경사항을 확인하고 <code>git merge</code>를 통해 로컬과 외부저장소를 병합합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p><strong>branch는 git의 커밋과 커밋 사이를 이동할 수 있는 일종의 포인터 입니다.</strong> </p>
<p>git branch는 git의 버전관리와 협업의 핵심이 되는 컨셉입니다.</p>
<p>여러 작업자가 동시에 작업해야 하는 큰 프로젝트가 있을때 git branch를 사용해서 생산성을 높일 수 있습니다.</p>
<p><img src="/git-branch.png"></p>
<p><code>git branch</code> 를 통해 현재 branch들을 조회합니다. -a 를 통해 원격과 로컬 branch를 모두 조회할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>새 branch를 만듧니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch 브랜치명</span><br></pre></td></tr></table></figure>
<p>원래 branch를 새로운 branch로 변경합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m 원래브랜치 새로운브랜치</span><br></pre></td></tr></table></figure>
<p>main에서 새로운 브랜치 new를 만듭니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch new main</span><br></pre></td></tr></table></figure>
<p>브랜치를 삭제합니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d 브랜치</span><br></pre></td></tr></table></figure>
<p>해당 브랜치로 작업영역을 변경합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout 브랜치</span><br></pre></td></tr></table></figure>

<p>A 브랜치를 현재 브랜치로 합칩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git merge A</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://opentutorials.org/module/2676/15202">https://opentutorials.org/module/2676/15202</a></li>
<li><a href="https://dzone.com/articles/top-20-git-commands-with-examples">https://dzone.com/articles/top-20-git-commands-with-examples</a></li>
<li><a href="https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80">https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>[Git]commit, push 제외 자주쓰는 git 명령어들</title>
    <url>/2022/06/15/tools-git-log/</url>
    <content><![CDATA[<!--

merge 렉카 : https://kotlinworld.com/277

merge flow :
master 에서 출발
나의 작업용 브랜치를 만들기 위해 master 에서 feature 브랜치를 생성
feature 브랜치에서 add commit 등의 작업
내가 지금까지 push했던것은 local에 있던 코드를 remote의 브랜치로 전달한것
PR 메시지 작성
remote feature 에서 remote master로 merge
local master에서 최신의 remote master 내용을 반영하기 위해 git pull origin master
local feature 에서 최신이 된 local master 내용을 반영하기 위해 git merge master
충돌 발생 (local feature 에서)
충돌 해결 후 add ,commit => 새 변경 사항
remote feature에 새 변경 사항을 push
충돌 해결 (remote feture 에서)

-->



<h4 id="Branch-생성"><a href="#Branch-생성" class="headerlink" title="Branch 생성"></a>Branch 생성</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>


<h4 id="생성한-Branch로-이동"><a href="#생성한-Branch로-이동" class="headerlink" title="생성한 Branch로 이동"></a>생성한 Branch로 이동</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch example</span><br></pre></td></tr></table></figure>

<ul>
<li>branch를 만들면서 현재 branch 변경</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch -c example2  <span class="comment"># c 는 아마 create를 의미</span></span><br></pre></td></tr></table></figure>

<h4 id="branch-삭제"><a href="#branch-삭제" class="headerlink" title="branch 삭제"></a>branch 삭제</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d example</span><br></pre></td></tr></table></figure>

<ul>
<li>merge가 정상적으로 안되는 branch를 강제 삭제할 겨우</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D example</span><br></pre></td></tr></table></figure>


<ul>
<li>원격 브랜치를 삭제할 경우</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete example</span><br></pre></td></tr></table></figure>


<h4 id="파일옮기기-이름-바꾸기"><a href="#파일옮기기-이름-바꾸기" class="headerlink" title="파일옮기기, 이름 바꾸기"></a>파일옮기기, 이름 바꾸기</h4><p>단순히 unix mv 명령어를 사용해도 된다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">mv</span>  old_file new file </span><br></pre></td></tr></table></figure>
<h4 id="커밋내역-확인하기"><a href="#커밋내역-확인하기" class="headerlink" title="커밋내역 확인하기"></a>커밋내역 확인하기</h4><p>log를 통해 이전 커밋 내역을 확인한다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h4 id="커밋내역-삭제하기"><a href="#커밋내역-삭제하기" class="headerlink" title="커밋내역 삭제하기"></a>커밋내역 삭제하기</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset HEAD~n  최근 내역 n개 삭제</span><br><span class="line">git <span class="built_in">log</span>  <span class="comment"># 삭제된 커밋 확인</span></span><br></pre></td></tr></table></figure>


<h4 id="변경사항-복원하기"><a href="#변경사항-복원하기" class="headerlink" title="변경사항 복원하기"></a>변경사항 복원하기</h4><p>restore  :  변경 내역이 있는 파일을 복원할 수 있다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore a_file </span><br></pre></td></tr></table></figure>

<ul>
<li>stage 된 파일 복원</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git restore --staged a_file</span><br></pre></td></tr></table></figure>

<h4 id="branch-합치기-merge"><a href="#branch-합치기-merge" class="headerlink" title="branch 합치기(merge)"></a>branch 합치기(merge)</h4><ul>
<li>여기서는 현재 branch의 commit을 대상이 되는 branch의 commit까지 옮기는 작업인 <code>Fast Forward Merge</code> 만 다룬다.</li>
<li><code>Fast Forward Merge</code>는 중간에 다른 커밋이 추가되면 충돌 오류가 발생한다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git switch example</span><br><span class="line">git merge example2</span><br></pre></td></tr></table></figure>



<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EC%99%80-Merge-%EC%9D%98-%EA%B8%B0%EC%B4%88">브랜치와 Merge의 기초</a></li>
<li><a href="https://git-scm.com/book/ko/v2">https://git-scm.com/book/ko/v2</a></li>
<li><a href="https://goddaehee.tistory.com/274">https://goddaehee.tistory.com/274</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>[Git]Private repository import 하기</title>
    <url>/2022/06/15/tools-git-private-repo/</url>
    <content><![CDATA[<!--

<center>Kaggle Customer Score Dataset</center>

- Machine Learning
- Statistics , Math
- Data Engineering
- Programmingdf
- EDA & Visualization
- Data Extraction & Wrangling

#신경망이란 무엇인가?

https://www.youtube.com/watch?v=aircAruvnKk


#참고

https://cinema4dr12.tistory.com/1016?category=515283

https://www.kdnuggets.com/2021/07/top-python-data-science-interview-questions.html
-->

<p><strong>보안이나 기타 이유로 private repository에서 관리하는 패키지를 써야할 경우가 있다.</strong></p>
<p><strong>나중에도 자주 쓸거 같으니까 개인용 패키지를 pandas나 sklearn처럼 설치하고 사용하는 법을 정리해두자.</strong></p>
<hr>
<h2 id="작업용-repository-만들기"><a href="#작업용-repository-만들기" class="headerlink" title="작업용 repository 만들기"></a>작업용 repository 만들기</h2><p>적당한 이름의 private repository를 만들고 패키지를 넣을 디렉터리를 만들어준다. </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> some_package</span><br></pre></td></tr></table></figure>

<h2 id="init-py-만들기"><a href="#init-py-만들기" class="headerlink" title="__init__.py 만들기"></a><code>__init__.py</code> 만들기</h2><p><code>__init__.py</code> 파일을 디렉터리에 넣으면 pip에서 해당 디렉토리를 패키지로 인식한다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># example 패키지(디렉토리)의 broadcast 파일에서  전부 가져오기</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> example.broadcast <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<h2 id="패키지에-함수-넣기"><a href="#패키지에-함수-넣기" class="headerlink" title="패키지에 함수 넣기"></a>패키지에 함수 넣기</h2><p>패키지 디렉토리에 포함될 함수를 넣어준다.</p>
<p>여기서는 numpy의 broadcast를 구현하는 함수를 넣어주었다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># broadcast.py</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">m1 = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">m2 = np.array([<span class="number">10</span>,<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(m1 * m2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="setup-py-만들기"><a href="#setup-py-만들기" class="headerlink" title="setup.py 만들기"></a><code>setup.py</code> 만들기</h2><p>setup.py에는 패키지의 메타데이터를 넣어준다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Python package setup info</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> setuptools</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;README.md&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fh:</span><br><span class="line">    long_description = fh.read()</span><br><span class="line"></span><br><span class="line">setuptools.setup(</span><br><span class="line">    name=<span class="string">&#x27;레포이름&#x27;</span>,</span><br><span class="line">    version=<span class="string">&#x27;0.0.1&#x27;</span>,</span><br><span class="line">    author=<span class="string">&#x27;jinheonyoon&#x27;</span>,</span><br><span class="line">    author_email=<span class="string">&#x27;yjinheon@gmail.com&#x27;</span>,</span><br><span class="line">    description=<span class="string">&#x27;Package 설치 확인&#x27;</span>,</span><br><span class="line">    long_description=long_description,</span><br><span class="line">    long_description_content_type=<span class="string">&quot;text/markdown&quot;</span>,</span><br><span class="line">    url=<span class="string">&#x27;https://github.com/yjinheon/레포이름.git&#x27;</span>,</span><br><span class="line">    project_urls = &#123;</span><br><span class="line">        <span class="string">&quot;Bug Tracker&quot;</span>: <span class="string">&quot;https://github.com/yjinheon/레포이름/issues&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    license=<span class="string">&#x27;jinheonyoon&#x27;</span>,</span><br><span class="line">    zip_safe = <span class="literal">False</span>,</span><br><span class="line">    packages = [<span class="string">&#x27;설치한 패키지 명&#x27;</span>],</span><br><span class="line">    install_requires = [</span><br><span class="line">        <span class="string">&#x27;numpy==1.20.1&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;pandas==1.3&#x27;</span></span><br><span class="line">        ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="token-생성하기"><a href="#token-생성하기" class="headerlink" title="token 생성하기"></a>token 생성하기</h2><p>Github 계정의 <code>Setting</code>의 <code>developer settings</code>에서 token을 생성할 수 있다.</p>
<p><a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">여기</a> 참조</p>
<h2 id="설치하기"><a href="#설치하기" class="headerlink" title="설치하기"></a>설치하기</h2><p>생성한 토큰을 로컬에 변수로 넣어준다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export token=생성한 토큰</span><br></pre></td></tr></table></figure>

<p>$token으로 토큰을 불러와서 일반 package처럼 private repository의 package를 설치할 수 있다.</p>
<p>설치할 때는 <code>powershell</code>이나 <code>git</code>을 관리자 모드로 열어야한다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install git+https://&#123;<span class="variable">$token</span>&#125;@github.com/yjinheon/toolbox</span><br></pre></td></tr></table></figure>


<h2 id="사용하기-amp-결론"><a href="#사용하기-amp-결론" class="headerlink" title="사용하기 &amp; 결론"></a>사용하기 &amp; 결론</h2><p>repository로 설치를 하고 불러올 때는 package명으로 불러와줘야 한다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> eda <span class="keyword">import</span> glimpse <span class="comment"># 최근에 넣어둔 eda용 헬퍼함수</span></span><br><span class="line"></span><br><span class="line">df = sns.load_dataset(<span class="string">&#x27;penguins&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">glimpse(df)</span><br><span class="line">Shape:  (<span class="number">344</span>, <span class="number">7</span>)</span><br><span class="line">species           <span class="built_in">object</span>   <span class="number">0</span> (<span class="number">0</span>%) NAs : Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adelie</span><br><span class="line">island            <span class="built_in">object</span>   <span class="number">0</span> (<span class="number">0</span>%) NAs : Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, Torgersen, Torg</span><br><span class="line">bill_length_mm    float64  <span class="number">2</span> (<span class="number">1</span>%) NAs : <span class="number">39.1</span>, <span class="number">39.5</span>, <span class="number">40.3</span>, nan, <span class="number">36.7</span>, <span class="number">39.3</span>, <span class="number">38.9</span>, <span class="number">39.2</span>, <span class="number">34.1</span>, <span class="number">42.0</span></span><br><span class="line">bill_depth_mm     float64  <span class="number">2</span> (<span class="number">1</span>%) NAs : <span class="number">18.7</span>, <span class="number">17.4</span>, <span class="number">18.0</span>, nan, <span class="number">19.3</span>, <span class="number">20.6</span>, <span class="number">17.8</span>, <span class="number">19.6</span>, <span class="number">18.1</span>, <span class="number">20.2</span></span><br><span class="line">flipper_length_mm float64  <span class="number">2</span> (<span class="number">1</span>%) NAs : <span class="number">181.0</span>, <span class="number">186.0</span>, <span class="number">195.0</span>, nan, <span class="number">193.0</span>, <span class="number">190.0</span>, <span class="number">181.0</span>, <span class="number">195.0</span>, <span class="number">193.0</span>, <span class="number">190.0</span></span><br><span class="line">body_mass_g       float64  <span class="number">2</span> (<span class="number">1</span>%) NAs : <span class="number">3750.0</span>, <span class="number">3800.0</span>, <span class="number">3250.0</span>, nan, <span class="number">3450.0</span>, <span class="number">3650.0</span>, <span class="number">3625.0</span>, <span class="number">4675.0</span>, <span class="number">3475.0</span>, <span class="number">4</span></span><br><span class="line">sex               <span class="built_in">object</span>  <span class="number">11</span> (<span class="number">3</span>%) NAs : Male, Female, Female, nan, Female, Male, Female, Male, nan, nan</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>아직 패키지만 만든 상태라서 편한지 어떤지는 모르겠다. 몇주 써보고 좀 익숙해져야 할 것 같다.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li><a href="https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token">Personal access token 만들기</a></li>
<li><a href="https://docs.readthedocs.io/en/stable/guides/private-python-packages.html">private-python-package</a></li>
<li><a href="https://towardsdatascience.com/create-your-custom-python-package-that-you-can-pip-install-from-your-git-repository-f90465867893">custom-package</a></li>
</ul>
]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
