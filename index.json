[{"categories":["Data Engineering"],"content":" 개요git 원격저장소 추가하기 정리 엄청 자주 하는 작업이지만 매번 찾아보면서 작업했기 때문에 이 참에 간단하게 정리한다. ","date":"2024-05-16","objectID":"/posts/02.de/de-ssh-git-remote-add/:1:0","series":null,"tags":["Git"],"title":"[Git]원격저장소 추가하기","uri":"/posts/02.de/de-ssh-git-remote-add/#개요"},{"categories":["Data Engineering"],"content":" 절차 git 저장소 만들기 git init 원격저장소 만들기(github) README, .gitignore 파일 만들지 말것. 원격저장소랑 로컬 저장소랑 충돌남 로컬 저장소와 원격 저장소 연결 git remote add origin \u003c원격저장소주소\u003e 로컬 수정사항 반영하기 # 로컬 수정사항 반영 git add . # commit git commit -m \"feat: first commit\" #commit 이력으로 remote repository에 업로드 git push -u origin main ","date":"2024-05-16","objectID":"/posts/02.de/de-ssh-git-remote-add/:2:0","series":null,"tags":["Git"],"title":"[Git]원격저장소 추가하기","uri":"/posts/02.de/de-ssh-git-remote-add/#절차"},{"categories":["Data Engineering"],"content":" 문제상황 SSH를 통해 git 저장소를 원격 저장소와 로컬에서 자동으로 동기화 하려함 cron으로 12시간 마다 저장소를 업데이트 하려 했는데 git push 할때 마다 ssh passphrase를 입력해야함 로컬에서 저장소 업데이트를 자동화 하려면 passphrase를 따로 입력받지 않고 스크립트에서 자동으로 배포할 수 있게끔 설정을 잡아줄 필요가 있음 ","date":"2024-05-15","objectID":"/posts/02.de/de-ssh-git-push/:1:0","series":null,"tags":["Git"],"title":"[Git]ssh passphrase없이 commit하기","uri":"/posts/02.de/de-ssh-git-push/#문제상황"},{"categories":["Data Engineering"],"content":" 해결1 eval \"$(ssh-agent -s)\" # ssh agent의 pid 확인 ssh-add 첫번째 방법은 세션 단위에서 passphrase를 매번 입력하지 않도록 설정하는 방식이다. 이 방식은 현재 세션에서만 유효하다. 즉, 세션을 종료하면 다시 passphrase를 입력해야 한다. ","date":"2024-05-15","objectID":"/posts/02.de/de-ssh-git-push/:2:0","series":null,"tags":["Git"],"title":"[Git]ssh passphrase없이 commit하기","uri":"/posts/02.de/de-ssh-git-push/#해결1"},{"categories":["Data Engineering"],"content":" 해결2ssh key를 사용할 때마다 passphrase를 입력하지 않도록 설정 bashrc에 아래 내용을 추가 env=~/.ssh/agent.env agent_load_env () { test -f \"$env\" \u0026\u0026 . \"$env\" \u003e| /dev/null ; } agent_start () { (umask 077; ssh-agent \u003e| \"$env\") . \"$env\" \u003e| /dev/null ; } agent_load_env # agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2=agent not running agent_run_state=$(ssh-add -l \u003e| /dev/null 2\u003e\u00261; echo $?) if [ ! \"$SSH_AUTH_SOCK\" ] || [ $agent_run_state = 2 ]; then agent_start ssh-add elif [ \"$SSH_AUTH_SOCK\" ] \u0026\u0026 [ $agent_run_state = 1 ]; then ssh-add fi unset env 로그인 시 자동으로 ssh-agent를 실행하고 ssh-add를 실행하여 passphrase를 입력하지 않도록 설정한다. 두번째 방법을 통해 crontab을 이용하여 자동으로 git 저장소를 업데이트하는 환경을 구축하였다. ","date":"2024-05-15","objectID":"/posts/02.de/de-ssh-git-push/:3:0","series":null,"tags":["Git"],"title":"[Git]ssh passphrase없이 commit하기","uri":"/posts/02.de/de-ssh-git-push/#해결2"},{"categories":["Data Engineering"],"content":" Reference https://www.asterhu.com/post/2023-12-21-use-ssh-github-push-crontab/ https://docs.github.com/en/authentication/connecting-to-github-with-ssh/working-with-ssh-key-passphrases?platform=windows ","date":"2024-05-15","objectID":"/posts/02.de/de-ssh-git-push/:4:0","series":null,"tags":["Git"],"title":"[Git]ssh passphrase없이 commit하기","uri":"/posts/02.de/de-ssh-git-push/#reference"},{"categories":"test","content":"첫번째 포스트 ","date":"2024-05-15","objectID":"/projets/01.ariflow_pipeline/:0:0","series":null,"tags":null,"title":"테스트 프로젝트","uri":"/projets/01.ariflow_pipeline/#"},{"categories":["Data Engineering"],"content":" Introduction 자주 쓰는 airflow cli 명령어들 정리 지속 업데이트 ","date":"2024-03-02","objectID":"/posts/02.de/de-airflow-03-cli_commands/:1:0","series":null,"tags":["Airflow"],"title":"[Airflow]CLI Commands","uri":"/posts/02.de/de-airflow-03-cli_commands/#introduction"},{"categories":["Data Engineering"],"content":" CLI Commands","date":"2024-03-02","objectID":"/posts/02.de/de-airflow-03-cli_commands/:2:0","series":null,"tags":["Airflow"],"title":"[Airflow]CLI Commands","uri":"/posts/02.de/de-airflow-03-cli_commands/#cli-commands"},{"categories":["Data Engineering"],"content":" Testing 실질적으로 가장 많이 사용하게되는 명령어 작업한 DAGd의 tasks가 잘 동작하는지 확인하기 위해 사용 과거시점도 execution_date로 전달 할 수 있기 때문에 backfilling에도 사용됨 airflow tasks test \u003cdag_id\u003e \u003ctask_id\u003e \u003cexecution_date\u003e ","date":"2024-03-02","objectID":"/posts/02.de/de-airflow-03-cli_commands/:2:1","series":null,"tags":["Airflow"],"title":"[Airflow]CLI Commands","uri":"/posts/02.de/de-airflow-03-cli_commands/#testing"},{"categories":["Data Engineering"],"content":" DB 메타데이터 데이터베이스 실행 airflow db init 메타데이터 DB 초기화 airflow db reset ","date":"2024-03-02","objectID":"/posts/02.de/de-airflow-03-cli_commands/:3:0","series":null,"tags":["Airflow"],"title":"[Airflow]CLI Commands","uri":"/posts/02.de/de-airflow-03-cli_commands/#db"},{"categories":["Data Engineering"],"content":" 개요리눅스 ec2 인스턴스에서 생성된 기본 timezone은 UTC이다. 이를 local KST로 변경하자. ","date":"2023-07-21","objectID":"/posts/02.de/de-linux-set_timezone/:1:0","series":null,"tags":["linux"],"title":"[linux]linux container timezone 설정","uri":"/posts/02.de/de-linux-set_timezone/#개요"},{"categories":["Data Engineering"],"content":" 1. timezone 확인date ","date":"2023-07-21","objectID":"/posts/02.de/de-linux-set_timezone/:2:0","series":null,"tags":["linux"],"title":"[linux]linux container timezone 설정","uri":"/posts/02.de/de-linux-set_timezone/#1-timezone-확인"},{"categories":["Data Engineering"],"content":" 2. timezone 변경 현재 timezone 이 설정된 symbolic link 삭제 sudo rm /etc/localtime symbolic link 재생성 sudo ln -s /usr/share/zoneinfo/Asia/Seoul /etc/localtime timezone 변경 확인 date ","date":"2023-07-21","objectID":"/posts/02.de/de-linux-set_timezone/:3:0","series":null,"tags":["linux"],"title":"[linux]linux container timezone 설정","uri":"/posts/02.de/de-linux-set_timezone/#2-timezone-변경"},{"categories":["Data Engineering"],"content":" 간단한 서브쿼리 용법 정리","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:1:0","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#간단한-서브쿼리-용법-정리"},{"categories":["Data Engineering"],"content":" Subquery Concept 서브쿼리 : 서브쿼리는 하나의 SQL쿼리 안에 포함된 다른 SQL쿼리를 말한다. 서브쿼리 사용상황 가장 기본적으로는 알려지지 않은 조건을 사용해서 조회해야할 때 DB에 접근하는 속도를 향상시킬 때 사용시 주의점 항상 괄호로 감싸서 사용할 것 서브쿼리의 결과가 2건 이상이라면(다중행) 반드시 비교연산자와 함께 사용한다, 서브쿼리 내에서는 order by 사용 못함( order by는 쿼리에서 하나만 사용) 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다. 질의 결과에 서브쿼리 컬럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 한다. 종류 단일 행 서브쿼리 : 특정 행을 반환. 이 행을 조건절도도 사용가능 ex) 평균값알아내는 서브쿼리를 통해 평균값 이상의 그룹을 출력 다중행 서브쿼리 : 결과가 2건이상 반환되는 서브쿼리. 반드시 비교연산자와 함께 사용. Where 절에 괄호로 들어간다. IN(서브쿼리) : 서브쿼리의 결과에 존재하는 값과 동일한 조건의미 ALL(서브쿼리) : 모든 값을 만족하는 조건 ANY(서브쿼리) : 비교연산자에 \"\u003e\" 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에 결과중에 가장 작은값보다 크면 만족한다. EXIST(서브쿼리) : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인. 존재유무만 확인하기에 1건만 찾으면 더 이상검색안함 다중 컬럼 서브쿼리 : 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인쿼리 조건과 동시에 비교되는 것. -- 다중컬럼 서브쿼리 select ord_num, agent_code, ord_date, ord_amount from orders where(agent_code, ord_amount) IN (SELECT agent_code, MIN(ord_amount) FROM orders GROUP BY agent_code); Where 절의 Subquery 비교연산자 IN 사용 # 특정 행 반환 SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = \"찾는 아이디\") ORDER BY first_name , last_name; MAX나 MIN 사용 # where 절에서 서브쿼리로 정의한 조건을 select 절에 쓸 수 있다. SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary = (SELECT MAX(salary) FROM employees) ORDER BY first_name , last_name; AVG로 조건걸기 SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary \u003e (SELECT AVG(salary) FROM employees); 서브쿼리 조건문처럼 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 WHERE Date = (SELECT MIN(date) FROM tutorial.sf_crime_incidents_2014_01 ) FROM 절의 Subquery(Inline View) SQL이 실행될 때만 동적으로 생성되는 Inline view SELECT MAX(items), MIN(items), FLOOR(AVG(items)) FROM (SELECT orderNumber, COUNT(orderNumber) AS items FROM orderdetails GROUP BY orderNumber) AS lineitems; 파생테이블은 반드시 alias를 가진다, select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드' select avg(review_count), max(review_count), min(review_count) from (select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드') as review_count_summary #서브쿼리로 탄생한 파생테이블은 반드시 alias를 가져야 한다 -- Join과 서브쿼리 같이 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 incidents JOIN ( SELECT date FROM tutorial.sf_crime_incidents_2014_01 ORDER BY date LIMIT 5 ) sub ON incidents.date = sub.date SELECT 절의 Subquery(Scala Subquery) SELECT 절 안에 SELECT가 있을 경우 Scala 서브쿼리라 부르며 기본적으로 한 행만 리턴한다. SELECT PLAYER, HEIGHT , (SELECT AVG(HEIGHT) FROM PLAYER X WHERE X.TEAM_ID = P.TEAM_ID) FROM PLAYER_P 기본적으로 outer join이 적용되어 있다. 쿼리 수행 횟수를 최소화하기 위해서 입력값과 출력값을 내부 캐시에 저장한다. 대용량 데이터를 처리할 경우 속도가 느려질 수 있다. SELECT A.PKID , A.TITLE , NVL(B.NAME, '탈퇴한 회원'), B.NAME , (SELECT COUNT(*) FROM REPLY WHERE P_PKID = B.PKID) AS COUNT1 FROM BOARD B LEFT OUTER JOIN MEMBER M ON B.MEM_NO = M.PKID ","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:1:1","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#subquery"},{"categories":["Data Engineering"],"content":" Subquery Concept 서브쿼리 : 서브쿼리는 하나의 SQL쿼리 안에 포함된 다른 SQL쿼리를 말한다. 서브쿼리 사용상황 가장 기본적으로는 알려지지 않은 조건을 사용해서 조회해야할 때 DB에 접근하는 속도를 향상시킬 때 사용시 주의점 항상 괄호로 감싸서 사용할 것 서브쿼리의 결과가 2건 이상이라면(다중행) 반드시 비교연산자와 함께 사용한다, 서브쿼리 내에서는 order by 사용 못함( order by는 쿼리에서 하나만 사용) 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다. 질의 결과에 서브쿼리 컬럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 한다. 종류 단일 행 서브쿼리 : 특정 행을 반환. 이 행을 조건절도도 사용가능 ex) 평균값알아내는 서브쿼리를 통해 평균값 이상의 그룹을 출력 다중행 서브쿼리 : 결과가 2건이상 반환되는 서브쿼리. 반드시 비교연산자와 함께 사용. Where 절에 괄호로 들어간다. IN(서브쿼리) : 서브쿼리의 결과에 존재하는 값과 동일한 조건의미 ALL(서브쿼리) : 모든 값을 만족하는 조건 ANY(서브쿼리) : 비교연산자에 \"\u003e\" 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에 결과중에 가장 작은값보다 크면 만족한다. EXIST(서브쿼리) : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인. 존재유무만 확인하기에 1건만 찾으면 더 이상검색안함 다중 컬럼 서브쿼리 : 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인쿼리 조건과 동시에 비교되는 것. -- 다중컬럼 서브쿼리 select ord_num, agent_code, ord_date, ord_amount from orders where(agent_code, ord_amount) IN (SELECT agent_code, MIN(ord_amount) FROM orders GROUP BY agent_code); Where 절의 Subquery 비교연산자 IN 사용 # 특정 행 반환 SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = \"찾는 아이디\") ORDER BY first_name , last_name; MAX나 MIN 사용 # where 절에서 서브쿼리로 정의한 조건을 select 절에 쓸 수 있다. SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary = (SELECT MAX(salary) FROM employees) ORDER BY first_name , last_name; AVG로 조건걸기 SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary \u003e (SELECT AVG(salary) FROM employees); 서브쿼리 조건문처럼 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 WHERE Date = (SELECT MIN(date) FROM tutorial.sf_crime_incidents_2014_01 ) FROM 절의 Subquery(Inline View) SQL이 실행될 때만 동적으로 생성되는 Inline view SELECT MAX(items), MIN(items), FLOOR(AVG(items)) FROM (SELECT orderNumber, COUNT(orderNumber) AS items FROM orderdetails GROUP BY orderNumber) AS lineitems; 파생테이블은 반드시 alias를 가진다, select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드' select avg(review_count), max(review_count), min(review_count) from (select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드') as review_count_summary #서브쿼리로 탄생한 파생테이블은 반드시 alias를 가져야 한다 -- Join과 서브쿼리 같이 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 incidents JOIN ( SELECT date FROM tutorial.sf_crime_incidents_2014_01 ORDER BY date LIMIT 5 ) sub ON incidents.date = sub.date SELECT 절의 Subquery(Scala Subquery) SELECT 절 안에 SELECT가 있을 경우 Scala 서브쿼리라 부르며 기본적으로 한 행만 리턴한다. SELECT PLAYER, HEIGHT , (SELECT AVG(HEIGHT) FROM PLAYER X WHERE X.TEAM_ID = P.TEAM_ID) FROM PLAYER_P 기본적으로 outer join이 적용되어 있다. 쿼리 수행 횟수를 최소화하기 위해서 입력값과 출력값을 내부 캐시에 저장한다. 대용량 데이터를 처리할 경우 속도가 느려질 수 있다. SELECT A.PKID , A.TITLE , NVL(B.NAME, '탈퇴한 회원'), B.NAME , (SELECT COUNT(*) FROM REPLY WHERE P_PKID = B.PKID) AS COUNT1 FROM BOARD B LEFT OUTER JOIN MEMBER M ON B.MEM_NO = M.PKID ","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:1:1","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#where-절의-subquery"},{"categories":["Data Engineering"],"content":" Subquery Concept 서브쿼리 : 서브쿼리는 하나의 SQL쿼리 안에 포함된 다른 SQL쿼리를 말한다. 서브쿼리 사용상황 가장 기본적으로는 알려지지 않은 조건을 사용해서 조회해야할 때 DB에 접근하는 속도를 향상시킬 때 사용시 주의점 항상 괄호로 감싸서 사용할 것 서브쿼리의 결과가 2건 이상이라면(다중행) 반드시 비교연산자와 함께 사용한다, 서브쿼리 내에서는 order by 사용 못함( order by는 쿼리에서 하나만 사용) 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다. 질의 결과에 서브쿼리 컬럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 한다. 종류 단일 행 서브쿼리 : 특정 행을 반환. 이 행을 조건절도도 사용가능 ex) 평균값알아내는 서브쿼리를 통해 평균값 이상의 그룹을 출력 다중행 서브쿼리 : 결과가 2건이상 반환되는 서브쿼리. 반드시 비교연산자와 함께 사용. Where 절에 괄호로 들어간다. IN(서브쿼리) : 서브쿼리의 결과에 존재하는 값과 동일한 조건의미 ALL(서브쿼리) : 모든 값을 만족하는 조건 ANY(서브쿼리) : 비교연산자에 \"\u003e\" 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에 결과중에 가장 작은값보다 크면 만족한다. EXIST(서브쿼리) : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인. 존재유무만 확인하기에 1건만 찾으면 더 이상검색안함 다중 컬럼 서브쿼리 : 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인쿼리 조건과 동시에 비교되는 것. -- 다중컬럼 서브쿼리 select ord_num, agent_code, ord_date, ord_amount from orders where(agent_code, ord_amount) IN (SELECT agent_code, MIN(ord_amount) FROM orders GROUP BY agent_code); Where 절의 Subquery 비교연산자 IN 사용 # 특정 행 반환 SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = \"찾는 아이디\") ORDER BY first_name , last_name; MAX나 MIN 사용 # where 절에서 서브쿼리로 정의한 조건을 select 절에 쓸 수 있다. SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary = (SELECT MAX(salary) FROM employees) ORDER BY first_name , last_name; AVG로 조건걸기 SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary \u003e (SELECT AVG(salary) FROM employees); 서브쿼리 조건문처럼 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 WHERE Date = (SELECT MIN(date) FROM tutorial.sf_crime_incidents_2014_01 ) FROM 절의 Subquery(Inline View) SQL이 실행될 때만 동적으로 생성되는 Inline view SELECT MAX(items), MIN(items), FLOOR(AVG(items)) FROM (SELECT orderNumber, COUNT(orderNumber) AS items FROM orderdetails GROUP BY orderNumber) AS lineitems; 파생테이블은 반드시 alias를 가진다, select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드' select avg(review_count), max(review_count), min(review_count) from (select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드') as review_count_summary #서브쿼리로 탄생한 파생테이블은 반드시 alias를 가져야 한다 -- Join과 서브쿼리 같이 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 incidents JOIN ( SELECT date FROM tutorial.sf_crime_incidents_2014_01 ORDER BY date LIMIT 5 ) sub ON incidents.date = sub.date SELECT 절의 Subquery(Scala Subquery) SELECT 절 안에 SELECT가 있을 경우 Scala 서브쿼리라 부르며 기본적으로 한 행만 리턴한다. SELECT PLAYER, HEIGHT , (SELECT AVG(HEIGHT) FROM PLAYER X WHERE X.TEAM_ID = P.TEAM_ID) FROM PLAYER_P 기본적으로 outer join이 적용되어 있다. 쿼리 수행 횟수를 최소화하기 위해서 입력값과 출력값을 내부 캐시에 저장한다. 대용량 데이터를 처리할 경우 속도가 느려질 수 있다. SELECT A.PKID , A.TITLE , NVL(B.NAME, '탈퇴한 회원'), B.NAME , (SELECT COUNT(*) FROM REPLY WHERE P_PKID = B.PKID) AS COUNT1 FROM BOARD B LEFT OUTER JOIN MEMBER M ON B.MEM_NO = M.PKID ","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:1:1","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#from-절의-subqueryinline-view"},{"categories":["Data Engineering"],"content":" Subquery Concept 서브쿼리 : 서브쿼리는 하나의 SQL쿼리 안에 포함된 다른 SQL쿼리를 말한다. 서브쿼리 사용상황 가장 기본적으로는 알려지지 않은 조건을 사용해서 조회해야할 때 DB에 접근하는 속도를 향상시킬 때 사용시 주의점 항상 괄호로 감싸서 사용할 것 서브쿼리의 결과가 2건 이상이라면(다중행) 반드시 비교연산자와 함께 사용한다, 서브쿼리 내에서는 order by 사용 못함( order by는 쿼리에서 하나만 사용) 서브쿼리는 메인쿼리의 컬럼을 모두 사용할 수 있지만, 메인쿼리는 서브쿼리의 컬럼을 사용할 수 없다. 질의 결과에 서브쿼리 컬럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 한다. 종류 단일 행 서브쿼리 : 특정 행을 반환. 이 행을 조건절도도 사용가능 ex) 평균값알아내는 서브쿼리를 통해 평균값 이상의 그룹을 출력 다중행 서브쿼리 : 결과가 2건이상 반환되는 서브쿼리. 반드시 비교연산자와 함께 사용. Where 절에 괄호로 들어간다. IN(서브쿼리) : 서브쿼리의 결과에 존재하는 값과 동일한 조건의미 ALL(서브쿼리) : 모든 값을 만족하는 조건 ANY(서브쿼리) : 비교연산자에 \"\u003e\" 를 썼다면 ANY가 어떤 하나라도 맞는지 조건이기 때문에 결과중에 가장 작은값보다 크면 만족한다. EXIST(서브쿼리) : 서브쿼리의 결과를 만족하는 값이 존재하는지 여부 확인. 존재유무만 확인하기에 1건만 찾으면 더 이상검색안함 다중 컬럼 서브쿼리 : 서브쿼리 결과로 여러 개의 컬럼이 반환되어 메인쿼리 조건과 동시에 비교되는 것. -- 다중컬럼 서브쿼리 select ord_num, agent_code, ord_date, ord_amount from orders where(agent_code, ord_amount) IN (SELECT agent_code, MIN(ord_amount) FROM orders GROUP BY agent_code); Where 절의 Subquery 비교연산자 IN 사용 # 특정 행 반환 SELECT employee_id, first_name, last_name FROM employees WHERE department_id IN (SELECT department_id FROM departments WHERE location_id = \"찾는 아이디\") ORDER BY first_name , last_name; MAX나 MIN 사용 # where 절에서 서브쿼리로 정의한 조건을 select 절에 쓸 수 있다. SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary = (SELECT MAX(salary) FROM employees) ORDER BY first_name , last_name; AVG로 조건걸기 SELECT employee_id, first_name, last_name, salary FROM employees WHERE salary \u003e (SELECT AVG(salary) FROM employees); 서브쿼리 조건문처럼 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 WHERE Date = (SELECT MIN(date) FROM tutorial.sf_crime_incidents_2014_01 ) FROM 절의 Subquery(Inline View) SQL이 실행될 때만 동적으로 생성되는 Inline view SELECT MAX(items), MIN(items), FLOOR(AVG(items)) FROM (SELECT orderNumber, COUNT(orderNumber) AS items FROM orderdetails GROUP BY orderNumber) AS lineitems; 파생테이블은 반드시 alias를 가진다, select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드' select avg(review_count), max(review_count), min(review_count) from (select substring(address,1,2) as region, count(*) as review_count from review as r left outer join member as m on r.mem_id = m.id group by substring(address,1,2) having region is not null and region != '안드') as review_count_summary #서브쿼리로 탄생한 파생테이블은 반드시 alias를 가져야 한다 -- Join과 서브쿼리 같이 사용하기 SELECT * FROM tutorial.sf_crime_incidents_2014_01 incidents JOIN ( SELECT date FROM tutorial.sf_crime_incidents_2014_01 ORDER BY date LIMIT 5 ) sub ON incidents.date = sub.date SELECT 절의 Subquery(Scala Subquery) SELECT 절 안에 SELECT가 있을 경우 Scala 서브쿼리라 부르며 기본적으로 한 행만 리턴한다. SELECT PLAYER, HEIGHT , (SELECT AVG(HEIGHT) FROM PLAYER X WHERE X.TEAM_ID = P.TEAM_ID) FROM PLAYER_P 기본적으로 outer join이 적용되어 있다. 쿼리 수행 횟수를 최소화하기 위해서 입력값과 출력값을 내부 캐시에 저장한다. 대용량 데이터를 처리할 경우 속도가 느려질 수 있다. SELECT A.PKID , A.TITLE , NVL(B.NAME, '탈퇴한 회원'), B.NAME , (SELECT COUNT(*) FROM REPLY WHERE P_PKID = B.PKID) AS COUNT1 FROM BOARD B LEFT OUTER JOIN MEMBER M ON B.MEM_NO = M.PKID ","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:1:1","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#select-절의-subqueryscala-subquery"},{"categories":["Data Engineering"],"content":" References \u0026 annotation https://mode.com/sql-tutorial/sql-sub-queries/ https://www.mysqltutorial.org/mysql-subquery/ ","date":"2021-08-21","objectID":"/posts/02.de/de-sql-subquery/:2:0","series":null,"tags":["sql"],"title":"[SQL]간단한 서브쿼리 용법","uri":"/posts/02.de/de-sql-subquery/#references--annotation"},{"categories":["Data Engineering"],"content":" Direction Operators리눅스에서 데이터의 입출력방향을 다루는 연산자는 Direction Operators이다. Direction Operators에는 \u003e와 \u003e\u003e가 있다. \u003e와 \u003e\u003e 의 차이점은 Linux에서의 데이터의 출력방향이다. \u003e : 기존 파일을 덮어쓰거나 지정한 이름의 파일이 디렉토리에 없는 경우 파일을 생성한다 \u003e\u003e : 기존 파일에 추가하거나 지정한 이름의 파일이 디렉토리에 없는 경우 파일을 생성한다. 정리하면 다음과 같다. 파일을 수정하고 기존 데이터를 덮어쓰려면 \u003e 사용. 파일에 무언가를 추가하려면 \u003e\u003e 연산자를 사용. ","date":"2021-06-01","objectID":"/posts/02.de/de-bash-direction_operators/:1:0","series":null,"tags":["Linux","Bash"],"title":"[Bash]Direction Operators","uri":"/posts/02.de/de-bash-direction_operators/#direction-operators"},{"categories":["Data Engineering"],"content":" 예제 \u003e 연산자 사용 # a.txt 파일에 \"Hello World\"를 출력한다. echo \"Hello World\" \u003e a.txt \u003e\u003e 연산자 사용 a.txt 파일에 \"Goodbye World\"를 추가한다. echo \"Goodbye World\" \u003e\u003e a.txt cat a.txt Hello World Goodbye World ","date":"2021-06-01","objectID":"/posts/02.de/de-bash-direction_operators/:2:0","series":null,"tags":["Linux","Bash"],"title":"[Bash]Direction Operators","uri":"/posts/02.de/de-bash-direction_operators/#예제"},{"categories":["Data Engineering"],"content":" References https://www.tutorialspoint.com/unix/unix-io-redirections.htm ","date":"2021-06-01","objectID":"/posts/02.de/de-bash-direction_operators/:3:0","series":null,"tags":["Linux","Bash"],"title":"[Bash]Direction Operators","uri":"/posts/02.de/de-bash-direction_operators/#references"},{"categories":["Data Engineering"],"content":" 도커 이미지","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:1:0","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#도커-이미지"},{"categories":["Data Engineering"],"content":" docker imagesdocker images ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:1:1","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#docker-images"},{"categories":["Data Engineering"],"content":" 도커 컨테이너","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:2:0","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#도커-컨테이너"},{"categories":["Data Engineering"],"content":" docker run: 도커 이미지 실행 docker run -v [로컬경로]:/[컨테이너경로] -d -p 8080:8080 yjinheon/test:latest ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:2:1","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#docker-run"},{"categories":["Data Engineering"],"content":" docker psdocker ps # 모든 컨테이너를 보여준다 docker ps -a # 실행중인 docker containner id 전부 가져오기 docker ps | awk 'NR \u003e 1 {print $1}' # 맨위의 docker container 하나만 가져오기 docker ps | awk 'NR \u003e 1 {print $1; exit}' ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:2:2","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#docker-ps"},{"categories":["Data Engineering"],"content":" docker rm# 컨테이너 ID로 삭제 docker rm [컨테이너 ID] # 컨테이너 명으로 삭제 docker rm [컨네이너 명] # 실행중인 컨테이너 강제삭제 docker rm -f [컨테이너명] id가 none인 도커 이미지 전부 삭제 docker rmi $(docker images -a|grep \"\u003cnone\u003e\"|awk '$1==\"\u003cnone\u003e\" {print $3}') ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:2:3","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#docker-rm"},{"categories":["Data Engineering"],"content":" 도커 볼륨","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:3:0","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#도커-볼륨"},{"categories":["Data Engineering"],"content":" docker volumedocker create volume [볼륨명] ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:3:1","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#docker-volume"},{"categories":["Data Engineering"],"content":" References https://docs.docker.com/engine/reference/commandline/ ","date":"2021-06-01","objectID":"/posts/02.de/de-docker-commands/:4:0","series":null,"tags":["Docker"],"title":"[Docker]Docker 자주쓰는 명령어","uri":"/posts/02.de/de-docker-commands/#references"},{"categories":["Data Engineering"],"content":" 유저 편집기 변경 nano -\u003e nvim 현재 편집기 확인 # 현제 편집기 확인 echo $EDITOR 현재 쉘의 편집기를 리눅스 환경변수로 등록 nvim ~/.bashrc export VISUAL=\"nvim\" export EDITOR=$VISUAL source ~/.bashrc ","date":"2021-05-02","objectID":"/posts/02.de/de-seteditor/:1:0","series":null,"tags":["Neovim"],"title":"[Linux]기본 에디터 neovim으로 변경하기","uri":"/posts/02.de/de-seteditor/#유저-편집기-변경"},{"categories":["Data Engineering"],"content":" 글로벌 설정 sudo nvim /etc/profile ","date":"2021-05-02","objectID":"/posts/02.de/de-seteditor/:2:0","series":null,"tags":["Neovim"],"title":"[Linux]기본 에디터 neovim으로 변경하기","uri":"/posts/02.de/de-seteditor/#글로벌-설정"},{"categories":null,"content":" 소개안녕하세요. 이것저것 하고 있습니다. 데이터 엔지니어링, 데이터 분석에 관심이 많습니다. ","date":"0001-01-01","objectID":"/about/:1:0","series":null,"tags":null,"title":"","uri":"/about/#소개"},{"categories":null,"content":" Fundamentals of Data Engineering","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:0:0","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#fundamentals-of-data-engineering"},{"categories":null,"content":" Types of Data Stuctured Data Unstructured Data Semi-Structured Data ","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:1:0","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#types-of-data"},{"categories":null,"content":" Properties of Data Volume Velocity Variety ","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:2:0","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#properties-of-data"},{"categories":null,"content":" Data Warehouse and Data Lake","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:3:0","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#data-warehouse-and-data-lake"},{"categories":null,"content":" Data Warehouse :A centralized repository optimized for analysis where data from different sources is stored in Stuctured format Amazon Redshift Google Bigquery MS Aure Data Warehouse ","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:3:1","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#data-warehouse-"},{"categories":null,"content":" Data Lake :A storage repository that holds vast amount of raw data in its native format, including Stuctured, Semi-Structured, Unstructured data ","date":"0001-01-01","objectID":"/posts/10.project/aws_dea/01.main/:3:2","series":null,"tags":null,"title":"","uri":"/posts/10.project/aws_dea/01.main/#data-lake-"}]